[
  {
    "url": "https://api.github.com/repos/OpenRA/OpenRA/issues/comments/152917049",
    "html_url": "https://github.com/OpenRA/OpenRA/issues/8890#issuecomment-152917049",
    "issue_url": "https://api.github.com/repos/OpenRA/OpenRA/issues/8890",
    "id": 152917049,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjkxNzA0OQ==",
    "user": {
      "login": "Phrohdoh",
      "id": 4861023,
      "node_id": "MDQ6VXNlcjQ4NjEwMjM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4861023?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Phrohdoh",
      "html_url": "https://github.com/Phrohdoh",
      "followers_url": "https://api.github.com/users/Phrohdoh/followers",
      "following_url": "https://api.github.com/users/Phrohdoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Phrohdoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Phrohdoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Phrohdoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Phrohdoh/orgs",
      "repos_url": "https://api.github.com/users/Phrohdoh/repos",
      "events_url": "https://api.github.com/users/Phrohdoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Phrohdoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-02T05:11:30Z",
    "updated_at": "2015-11-02T13:26:42Z",
    "author_association": "MEMBER",
    "body": "Investigation:\n\n**Using ActorInfo as a basis**:\n\n**Constructor**: `ActorInfo(string name, MiniYaml node, Dictionary<string, MiniYaml> allUnits)`\n\n`name`: The actor definition's top-level node's key. (`E1`, `Medic`, etc)\n\n`node`: The `MiniYaml` representation of the textual definition\n\n``` yaml\nE1:\n    Inherits: ^Soldier\n    Buildable:\n        Queue: Infantry\n        BuildPaletteOrder: 10\n        Prerequisites: ~barracks\n```\n\n``` yaml\nkey:\n    key: value\n    key:\n        key: value\n        key: value\n        key: value\n```\n\n`allUnits`: A dictionary with keys that are `ActorInfo.Name.ToLowerInvariant()`s\n\n``` yaml\n# This dict contains (as the name suggests) *all* definitions as MiniYaml structures\nallUnits[\"e1\"] =\nE1:\n    Inherits: ^Soldier\n    Buildable:\n        Queue: Infantry\n        BuildPaletteOrder: 10\n        Prerequisites: ~barracks\n...\n```\n\nSnippet from `ActorInfo`'s ctor:\n\n``` csharp\n                // Guard against circular inheritance\n                allParents.Add(name);\n                var mergedNode = MergeWithParents(node, allUnits, allParents).ToDictionary();\n\n                Name = name;\n\n                foreach (var traitNode in mergedNode)\n                {\n                    ...\n                }\n```\n\n``` csharp\n        static MiniYaml MergeWithParents(MiniYaml node, Dictionary<string, MiniYaml> allUnits, HashSet<string> allParents)\n        {\n            var parents = GetParents(node, allUnits);\n            ...\n        }\n```\n\n``` csharp\n        static Dictionary<string, MiniYaml> GetParents(MiniYaml node, Dictionary<string, MiniYaml> allUnits)\n        {\n            return node.Nodes.Where(n => n.Key == \"Inherits\" || n.Key.StartsWith(\"Inherits@\"))\n                .ToDictionary(n => n.Value.Value, n =>\n            {\n                MiniYaml i;\n                    if (!allUnits.TryGetValue(n.Value.Value, out i))\n                        throw new YamlException(\n                            \"Bogus inheritance -- parent type {0} does not exist\".F(n.Value.Value));\n\n                return i;\n            });\n        }\n```\n\nAll appears fine and dandy with borrowing this approach except for a small difference.\n- Sequences are parsed (**once!**) top-down and independently of one-another\n- Actor definitions are parsed in two phases:\n  - Creating the relevant `Dictionary<string, MiniYaml>` from files on disk\n  - Building `ActorInfo`s from the existing dictionaries\n\nThis means ActorInfos have access to all other relevant MiniYaml structures they may need while sequences have absolutely no extra information.\n\n---\n\n`DefaultSpriteSequence.ParseSequence`:\n\n``` csharp\n        public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node)\n        {\n            var sequences = new Dictionary<string, ISpriteSequence>();\n            var nodes = node.Value.ToDictionary();\n\n            MiniYaml defaults;\n            if (nodes.TryGetValue(\"Defaults\", out defaults))\n            {\n                nodes.Remove(\"Defaults\");\n                nodes = nodes.ToDictionary(kv => kv.Key, kv => MiniYaml.MergeStrict(kv.Value, defaults));\n\n                foreach (var n in nodes)\n                    n.Value.Value = n.Value.Value ?? defaults.Value;\n            }\n\n            ...\n\n            return new ReadOnlyDictionary<string, ISpriteSequence>(sequences);\n        }\n```\n\nThe important lines here are:\n\n``` csharp\n                foreach (var n in nodes)\n                    n.Value.Value = n.Value.Value ?? defaults.Value;\n```\n\nWhich of course uses the values found in `Defaults` for a key if the key is omitted.\nThis is similar to what we are after but still lies in its own little world with no knowledge of other sequences.\n\n---\n\n**Why I cannot do anything with this information**:\n\nI cannot make out where we are constructing `allUnits`, but I feel if we rewrite sequence parsing to be a two-step process we basically get all of the merging logic for free as it already exists for `ActorInfo` construction\n\n---\n\n**Edit 1**:\n\n`ParseSequences` contains `nodes = nodes.ToDictionary(kv => kv.Key, kv => MiniYaml.MergeStrict(kv.Value, defaults));` which seems a bit odd as we are explicitly 'merging' Defaults in just below this by using the values it provides if we don't override them below.\n\nThis will need to be understood before I can make sense of even the current sequence parsing.\n\n**Edit 2**:\n\nSequences are parsed from `MiniYaml` into `ISpriteSequence` here:\n`SequenceProvider:126`: `Sequences Load(List<MiniYamlNode> sequenceNodes)`\n\nWhich leads me to:\n\n``` diff\ndiff --git a/OpenRA.Game/Graphics/SequenceProvider.cs b/OpenRA.Game/Graphics/SequenceProvider.cs\nindex 198f9ff..5d5a79c 100644\n--- a/OpenRA.Game/Graphics/SequenceProvider.cs\n+++ b/OpenRA.Game/Graphics/SequenceProvider.cs\n@@ -40,7 +40,7 @@ public interface ISpriteSequence\n    public interface ISpriteSequenceLoader\n    {\n        Action<string> OnMissingSpriteError { get; set; }\n-       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node);\n+       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node, List<MiniYamlNode> allSequences);\n    }\n\n    public class SequenceProvider\n@@ -144,7 +144,7 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                    items.Add(node.Key, t);\n                else\n                {\n-                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node));\n+                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node, nodes));\n                    sequenceCache.Add(key, t);\n                    items.Add(node.Key, t);\n                }\ndiff --git a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\nindex 74571a0..e7ae0fc 100644\n--- a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n+++ b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n@@ -26,7 +26,7 @@ public virtual ISpriteSequence CreateSequence(ModData modData, TileSet tileSet,\n            return new DefaultSpriteSequence(modData, tileSet, cache, this, sequence, animation, info);\n        }\n\n-       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node)\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node, List<MiniYamlNode> allSequences)\n        {\n            var sequences = new Dictionary<string, ISpriteSequence>();\n            var nodes = node.Value.ToDictionary();\n```\n"
  },
  {
    "url": "https://api.github.com/repos/OpenRA/OpenRA/issues/comments/153210387",
    "html_url": "https://github.com/OpenRA/OpenRA/issues/8890#issuecomment-153210387",
    "issue_url": "https://api.github.com/repos/OpenRA/OpenRA/issues/8890",
    "id": 153210387,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MzIxMDM4Nw==",
    "user": {
      "login": "Phrohdoh",
      "id": 4861023,
      "node_id": "MDQ6VXNlcjQ4NjEwMjM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4861023?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Phrohdoh",
      "html_url": "https://github.com/Phrohdoh",
      "followers_url": "https://api.github.com/users/Phrohdoh/followers",
      "following_url": "https://api.github.com/users/Phrohdoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Phrohdoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Phrohdoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Phrohdoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Phrohdoh/orgs",
      "repos_url": "https://api.github.com/users/Phrohdoh/repos",
      "events_url": "https://api.github.com/users/Phrohdoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Phrohdoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-03T01:19:11Z",
    "updated_at": "2015-11-03T01:22:28Z",
    "author_association": "MEMBER",
    "body": "I have this now but the merging is incorrect:\n\n``` diff\ndiff --git a/OpenRA.Game/Graphics/SequenceProvider.cs b/OpenRA.Game/Graphics/SequenceProvider.cs\nindex 198f9ff..bc5c761 100644\n--- a/OpenRA.Game/Graphics/SequenceProvider.cs\n+++ b/OpenRA.Game/Graphics/SequenceProvider.cs\n@@ -40,7 +40,7 @@ public interface ISpriteSequence\n    public interface ISpriteSequenceLoader\n    {\n        Action<string> OnMissingSpriteError { get; set; }\n-       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node);\n+       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYaml node, string name, Dictionary<string, MiniYaml> allSequences);\n    }\n\n    public class SequenceProvider\n@@ -119,8 +119,13 @@ public SequenceCache(ModData modData, TileSet tileSet)\n\n        public Sequences LoadSequences(Map map)\n        {\n+           if (map != null)\n+               foreach (var def in map.SequenceDefinitions)\n+                   Console.WriteLine(\"{0}: {1}\", def.Key, def.Value);\n+\n            using (new Support.PerfTimer(\"LoadSequences\"))\n                return Load(map != null ? map.SequenceDefinitions : new List<MiniYamlNode>());\n+\n        }\n\n        Sequences Load(List<MiniYamlNode> sequenceNodes)\n@@ -131,6 +136,15 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                .Select(s => MiniYaml.FromFile(s))\n                .Aggregate(sequenceNodes, MiniYaml.MergeLiberal);\n\n+           var allSequences = new Dictionary<string, MiniYaml>();\n+           foreach (var n in nodes)\n+           {\n+               if (allSequences.ContainsKey(n.Key))\n+                   continue;\n+\n+               allSequences.Add(n.Key, n.Value);\n+           }\n+\n            var items = new Dictionary<string, UnitSequences>();\n            foreach (var n in nodes)\n            {\n@@ -144,7 +158,8 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                    items.Add(node.Key, t);\n                else\n                {\n-                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node));\n+                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node.Value, node.Key, allSequences));\n+                   //t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node, nodes));\n                    sequenceCache.Add(key, t);\n                    items.Add(node.Key, t);\n                }\ndiff --git a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\nindex 74571a0..e2916db 100644\n--- a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n+++ b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n@@ -26,7 +26,107 @@ public virtual ISpriteSequence CreateSequence(ModData modData, TileSet tileSet,\n            return new DefaultSpriteSequence(modData, tileSet, cache, this, sequence, animation, info);\n        }\n\n-       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node)\n+//     /* new\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache,\n+           MiniYaml node, string name, Dictionary<string, MiniYaml> allSequences)\n+       {\n+           var sequences = new Dictionary<string, ISpriteSequence>();\n+\n+           try\n+           {\n+               var nodes = node.ToDictionary();\n+               MiniYaml defaults;\n+               if (nodes.TryGetValue(\"Defaults\", out defaults))\n+               {\n+                   nodes.Remove(\"Defaults\");\n+                   nodes = nodes.ToDictionary(kv => kv.Key, kv => MiniYaml.MergeStrict(kv.Value, defaults));\n+\n+                   foreach (var n in nodes)\n+                       n.Value.Value = n.Value.Value ?? defaults.Value;\n+               }\n+\n+               node = MiniYaml.FromDictionary(nodes);\n+\n+               var allParents = new HashSet<string>();\n+               var abstractType = name.StartsWith(\"^\");\n+\n+               allParents.Add(name);\n+\n+               var mergedNode = MergeWithParents(node, allSequences, allParents).ToDictionary();\n+\n+               // debuggy\n+               Console.WriteLine(\"Reading \" + name);\n+               foreach (var kvp in mergedNode)\n+               {\n+                   Console.WriteLine(\"Key={0}, Children={1}\", kvp.Key, kvp.Value.Nodes.Count());\n+               }\n+               Console.WriteLine();\n+               // end debuggy\n+\n+               foreach (var kvp in mergedNode)\n+               {\n+                   if (kvp.Key[0] == '-')\n+                       throw new YamlException(\"Bogus sequence removal: \" + kvp.Key);\n+\n+                   if (kvp.Key != \"Inherits\" && !kvp.Key.StartsWith(\"Inherits@\"))\n+                   {\n+                       try\n+                       {\n+                           sequences.Add(kvp.Key, CreateSequence(modData, tileSet, cache, kvp.Key, kvp.Key, kvp.Value));\n+                       }\n+                       catch (FieldLoader.MissingFieldsException e)\n+                       {\n+                           if (!abstractType)\n+                               throw new YamlException(e.Message);\n+                       }\n+                   }\n+               }\n+           }\n+           catch (YamlException e)\n+           {\n+               throw new YamlException(\"Actor type {0}: {1}\".F(name, e.Message));\n+           }\n+           catch (FileNotFoundException ex)\n+           {\n+               // Eat the FileNotFound exceptions from missing sprites\n+               OnMissingSpriteError(ex.Message);\n+           }\n+\n+           return new ReadOnlyDictionary<string, ISpriteSequence>(sequences);\n+       }\n+\n+       static Dictionary<string, MiniYaml> GetParents(MiniYaml node, Dictionary<string, MiniYaml> allUnits)\n+       {\n+           return node.Nodes.Where(n => n.Key == \"Inherits\" || n.Key.StartsWith(\"Inherits@\"))\n+               .ToDictionary(n => n.Value.Value, n =>\n+                   {\n+                       MiniYaml i;\n+                       if (!allUnits.TryGetValue(n.Value.Value, out i))\n+                           throw new YamlException(\n+                               \"Bogus inheritance -- parent type {0} does not exist\".F(n.Value.Value));\n+\n+                       return i;\n+                   });\n+       }\n+\n+       static MiniYaml MergeWithParents(MiniYaml node, Dictionary<string, MiniYaml> allSequences, HashSet<string> allParents)\n+       {\n+           var parents = GetParents(node, allSequences);\n+\n+           foreach (var kv in parents)\n+           {\n+               if (!allParents.Add(kv.Key))\n+                   throw new YamlException(\n+                       \"Bogus inheritance -- duplicate inheritance of {0}.\".F(kv.Key));\n+\n+               node = MiniYaml.MergeStrict(node, MergeWithParents(kv.Value, allSequences, allParents));\n+           }\n+\n+           return node;\n+       }\n+//     new end */\n+\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node, List<MiniYamlNode> allSequences)\n        {\n            var sequences = new Dictionary<string, ISpriteSequence>();\n            var nodes = node.Value.ToDictionary();\ndiff --git a/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs b/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\nindex 2d4d159..20cbb88 100644\n--- a/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\n+++ b/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\n@@ -36,7 +36,7 @@ public void Run(ModData modData, string[] args)\n            {\n                var ts = new TileSet(Game.ModData, t);\n                Console.WriteLine(\"Tileset: \" + ts.Name);\n-               var sc = new SpriteCache(modData.SpriteLoaders, new SheetBuilder(SheetType.Indexed));\n+               //var sc = new SpriteCache(modData.SpriteLoaders, new SheetBuilder(SheetType.Indexed));\n                var sequenceFiles = modData.Manifest.Sequences;\n\n                var nodes = sequenceFiles\n@@ -44,7 +44,8 @@ public void Run(ModData modData, string[] args)\n                    .Aggregate(MiniYaml.MergeLiberal);\n\n                foreach (var n in nodes)\n-                   Game.ModData.SpriteSequenceLoader.ParseSequences(Game.ModData, ts, sc, n);\n+                   ;\n+                   //Game.ModData.SpriteSequenceLoader.ParseSequences(Game.ModData, ts, sc, n);\n            }\n        }\n    }\n```\n"
  },
  {
    "url": "https://api.github.com/repos/OpenRA/OpenRA/issues/comments/153452307",
    "html_url": "https://github.com/OpenRA/OpenRA/issues/8890#issuecomment-153452307",
    "issue_url": "https://api.github.com/repos/OpenRA/OpenRA/issues/8890",
    "id": 153452307,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MzQ1MjMwNw==",
    "user": {
      "login": "Phrohdoh",
      "id": 4861023,
      "node_id": "MDQ6VXNlcjQ4NjEwMjM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4861023?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Phrohdoh",
      "html_url": "https://github.com/Phrohdoh",
      "followers_url": "https://api.github.com/users/Phrohdoh/followers",
      "following_url": "https://api.github.com/users/Phrohdoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Phrohdoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Phrohdoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Phrohdoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Phrohdoh/orgs",
      "repos_url": "https://api.github.com/users/Phrohdoh/repos",
      "events_url": "https://api.github.com/users/Phrohdoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Phrohdoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-03T18:51:46Z",
    "updated_at": "2015-11-03T19:17:06Z",
    "author_association": "MEMBER",
    "body": "The issue is this right here:\n\n![image](http://i.imgur.com/xUixcrr.png)\n\nI want `x.Value.Value`, but this uses `x.Value.ToString()`.\n\nThis can be confirmed using:\n\n``` csharp\n        public static MiniYaml FromDictionary2(Dictionary<string, MiniYaml> dict)\n        {\n            foreach (var k in dict.Keys.Select(kk => kk))\n            {\n                var v = dict[k];\n                Console.WriteLine(\"\\t{0}: {1}\", k, v.Value ?? \"\");\n                foreach (var vv in v.Nodes)\n                    Console.WriteLine(\"\\t\\t{0}: {1}\", vv.Key, vv.Value.Value);\n            }\n\n            return new MiniYaml(null, dict.Select(x => new MiniYamlNode(x.Key, new MiniYaml(x.Value.Value))).ToList());\n        }\n```\n\nWhich puts me at:\n\n``` diff\ndiff --git a/OpenRA.Game/Graphics/SequenceProvider.cs b/OpenRA.Game/Graphics/SequenceProvider.cs\nindex 198f9ff..d17d0c5 100644\n--- a/OpenRA.Game/Graphics/SequenceProvider.cs\n+++ b/OpenRA.Game/Graphics/SequenceProvider.cs\n@@ -40,7 +40,7 @@ public interface ISpriteSequence\n    public interface ISpriteSequenceLoader\n    {\n        Action<string> OnMissingSpriteError { get; set; }\n-       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node);\n+       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYaml node, string name, Dictionary<string, MiniYaml> allSequences);\n    }\n\n    public class SequenceProvider\n@@ -131,6 +131,17 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                .Select(s => MiniYaml.FromFile(s))\n                .Aggregate(sequenceNodes, MiniYaml.MergeLiberal);\n\n+           var allSequences = new Dictionary<string, MiniYaml>();\n+           foreach (var n in nodes)\n+           {\n+               /*\n+               if (allSequences.ContainsKey(n.Key))\n+                   continue;\n+               */\n+\n+               allSequences.Add(n.Key, n.Value);\n+           }\n+\n            var items = new Dictionary<string, UnitSequences>();\n            foreach (var n in nodes)\n            {\n@@ -144,7 +155,8 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                    items.Add(node.Key, t);\n                else\n                {\n-                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node));\n+                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node.Value, node.Key, allSequences));\n+                   //t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node, nodes));\n                    sequenceCache.Add(key, t);\n                    items.Add(node.Key, t);\n                }\ndiff --git a/OpenRA.Game/MiniYaml.cs b/OpenRA.Game/MiniYaml.cs\nindex 3075bf2..60a423e 100644\n--- a/OpenRA.Game/MiniYaml.cs\n+++ b/OpenRA.Game/MiniYaml.cs\n@@ -133,6 +133,19 @@ public MiniYaml(string value, List<MiniYamlNode> nodes)\n            return new MiniYaml(null, dict.Select(x => new MiniYamlNode(x.Key.ToString(), new MiniYaml(x.Value.ToString()))).ToList());\n        }\n\n+       public static MiniYaml FromDictionary2(Dictionary<string, MiniYaml> dict)\n+       {\n+           foreach (var k in dict.Keys.Select(kk => kk))\n+           {\n+               var v = dict[k];\n+               Console.WriteLine(\"\\t{0}: {1}\", k, string.IsNullOrWhiteSpace(v.Value) ? \"\" : v.Value);\n+               foreach (var vv in v.Nodes)\n+                   Console.WriteLine(\"\\t\\t{0}: {1}\", vv.Key, vv.Value.Value);\n+           }\n+\n+           return new MiniYaml(null, dict.Select(x => new MiniYamlNode(x.Key, new MiniYaml(x.Value.Value))).ToList());\n+       }\n+\n        public static MiniYaml FromList<T>(List<T> list)\n        {\n            return new MiniYaml(null, list.Select(x => new MiniYamlNode(x.ToString(), new MiniYaml(null))).ToList());\ndiff --git a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\nindex 74571a0..a90a2fb 100644\n--- a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n+++ b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n@@ -26,7 +26,100 @@ public virtual ISpriteSequence CreateSequence(ModData modData, TileSet tileSet,\n            return new DefaultSpriteSequence(modData, tileSet, cache, this, sequence, animation, info);\n        }\n\n-       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node)\n+//     /* new\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache,\n+           MiniYaml node, string name, Dictionary<string, MiniYaml> allSequences)\n+       {\n+           var sequences = new Dictionary<string, ISpriteSequence>();\n+\n+           try\n+           {\n+               var nodes = node.ToDictionary();\n+\n+               MiniYaml defaults;\n+               if (nodes.TryGetValue(\"Defaults\", out defaults))\n+               {\n+                   nodes.Remove(\"Defaults\");\n+                   nodes = nodes.ToDictionary(kv => kv.Key, kv => MiniYaml.MergeStrict(kv.Value, defaults));\n+\n+                   foreach (var n in nodes)\n+                       n.Value.Value = n.Value.Value ?? defaults.Value;\n+               }\n+\n+               Console.WriteLine(name + \":\");\n+               node = MiniYaml.FromDictionary2(nodes);\n+\n+               var allParents = new HashSet<string>();\n+               var abstractType = name.StartsWith(\"^\");\n+\n+               allParents.Add(name);\n+\n+               var mergedNode = MergeWithParents(node, allSequences, allParents).ToDictionary();\n+\n+               foreach (var kvp in mergedNode)\n+               {\n+                   if (kvp.Key[0] == '-')\n+                       throw new YamlException(\"Bogus sequence removal: \" + kvp.Key);\n+\n+                   if (kvp.Key != \"Inherits\" && !kvp.Key.StartsWith(\"Inherits@\"))\n+                   {\n+                       try\n+                       {\n+                           sequences.Add(kvp.Key, CreateSequence(modData, tileSet, cache, kvp.Key, kvp.Key, kvp.Value));\n+                       }\n+                       catch (FieldLoader.MissingFieldsException e)\n+                       {\n+                           if (!abstractType)\n+                               throw new YamlException(e.Message);\n+                       }\n+                   }\n+               }\n+           }\n+           catch (YamlException e)\n+           {\n+               throw new YamlException(\"Sequence `{0}`: {1}\".F(name, e.Message));\n+           }\n+           catch (FileNotFoundException ex)\n+           {\n+               // Eat the FileNotFound exceptions from missing sprites\n+               OnMissingSpriteError(ex.Message);\n+           }\n+\n+           return new ReadOnlyDictionary<string, ISpriteSequence>(sequences);\n+       }\n+\n+       static Dictionary<string, MiniYaml> GetParents(MiniYaml node, Dictionary<string, MiniYaml> allSequences)\n+       {\n+           return node.Nodes.Where(n => n.Key == \"Inherits\" || n.Key.StartsWith(\"Inherits@\"))\n+               .ToDictionary(n => n.Value.Value, n =>\n+                   {\n+                       MiniYaml i;\n+                       if (!allSequences.TryGetValue(n.Value.Value, out i))\n+                           throw new YamlException(\n+                               \"Bogus inheritance -- parent type {0} does not exist\".F(n.Value.Value));\n+\n+                       return i;\n+                   });\n+       }\n+\n+       static MiniYaml MergeWithParents(MiniYaml node, Dictionary<string, MiniYaml> allSequences, HashSet<string> allParents)\n+       {\n+           var parents = GetParents(node, allSequences);\n+\n+           foreach (var kv in parents)\n+           {\n+               if (!allParents.Add(kv.Key))\n+                   throw new YamlException(\n+                       \"Bogus inheritance -- duplicate inheritance of {0}.\".F(kv.Key));\n+\n+               node = MiniYaml.MergeStrict(node, MergeWithParents(kv.Value, allSequences, allParents));\n+           }\n+\n+           return node;\n+       }\n+//     new end */\n+\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node, List<MiniYamlNode> allSequences)\n        {\n            var sequences = new Dictionary<string, ISpriteSequence>();\n            var nodes = node.Value.ToDictionary();\ndiff --git a/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs b/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\nindex 2d4d159..20cbb88 100644\n--- a/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\n+++ b/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\n@@ -36,7 +36,7 @@ public void Run(ModData modData, string[] args)\n            {\n                var ts = new TileSet(Game.ModData, t);\n                Console.WriteLine(\"Tileset: \" + ts.Name);\n-               var sc = new SpriteCache(modData.SpriteLoaders, new SheetBuilder(SheetType.Indexed));\n+               //var sc = new SpriteCache(modData.SpriteLoaders, new SheetBuilder(SheetType.Indexed));\n                var sequenceFiles = modData.Manifest.Sequences;\n\n                var nodes = sequenceFiles\n@@ -44,7 +44,8 @@ public void Run(ModData modData, string[] args)\n                    .Aggregate(MiniYaml.MergeLiberal);\n\n                foreach (var n in nodes)\n-                   Game.ModData.SpriteSequenceLoader.ParseSequences(Game.ModData, ts, sc, n);\n+                   ;\n+                   //Game.ModData.SpriteSequenceLoader.ParseSequences(Game.ModData, ts, sc, n);\n            }\n        }\n    }\n```\n\nWhich will reconstruct the sequence yaml correctly (and print it out with the above snippet), but values are not merged properly yet.\n"
  },
  {
    "url": "https://api.github.com/repos/OpenRA/OpenRA/issues/comments/155258528",
    "html_url": "https://github.com/OpenRA/OpenRA/issues/8890#issuecomment-155258528",
    "issue_url": "https://api.github.com/repos/OpenRA/OpenRA/issues/8890",
    "id": 155258528,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTI1ODUyOA==",
    "user": {
      "login": "Phrohdoh",
      "id": 4861023,
      "node_id": "MDQ6VXNlcjQ4NjEwMjM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4861023?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Phrohdoh",
      "html_url": "https://github.com/Phrohdoh",
      "followers_url": "https://api.github.com/users/Phrohdoh/followers",
      "following_url": "https://api.github.com/users/Phrohdoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Phrohdoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Phrohdoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Phrohdoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Phrohdoh/orgs",
      "repos_url": "https://api.github.com/users/Phrohdoh/repos",
      "events_url": "https://api.github.com/users/Phrohdoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Phrohdoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-10T01:57:47Z",
    "updated_at": "2015-11-10T01:57:47Z",
    "author_association": "MEMBER",
    "body": "This now merges parents properly and from what I've noticed most values:\n\n``` diff\ndiff --git a/OpenRA.Game/Graphics/SequenceProvider.cs b/OpenRA.Game/Graphics/SequenceProvider.cs\nindex 198f9ff..d17d0c5 100644\n--- a/OpenRA.Game/Graphics/SequenceProvider.cs\n+++ b/OpenRA.Game/Graphics/SequenceProvider.cs\n@@ -40,7 +40,7 @@ public interface ISpriteSequence\n    public interface ISpriteSequenceLoader\n    {\n        Action<string> OnMissingSpriteError { get; set; }\n-       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node);\n+       IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYaml node, string name, Dictionary<string, MiniYaml> allSequences);\n    }\n\n    public class SequenceProvider\n@@ -131,6 +131,17 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                .Select(s => MiniYaml.FromFile(s))\n                .Aggregate(sequenceNodes, MiniYaml.MergeLiberal);\n\n+           var allSequences = new Dictionary<string, MiniYaml>();\n+           foreach (var n in nodes)\n+           {\n+               /*\n+               if (allSequences.ContainsKey(n.Key))\n+                   continue;\n+               */\n+\n+               allSequences.Add(n.Key, n.Value);\n+           }\n+\n            var items = new Dictionary<string, UnitSequences>();\n            foreach (var n in nodes)\n            {\n@@ -144,7 +155,8 @@ Sequences Load(List<MiniYamlNode> sequenceNodes)\n                    items.Add(node.Key, t);\n                else\n                {\n-                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node));\n+                   t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node.Value, node.Key, allSequences));\n+                   //t = Exts.Lazy(() => modData.SpriteSequenceLoader.ParseSequences(modData, tileSet, SpriteCache, node, nodes));\n                    sequenceCache.Add(key, t);\n                    items.Add(node.Key, t);\n                }\ndiff --git a/OpenRA.Game/MiniYaml.cs b/OpenRA.Game/MiniYaml.cs\nindex 3075bf2..30d36e6 100644\n--- a/OpenRA.Game/MiniYaml.cs\n+++ b/OpenRA.Game/MiniYaml.cs\n@@ -133,6 +133,11 @@ public MiniYaml(string value, List<MiniYamlNode> nodes)\n            return new MiniYaml(null, dict.Select(x => new MiniYamlNode(x.Key.ToString(), new MiniYaml(x.Value.ToString()))).ToList());\n        }\n\n+       public static MiniYaml FromDictionary2(Dictionary<string, MiniYaml> dict)\n+       {\n+           return new MiniYaml(null, dict.Select(x => new MiniYamlNode(x.Key, new MiniYaml(x.Value.Value))).ToList());\n+       }\n+\n        public static MiniYaml FromList<T>(List<T> list)\n        {\n            return new MiniYaml(null, list.Select(x => new MiniYamlNode(x.ToString(), new MiniYaml(null))).ToList());\ndiff --git a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\nindex 74571a0..71cff26 100644\n--- a/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n+++ b/OpenRA.Mods.Common/Graphics/DefaultSpriteSequence.cs\n@@ -26,7 +26,104 @@ public virtual ISpriteSequence CreateSequence(ModData modData, TileSet tileSet,\n            return new DefaultSpriteSequence(modData, tileSet, cache, this, sequence, animation, info);\n        }\n\n-       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node)\n+//     /* new\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache,\n+           MiniYaml node, string name, Dictionary<string, MiniYaml> allSequences)\n+       {\n+           var sequences = new Dictionary<string, ISpriteSequence>();\n+\n+           try\n+           {\n+               var nodes = node.ToDictionary();\n+\n+               Console.WriteLine(\"Parsing sequences for `{0}`\", name);\n+\n+               MiniYaml defaults;\n+               if (nodes.TryGetValue(\"Defaults\", out defaults))\n+               {\n+                   nodes.Remove(\"Defaults\");\n+                   nodes = nodes.ToDictionary(kv => kv.Key, kv => MiniYaml.MergeStrict(kv.Value, defaults));\n+\n+                   foreach (var n in nodes)\n+                       n.Value.Value = n.Value.Value ?? defaults.Value;\n+               }\n+\n+               node = MiniYaml.FromDictionary2(nodes);\n+\n+               var allParents = new HashSet<string>();\n+               var abstractType = name.StartsWith(\"^\");\n+\n+               allParents.Add(name);\n+\n+               var mergedNode = MergeWithParents(name, node, allSequences, allParents).ToDictionary();\n+\n+               foreach (var kvp in mergedNode)\n+               {\n+                   if (kvp.Key[0] == '-')\n+                       throw new YamlException(\"Bogus sequence removal: \" + kvp.Key);\n+\n+                   if (kvp.Key != \"Inherits\" && !kvp.Key.StartsWith(\"Inherits@\"))\n+                   {\n+                       try\n+                       {\n+                           sequences.Add(kvp.Key, CreateSequence(modData, tileSet, cache, kvp.Key, kvp.Key, kvp.Value));\n+                       }\n+                       catch (FieldLoader.MissingFieldsException e)\n+                       {\n+                           if (!abstractType)\n+                               throw new YamlException(e.Message);\n+                       }\n+                   }\n+               }\n+           }\n+           catch (YamlException e)\n+           {\n+               throw new YamlException(\"Sequence `{0}`: {1}\".F(name, e.Message));\n+           }\n+           catch (FileNotFoundException ex)\n+           {\n+               // Eat the FileNotFound exceptions from missing sprites\n+               OnMissingSpriteError(ex.Message);\n+           }\n+\n+           return new ReadOnlyDictionary<string, ISpriteSequence>(sequences);\n+       }\n+\n+       static Dictionary<string, MiniYaml> GetParents(MiniYaml node, Dictionary<string, MiniYaml> allSequences)\n+       {\n+           return node.Nodes.Where(n => n.Key == \"Inherits\" || n.Key.StartsWith(\"Inherits@\"))\n+               .ToDictionary(n => n.Value.Value, n =>\n+                   {\n+                       MiniYaml i;\n+                       if (!allSequences.TryGetValue(n.Value.Value, out i))\n+                           throw new YamlException(\n+                               \"Bogus inheritance -- parent type {0} does not exist\".F(n.Value.Value));\n+\n+                       return i;\n+                   });\n+       }\n+\n+       static MiniYaml MergeWithParents(string name, MiniYaml node, Dictionary<string, MiniYaml> allSequences, HashSet<string> allParents)\n+       {\n+           var parents = GetParents(node, allSequences);\n+\n+           if (parents.Count > 0)\n+               Console.WriteLine(\"Merging {0} with {1} parent(s)\", name, parents.Count);\n+\n+           foreach (var kv in parents)\n+           {\n+               if (!allParents.Add(kv.Key))\n+                   throw new YamlException(\n+                       \"Bogus inheritance -- duplicate inheritance of {0}.\".F(kv.Key));\n+\n+               node = MiniYaml.MergeStrict(node, MergeWithParents(name, kv.Value, allSequences, allParents));\n+           }\n+\n+           return node;\n+       }\n+//     new end */\n+\n+       public IReadOnlyDictionary<string, ISpriteSequence> ParseSequences(ModData modData, TileSet tileSet, SpriteCache cache, MiniYamlNode node, List<MiniYamlNode> allSequences)\n        {\n            var sequences = new Dictionary<string, ISpriteSequence>();\n            var nodes = node.Value.ToDictionary();\ndiff --git a/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs b/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\nindex 2d4d159..20cbb88 100644\n--- a/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\n+++ b/OpenRA.Mods.Common/UtilityCommands/CheckSequenceSprites.cs\n@@ -36,7 +36,7 @@ public void Run(ModData modData, string[] args)\n            {\n                var ts = new TileSet(Game.ModData, t);\n                Console.WriteLine(\"Tileset: \" + ts.Name);\n-               var sc = new SpriteCache(modData.SpriteLoaders, new SheetBuilder(SheetType.Indexed));\n+               //var sc = new SpriteCache(modData.SpriteLoaders, new SheetBuilder(SheetType.Indexed));\n                var sequenceFiles = modData.Manifest.Sequences;\n\n                var nodes = sequenceFiles\n@@ -44,7 +44,8 @@ public void Run(ModData modData, string[] args)\n                    .Aggregate(MiniYaml.MergeLiberal);\n\n                foreach (var n in nodes)\n-                   Game.ModData.SpriteSequenceLoader.ParseSequences(Game.ModData, ts, sc, n);\n+                   ;\n+                   //Game.ModData.SpriteSequenceLoader.ParseSequences(Game.ModData, ts, sc, n);\n            }\n        }\n    }\ndiff --git a/mods/ts/sequences/aircraft.yaml b/mods/ts/sequences/aircraft.yaml\nindex 97811dc..4173e70 100644\n--- a/mods/ts/sequences/aircraft.yaml\n+++ b/mods/ts/sequences/aircraft.yaml\n@@ -1,4 +1,8 @@\n+^idler:\n+   idle:\n+\n orca:\n+   Inherits@idle: ^idler\n    icon: orcaicon\n\n orcab:\n@@ -19,4 +23,4 @@ apache:\n        Length: 8\n\n orcatran:\n-   icon: crryicon\n\\ No newline at end of file\n+   icon: crryicon\ndiff --git a/mods/ts/sequences/voxels.yaml b/mods/ts/sequences/voxels.yaml\nindex 8b06b25..5963636 100644\n--- a/mods/ts/sequences/voxels.yaml\n+++ b/mods/ts/sequences/voxels.yaml\n@@ -1,3 +1,6 @@\n+^idler:\n+   idle:\n+\n mcv:\n    idle:\n\n@@ -173,4 +176,4 @@ sonic:\n #  idle:\n\n dpod:\n-   idle:\n\\ No newline at end of file\n+   idle:\n```\n\nBut (in TS) I now get:\n\n``` c#\nException of type `System.InvalidOperationException`: Unit `resources` does not have a sequence named `tib01`\n  at OpenRA.Graphics.SequenceProvider.GetSequence (System.String unitName, System.String sequenceName) [0x0006b] in /Users/thill/projects/openra/OpenRA.Game//Graphics/SequenceProvider.cs:68\n  at OpenRA.Traits.ResourceType..ctor (OpenRA.Traits.ResourceTypeInfo info, OpenRA.World world) [0x0004b] in /Users/thill/projects/openra/OpenRA.Game//Traits/World/ResourceType.cs:50\n  at OpenRA.Traits.ResourceTypeInfo.Create (OpenRA.ActorInitializer init) [0x00008] in /Users/thill/projects/openra/OpenRA.Game//Traits/World/ResourceType.cs:35\n  at OpenRA.Actor..ctor (OpenRA.World world, System.String name, OpenRA.Primitives.TypeDictionary initDict) [0x000b2] in /Users/thill/projects/openra/OpenRA.Game//Actor.cs:91\n  at OpenRA.World.CreateActor (Boolean addToWorld, System.String name, OpenRA.Primitives.TypeDictionary initDict) [0x00004] in /Users/thill/projects/openra/OpenRA.Game//World.cs:215\n  at OpenRA.World.CreateActor (System.String name, OpenRA.Primitives.TypeDictionary initDict) [0x00005] in /Users/thill/projects/openra/OpenRA.Game//World.cs:210\n  at OpenRA.World..ctor (OpenRA.Map map, OpenRA.Network.OrderManager orderManager, WorldType type) [0x00145] in /Users/thill/projects/openra/OpenRA.Game//World.cs:153\n  at OpenRA.Game.StartGame (System.String mapUID, WorldType type) [0x00074] in /Users/thill/projects/openra/OpenRA.Game//Game.cs:154\n  at OpenRA.Game.LoadShellMap () [0x00019] in /Users/thill/projects/openra/OpenRA.Game//Game.cs:396\n  at OpenRA.Mods.Common.LoadScreens.BlankLoadScreen.StartGame (OpenRA.Arguments args) [0x0012c] in /Users/thill/projects/openra/OpenRA.Mods.Common//LoadScreens/BlankLoadScreen.cs:77\n  at OpenRA.Game.InitializeMod (System.String mod, OpenRA.Arguments args) [0x00373] in /Users/thill/projects/openra/OpenRA.Game//Game.cs:352\n  at OpenRA.Game.Initialize (OpenRA.Arguments args) [0x00278] in /Users/thill/projects/openra/OpenRA.Game//Game.cs:250\n  at OpenRA.Program.Run (System.String[] args) [0x00007] in /Users/thill/projects/openra/OpenRA.Game//Support/Program.cs:115\n  at OpenRA.Program.Main (System.String[] args) [0x00050] in /Users/thill/projects/openra/OpenRA.Game//Support/Program.cs:39\n```\n"
  },
  {
    "url": "https://api.github.com/repos/OpenRA/OpenRA/issues/comments/155549065",
    "html_url": "https://github.com/OpenRA/OpenRA/issues/8890#issuecomment-155549065",
    "issue_url": "https://api.github.com/repos/OpenRA/OpenRA/issues/8890",
    "id": 155549065,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTU0OTA2NQ==",
    "user": {
      "login": "Phrohdoh",
      "id": 4861023,
      "node_id": "MDQ6VXNlcjQ4NjEwMjM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4861023?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Phrohdoh",
      "html_url": "https://github.com/Phrohdoh",
      "followers_url": "https://api.github.com/users/Phrohdoh/followers",
      "following_url": "https://api.github.com/users/Phrohdoh/following{/other_user}",
      "gists_url": "https://api.github.com/users/Phrohdoh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Phrohdoh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Phrohdoh/subscriptions",
      "organizations_url": "https://api.github.com/users/Phrohdoh/orgs",
      "repos_url": "https://api.github.com/users/Phrohdoh/repos",
      "events_url": "https://api.github.com/users/Phrohdoh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Phrohdoh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-10T19:59:26Z",
    "updated_at": "2015-11-10T19:59:26Z",
    "author_association": "MEMBER",
    "body": "I'm at the point of being unable to continue on my own.\nHere's a branch: [feat#merge_sequences](https://github.com/Phrohdoh/OpenRA/tree/feat%23merge_sequences)\n"
  }
]
