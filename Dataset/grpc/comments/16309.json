[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/412061078",
    "html_url": "https://github.com/grpc/grpc/issues/16309#issuecomment-412061078",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/16309",
    "id": 412061078,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjA2MTA3OA==",
    "user": {
      "login": "nicolasnoble",
      "id": 7281574,
      "node_id": "MDQ6VXNlcjcyODE1NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7281574?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicolasnoble",
      "html_url": "https://github.com/nicolasnoble",
      "followers_url": "https://api.github.com/users/nicolasnoble/followers",
      "following_url": "https://api.github.com/users/nicolasnoble/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicolasnoble/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicolasnoble/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicolasnoble/subscriptions",
      "organizations_url": "https://api.github.com/users/nicolasnoble/orgs",
      "repos_url": "https://api.github.com/users/nicolasnoble/repos",
      "events_url": "https://api.github.com/users/nicolasnoble/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicolasnoble/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T11:57:17Z",
    "updated_at": "2018-08-10T11:57:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "Without any more specific way to reproduce the problem, this is going to be difficult to troubleshoot. "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/412074170",
    "html_url": "https://github.com/grpc/grpc/issues/16309#issuecomment-412074170",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/16309",
    "id": 412074170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjA3NDE3MA==",
    "user": {
      "login": "Iliych",
      "id": 42270809,
      "node_id": "MDQ6VXNlcjQyMjcwODA5",
      "avatar_url": "https://avatars0.githubusercontent.com/u/42270809?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Iliych",
      "html_url": "https://github.com/Iliych",
      "followers_url": "https://api.github.com/users/Iliych/followers",
      "following_url": "https://api.github.com/users/Iliych/following{/other_user}",
      "gists_url": "https://api.github.com/users/Iliych/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Iliych/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Iliych/subscriptions",
      "organizations_url": "https://api.github.com/users/Iliych/orgs",
      "repos_url": "https://api.github.com/users/Iliych/repos",
      "events_url": "https://api.github.com/users/Iliych/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Iliych/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T12:56:46Z",
    "updated_at": "2018-08-10T12:56:46Z",
    "author_association": "NONE",
    "body": "There are no specific way to reproduce the problem.\r\nI extracted a problem piece of the code from a grpc code into a separate application (may be it helps).\r\nThe code can work well the whole day, but if the error occurs once, then it does not work any more.\r\n\r\nRemark: after bind call status == -1 and error == 10013.\r\n\r\n```cpp\r\n#include \"stdafx.h\"\r\n\r\n#include <winsock2.h>\r\n#include <ws2tcpip.h>\r\n\r\n// must be included after the above\r\n#include <mswsock.h>\r\n\r\n\r\n#pragma comment(lib, \"ws2_32.lib\")\r\n\r\n#include <exception>\r\n#include <string>\r\n\r\ntypedef struct sockaddr grpc_sockaddr;\r\ntypedef struct sockaddr_in grpc_sockaddr_in;\r\ntypedef struct in_addr grpc_in_addr;\r\ntypedef struct sockaddr_in6 grpc_sockaddr_in6;\r\ntypedef struct in6_addr grpc_in6_addr;\r\n\r\n#define GRPC_INET_ADDRSTRLEN INET_ADDRSTRLEN\r\n#define GRPC_INET6_ADDRSTRLEN INET6_ADDRSTRLEN\r\n\r\n#define GRPC_SOCK_STREAM SOCK_STREAM\r\n#define GRPC_SOCK_DGRAM SOCK_DGRAM\r\n\r\n#define GRPC_AF_UNSPEC AF_UNSPEC\r\n#define GRPC_AF_UNIX AF_UNIX\r\n#define GRPC_AF_INET AF_INET\r\n#define GRPC_AF_INET6 AF_INET6\r\n\r\n#define GRPC_AI_PASSIVE AI_PASSIVE\r\n\r\n#define GRPC_MAX_SOCKADDR_SIZE 128\r\n\r\ntypedef struct {\r\n\tchar addr[GRPC_MAX_SOCKADDR_SIZE];\r\n\tsocklen_t len;\r\n} grpc_resolved_address;\r\n\r\n\r\nstatic const uint8_t kV4MappedPrefix[] = { 0, 0, 0, 0, 0,    0,\r\n0, 0, 0, 0, 0xff, 0xff };\r\n\r\nint grpc_sockaddr_to_v4mapped(const grpc_resolved_address* resolved_addr,\r\n\tgrpc_resolved_address* resolved_addr6_out) {\r\n\tif (!(resolved_addr != resolved_addr6_out))\r\n\t{\r\n\t\tauto k = 1;\r\n\t\tauto str = std::to_string(__LINE__);\r\n\t\tthrow std::exception(str.c_str());\r\n\t}\r\n\tconst grpc_sockaddr* addr =\r\n\t\treinterpret_cast<const grpc_sockaddr*>(resolved_addr->addr);\r\n\tgrpc_sockaddr_in6* addr6_out =\r\n\t\treinterpret_cast<grpc_sockaddr_in6*>(resolved_addr6_out->addr);\r\n\tif (addr->sa_family == GRPC_AF_INET) {\r\n\t\tconst grpc_sockaddr_in* addr4 =\r\n\t\t\treinterpret_cast<const grpc_sockaddr_in*>(addr);\r\n\t\tmemset(resolved_addr6_out, 0, sizeof(*resolved_addr6_out));\r\n\t\taddr6_out->sin6_family = GRPC_AF_INET6;\r\n\t\tmemcpy(&addr6_out->sin6_addr.s6_addr[0], kV4MappedPrefix, 12);\r\n\t\tmemcpy(&addr6_out->sin6_addr.s6_addr[12], &addr4->sin_addr, 4);\r\n\t\taddr6_out->sin6_port = addr4->sin_port;\r\n\t\tresolved_addr6_out->len = static_cast<socklen_t>(sizeof(grpc_sockaddr_in6));\r\n\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nuint16_t grpc_htons(uint16_t hostshort) { return htons(hostshort); }\r\n\r\nint grpc_inet_pton(int af, const char* src, void* dst) {\r\n\treturn inet_pton(af, src, dst);\r\n}\r\n\r\nvoid fill_host(grpc_resolved_address* addr)\r\n{\r\n\tmemset(addr, 0, sizeof(*addr));\r\n\taddr->len = static_cast<socklen_t>(sizeof(grpc_sockaddr_in));\r\n\r\n\tgrpc_sockaddr_in* in = reinterpret_cast<grpc_sockaddr_in*>(addr->addr);\r\n\tin->sin_family = GRPC_AF_INET;\r\n\tconst char* host = \"10.*.*.*\";\r\n\tif (grpc_inet_pton(GRPC_AF_INET, host, &in->sin_addr) == 0) {\r\n\t\tauto k = -1;\r\n\t}\r\n\tint port_num = 7779;\r\n\tin->sin_port = grpc_htons(static_cast<uint16_t>(port_num));\r\n}\r\n\r\n\r\nvoid grpc_sockaddr_make_wildcard6(int port,\r\n\tgrpc_resolved_address* resolved_wild_out) {\r\n\tgrpc_sockaddr_in6* wild_out =\r\n\t\treinterpret_cast<grpc_sockaddr_in6*>(resolved_wild_out->addr);\r\n\tif (!(port >= 0 && port < 65536))\r\n\t{\r\n\t\tauto str = std::to_string(__LINE__);\r\n\t\tthrow std::exception(str.c_str());\r\n\t}\r\n\tmemset(resolved_wild_out, 0, sizeof(*resolved_wild_out));\r\n\twild_out->sin6_family = GRPC_AF_INET6;\r\n\twild_out->sin6_port = grpc_htons(static_cast<uint16_t>(port));\r\n\tresolved_wild_out->len = static_cast<socklen_t>(sizeof(grpc_sockaddr_in6));\r\n}\r\n\r\n#define GRPC_FIONBIO FIONBIO\r\n\r\nstatic int set_non_block(SOCKET sock) {\r\n\tint status;\r\n\tuint32_t param = 1;\r\n\tDWORD ret;\r\n\tstatus = WSAIoctl(sock, GRPC_FIONBIO, &param, sizeof(param), NULL, 0, &ret,\r\n\t\tNULL, NULL);\r\n\treturn status;\r\n}\r\n\r\nstatic int set_dualstack(SOCKET sock) {\r\n\tint status;\r\n\tunsigned long param = 0;\r\n\tstatus = setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&param,\r\n\t\tsizeof(param));\r\n\treturn status;\r\n}\r\n\r\nstatic int enable_loopback_fast_path(SOCKET sock) {\r\n\tint status;\r\n\tuint32_t param = 1;\r\n\tDWORD ret;\r\n\tstatus = WSAIoctl(sock, /*SIO_LOOPBACK_FAST_PATH==*/_WSAIOW(IOC_VENDOR, 16),\r\n\t\t&param, sizeof(param), NULL, 0, &ret, 0, 0);\r\n\tif (status == SOCKET_ERROR) {\r\n\t\tstatus = WSAGetLastError();\r\n\t}\r\n\treturn status;\r\n}\r\n\r\n#define GRPC_ERROR_NONE 0\r\n\r\nint grpc_tcp_prepare_socket(SOCKET sock) {\r\n\tint err;\r\n\terr = set_non_block(sock);\r\n\tif (err != GRPC_ERROR_NONE) return err;\r\n\terr = set_dualstack(sock);\r\n\tif (err != GRPC_ERROR_NONE) return err;\r\n\terr = enable_loopback_fast_path(sock);\r\n\tif (err != GRPC_ERROR_NONE) return err;\r\n\treturn 0;\r\n}\r\n\r\n\r\n\r\n\r\nvoid test()\r\n{\r\n\r\n\tSOCKET sock = INVALID_SOCKET;\r\n\tBOOL success;\r\n\tint status;\r\n\tgrpc_resolved_address addr6_v4mapped;\r\n\tgrpc_resolved_address local_address;\r\n\tLPFN_CONNECTEX ConnectEx;\r\n\tGUID guid = WSAID_CONNECTEX;\r\n\tDWORD ioctl_num_bytes;\r\n\r\n\tint error = 0;\r\n\r\n\tgrpc_resolved_address a;\r\n\r\n\tgrpc_resolved_address* addr = &a;\r\n\tfill_host(addr);\r\n\r\n\t/* Use dualstack sockets where available. */\r\n\tif (grpc_sockaddr_to_v4mapped(addr, &addr6_v4mapped)) {\r\n\t\taddr = &addr6_v4mapped;\r\n\t}\r\n\r\n\tsock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, NULL, 0,\r\n\t\tWSA_FLAG_OVERLAPPED);\r\n\tif (sock == INVALID_SOCKET) {\r\n\t\terror = WSAGetLastError();\r\n\t\tauto str = std::to_string(__LINE__);\r\n\t\tthrow std::exception(str.c_str());\r\n\t}\r\n\r\n\terror = grpc_tcp_prepare_socket(sock);\r\n\t//if (error != GRPC_ERROR_NONE) {\r\n\r\n\t//}\r\n\r\n\t/* Grab the function pointer for ConnectEx for that specific socket.\r\n\tIt may change depending on the interface. */\r\n\tstatus =\r\n\tWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, sizeof(guid),\r\n\t\t&ConnectEx, sizeof(ConnectEx), &ioctl_num_bytes, NULL, NULL);\r\n\r\n\tif (status != 0) {\r\n\t\terror = WSAGetLastError();\r\n\t}\r\n\r\n\tgrpc_sockaddr_make_wildcard6(0, &local_address);\r\n\r\n\tstatus =\r\n\tbind(sock, (grpc_sockaddr*)&local_address.addr, (int)local_address.len);\r\n\tif (status != 0) {\r\n\t\terror = WSAGetLastError();\r\n\t\tauto str = std::to_string(__LINE__);\r\n\t\tthrow std::exception(str.c_str());\r\n\t}\r\n\r\n}\r\n\r\nstatic void winsock_init(void) {\r\n\tWSADATA wsaData;\r\n\tint status = WSAStartup(MAKEWORD(2, 0), &wsaData);\r\n\t//\r\n}\r\n\r\nstatic void winsock_shutdown(void) {\r\n\tint status = WSACleanup();\r\n\t//GPR_ASSERT(status == 0);\r\n}\r\n\r\nint main()\r\n{\r\n\twinsock_init();\r\n\ttry {\r\n\t\ttest();\r\n\t}\r\n\tcatch (std::exception const & ex)\r\n\t{\r\n\t\tauto s = ex.what();\r\n\t}\r\n\twinsock_shutdown();\r\n    return 0;\r\n}\r\n\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/412078504",
    "html_url": "https://github.com/grpc/grpc/issues/16309#issuecomment-412078504",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/16309",
    "id": 412078504,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjA3ODUwNA==",
    "user": {
      "login": "nicolasnoble",
      "id": 7281574,
      "node_id": "MDQ6VXNlcjcyODE1NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7281574?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nicolasnoble",
      "html_url": "https://github.com/nicolasnoble",
      "followers_url": "https://api.github.com/users/nicolasnoble/followers",
      "following_url": "https://api.github.com/users/nicolasnoble/following{/other_user}",
      "gists_url": "https://api.github.com/users/nicolasnoble/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nicolasnoble/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nicolasnoble/subscriptions",
      "organizations_url": "https://api.github.com/users/nicolasnoble/orgs",
      "repos_url": "https://api.github.com/users/nicolasnoble/repos",
      "events_url": "https://api.github.com/users/nicolasnoble/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nicolasnoble/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-10T13:14:37Z",
    "updated_at": "2018-08-10T13:14:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "That... sounds like port exhaustion. There's an upper limit in any\noperating system as to how many concurrent connection can be made.\n\nOn Fri, Aug 10, 2018 at 2:57 PM, Iliych <notifications@github.com> wrote:\n\n> There are no specific way to reproduce the problem.\n> I extracted a problem piece of the code from a grpc code into a separate\n> application (may be it helps).\n> The code can work well the whole day, but if the error occurs once, then\n> it does not work any more.\n>\n> Remark: after bind call status == -1 and error == 10013.\n>\n> #include \"stdafx.h\"\n>\n> #include <winsock2.h>\n> #include <ws2tcpip.h>\n> // must be included after the above\n> #include <mswsock.h>\n>\n>\n> #pragma comment(lib, \"ws2_32.lib\")\n>\n> #include <exception>\n> #include <string>\n> typedef struct sockaddr grpc_sockaddr;typedef struct sockaddr_in grpc_sockaddr_in;typedef struct in_addr grpc_in_addr;typedef struct sockaddr_in6 grpc_sockaddr_in6;typedef struct in6_addr grpc_in6_addr;\n>\n> #define GRPC_INET_ADDRSTRLEN INET_ADDRSTRLEN\n> #define GRPC_INET6_ADDRSTRLEN INET6_ADDRSTRLEN\n>\n> #define GRPC_SOCK_STREAM SOCK_STREAM\n> #define GRPC_SOCK_DGRAM SOCK_DGRAM\n>\n> #define GRPC_AF_UNSPEC AF_UNSPEC\n> #define GRPC_AF_UNIX AF_UNIX\n> #define GRPC_AF_INET AF_INET\n> #define GRPC_AF_INET6 AF_INET6\n>\n> #define GRPC_AI_PASSIVE AI_PASSIVE\n>\n> #define GRPC_MAX_SOCKADDR_SIZE 128\n> typedef struct {\n> \tchar addr[GRPC_MAX_SOCKADDR_SIZE];\n> \tsocklen_t len;\n> } grpc_resolved_address;\n>\n> static const uint8_t kV4MappedPrefix[] = { 0, 0, 0, 0, 0,    0,0, 0, 0, 0, 0xff, 0xff };\n> int grpc_sockaddr_to_v4mapped(const grpc_resolved_address* resolved_addr,\n> \tgrpc_resolved_address* resolved_addr6_out) {\n> \tif (!(resolved_addr != resolved_addr6_out))\n> \t{\n> \t\tauto k = 1;\n> \t\tauto str = std::to_string(__LINE__);\n> \t\tthrow std::exception(str.c_str());\n> \t}\n> \tconst grpc_sockaddr* addr =\n> \t\treinterpret_cast<const grpc_sockaddr*>(resolved_addr->addr);\n> \tgrpc_sockaddr_in6* addr6_out =\n> \t\treinterpret_cast<grpc_sockaddr_in6*>(resolved_addr6_out->addr);\n> \tif (addr->sa_family == GRPC_AF_INET) {\n> \t\tconst grpc_sockaddr_in* addr4 =\n> \t\t\treinterpret_cast<const grpc_sockaddr_in*>(addr);\n> \t\tmemset(resolved_addr6_out, 0, sizeof(*resolved_addr6_out));\n> \t\taddr6_out->sin6_family = GRPC_AF_INET6;\n> \t\tmemcpy(&addr6_out->sin6_addr.s6_addr[0], kV4MappedPrefix, 12);\n> \t\tmemcpy(&addr6_out->sin6_addr.s6_addr[12], &addr4->sin_addr, 4);\n> \t\taddr6_out->sin6_port = addr4->sin_port;\n> \t\tresolved_addr6_out->len = static_cast<socklen_t>(sizeof(grpc_sockaddr_in6));\n> \t\treturn 1;\n> \t}\n> \treturn 0;\n> }\n> uint16_t grpc_htons(uint16_t hostshort) { return htons(hostshort); }\n> int grpc_inet_pton(int af, const char* src, void* dst) {\n> \treturn inet_pton(af, src, dst);\n> }\n> void fill_host(grpc_resolved_address* addr)\n> {\n> \tmemset(addr, 0, sizeof(*addr));\n> \taddr->len = static_cast<socklen_t>(sizeof(grpc_sockaddr_in));\n>\n> \tgrpc_sockaddr_in* in = reinterpret_cast<grpc_sockaddr_in*>(addr->addr);\n> \tin->sin_family = GRPC_AF_INET;\n> \tconst char* host = \"10.*.*.*\";\n> \tif (grpc_inet_pton(GRPC_AF_INET, host, &in->sin_addr) == 0) {\n> \t\tauto k = -1;\n> \t}\n> \tint port_num = 7779;\n> \tin->sin_port = grpc_htons(static_cast<uint16_t>(port_num));\n> }\n>\n> void grpc_sockaddr_make_wildcard6(int port,\n> \tgrpc_resolved_address* resolved_wild_out) {\n> \tgrpc_sockaddr_in6* wild_out =\n> \t\treinterpret_cast<grpc_sockaddr_in6*>(resolved_wild_out->addr);\n> \tif (!(port >= 0 && port < 65536))\n> \t{\n> \t\tauto str = std::to_string(__LINE__);\n> \t\tthrow std::exception(str.c_str());\n> \t}\n> \tmemset(resolved_wild_out, 0, sizeof(*resolved_wild_out));\n> \twild_out->sin6_family = GRPC_AF_INET6;\n> \twild_out->sin6_port = grpc_htons(static_cast<uint16_t>(port));\n> \tresolved_wild_out->len = static_cast<socklen_t>(sizeof(grpc_sockaddr_in6));\n> }\n>\n> #define GRPC_FIONBIO FIONBIO\n> static int set_non_block(SOCKET sock) {\n> \tint status;\n> \tuint32_t param = 1;\n> \tDWORD ret;\n> \tstatus = WSAIoctl(sock, GRPC_FIONBIO, &param, sizeof(param), NULL, 0, &ret,\n> \t\tNULL, NULL);\n> \treturn status;\n> }\n> static int set_dualstack(SOCKET sock) {\n> \tint status;\n> \tunsigned long param = 0;\n> \tstatus = setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&param,\n> \t\tsizeof(param));\n> \treturn status;\n> }\n> static int enable_loopback_fast_path(SOCKET sock) {\n> \tint status;\n> \tuint32_t param = 1;\n> \tDWORD ret;\n> \tstatus = WSAIoctl(sock, /*SIO_LOOPBACK_FAST_PATH==*/_WSAIOW(IOC_VENDOR, 16),\n> \t\t&param, sizeof(param), NULL, 0, &ret, 0, 0);\n> \tif (status == SOCKET_ERROR) {\n> \t\tstatus = WSAGetLastError();\n> \t}\n> \treturn status;\n> }\n>\n> #define GRPC_ERROR_NONE 0\n> int grpc_tcp_prepare_socket(SOCKET sock) {\n> \tint err;\n> \terr = set_non_block(sock);\n> \tif (err != GRPC_ERROR_NONE) return err;\n> \terr = set_dualstack(sock);\n> \tif (err != GRPC_ERROR_NONE) return err;\n> \terr = enable_loopback_fast_path(sock);\n> \tif (err != GRPC_ERROR_NONE) return err;\n> \treturn 0;\n> }\n>\n>\n>\n> void test()\n> {\n>\n> \tSOCKET sock = INVALID_SOCKET;\n> \tBOOL success;\n> \tint status;\n> \tgrpc_resolved_address addr6_v4mapped;\n> \tgrpc_resolved_address local_address;\n> \tLPFN_CONNECTEX ConnectEx;\n> \tGUID guid = WSAID_CONNECTEX;\n> \tDWORD ioctl_num_bytes;\n>\n> \tint error = 0;\n>\n> \tgrpc_resolved_address a;\n>\n> \tgrpc_resolved_address* addr = &a;\n> \tfill_host(addr);\n>\n> \t/* Use dualstack sockets where available. */\n> \tif (grpc_sockaddr_to_v4mapped(addr, &addr6_v4mapped)) {\n> \t\taddr = &addr6_v4mapped;\n> \t}\n>\n> \tsock = WSASocket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, NULL, 0,\n> \t\tWSA_FLAG_OVERLAPPED);\n> \tif (sock == INVALID_SOCKET) {\n> \t\terror = WSAGetLastError();\n> \t\tauto str = std::to_string(__LINE__);\n> \t\tthrow std::exception(str.c_str());\n> \t}\n>\n> \terror = grpc_tcp_prepare_socket(sock);\n> \t//if (error != GRPC_ERROR_NONE) {\n>\n> \t//}\n>\n> \t/* Grab the function pointer for ConnectEx for that specific socket.\tIt may change depending on the interface. */\n> \tstatus =\n> \tWSAIoctl(sock, SIO_GET_EXTENSION_FUNCTION_POINTER, &guid, sizeof(guid),\n> \t\t&ConnectEx, sizeof(ConnectEx), &ioctl_num_bytes, NULL, NULL);\n>\n> \tif (status != 0) {\n> \t\terror = WSAGetLastError();\n> \t}\n>\n> \tgrpc_sockaddr_make_wildcard6(0, &local_address);\n>\n> \tstatus =\n> \tbind(sock, (grpc_sockaddr*)&local_address.addr, (int)local_address.len);\n> \tif (status != 0) {\n> \t\terror = WSAGetLastError();\n> \t\tauto str = std::to_string(__LINE__);\n> \t\tthrow std::exception(str.c_str());\n> \t}\n>\n> }\n> static void winsock_init(void) {\n> \tWSADATA wsaData;\n> \tint status = WSAStartup(MAKEWORD(2, 0), &wsaData);\n> \t//\n> }\n> static void winsock_shutdown(void) {\n> \tint status = WSACleanup();\n> \t//GPR_ASSERT(status == 0);\n> }\n> int main()\n> {\n> \twinsock_init();\n> \ttry {\n> \t\ttest();\n> \t}\n> \tcatch (std::exception const & ex)\n> \t{\n> \t\tauto s = ex.what();\n> \t}\n> \twinsock_shutdown();\n>     return 0;\n> }\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/grpc/grpc/issues/16309#issuecomment-412074170>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AG8bpt4vwvY74yWCZF0f8QgN04opNPbeks5uPYNOgaJpZM4V4DZx>\n> .\n>\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/412464860",
    "html_url": "https://github.com/grpc/grpc/issues/16309#issuecomment-412464860",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/16309",
    "id": 412464860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjQ2NDg2MA==",
    "user": {
      "login": "Iliych",
      "id": 42270809,
      "node_id": "MDQ6VXNlcjQyMjcwODA5",
      "avatar_url": "https://avatars0.githubusercontent.com/u/42270809?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Iliych",
      "html_url": "https://github.com/Iliych",
      "followers_url": "https://api.github.com/users/Iliych/followers",
      "following_url": "https://api.github.com/users/Iliych/following{/other_user}",
      "gists_url": "https://api.github.com/users/Iliych/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Iliych/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Iliych/subscriptions",
      "organizations_url": "https://api.github.com/users/Iliych/orgs",
      "repos_url": "https://api.github.com/users/Iliych/repos",
      "events_url": "https://api.github.com/users/Iliych/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Iliych/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-13T09:46:39Z",
    "updated_at": "2018-08-13T09:46:39Z",
    "author_association": "NONE",
    "body": "In case of port exhaustion Windows returns another error - 10055 (\"10055 | No buffer space available.\")\r\nOn my system I can create approx 16.300 sockets.\r\n\r\n\r\n"
  }
]
