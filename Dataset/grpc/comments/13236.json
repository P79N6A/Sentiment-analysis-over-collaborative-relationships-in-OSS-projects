[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/341352163",
    "html_url": "https://github.com/grpc/grpc/issues/13236#issuecomment-341352163",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13236",
    "id": 341352163,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTM1MjE2Mw==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-02T08:37:58Z",
    "updated_at": "2017-11-02T08:38:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "You're right, this is happening because for each message sent, we serialize in a byte[] and then let the buffer to be garbage collected (for large objects, they are always taken from the large object generation which requires FullGC to garbage collect). Same thing happens for deserialization. \r\nThere's definitely room for improvement here. Using ArrayPool is one of the options, but at the same time, we'd like to avoid copying data between the managed and native layer (likely using pinning), so the whole situation is a bit more complicated. Also, we already have an API defined for marshaller and unmarshaller, and we don't want to break the public API so the change needs to be done carefully.\r\n\r\nDo you have any specific suggestions how the change should be made?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/341392551",
    "html_url": "https://github.com/grpc/grpc/issues/13236#issuecomment-341392551",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13236",
    "id": 341392551,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTM5MjU1MQ==",
    "user": {
      "login": "azyobuzin",
      "id": 1000655,
      "node_id": "MDQ6VXNlcjEwMDA2NTU=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1000655?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/azyobuzin",
      "html_url": "https://github.com/azyobuzin",
      "followers_url": "https://api.github.com/users/azyobuzin/followers",
      "following_url": "https://api.github.com/users/azyobuzin/following{/other_user}",
      "gists_url": "https://api.github.com/users/azyobuzin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/azyobuzin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/azyobuzin/subscriptions",
      "organizations_url": "https://api.github.com/users/azyobuzin/orgs",
      "repos_url": "https://api.github.com/users/azyobuzin/repos",
      "events_url": "https://api.github.com/users/azyobuzin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/azyobuzin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-02T11:24:44Z",
    "updated_at": "2017-11-02T17:25:46Z",
    "author_association": "NONE",
    "body": "I first thought that it would work if I replace `byte[]` with `ArraySegment` or something `IDisposable` which returns the buffer when `Dispose`.\r\n\r\nAs to the native layer, I think it is OK if we pass a larger array than required in the native layer, and ArrayPool will return a larger array than we specify.\r\n\r\nAs to marshallers, I thought of the below code, but **existing deserializers will slow down**. So I couldn't have a good idea.\r\n\r\n```csharp\r\npublic class RentedBuffer : IDisposable\r\n{\r\n    public ArraySegment<byte> Buffer { get; }\r\n    public void Dispose();\r\n}\r\n\r\npublic class Marshaller<T>\r\n{\r\n    Func<T, byte[]> bytesSerializer;\r\n    Func<byte[], T> bytesDeserializer;\r\n    Func<T, RentedBuffer> segmentSerializer;\r\n    Func<ArraySegment<byte>, T> segmentDeserializer;\r\n\r\n    public Marshaller(Func<T, byte[]> serializer, Func<byte[], T> deserializer)\r\n    {\r\n        this.bytesSerializer = GrpcPreconditions.CheckNotNull(serializer, nameof(serializer));\r\n        this.bytesDeserializer = GrpcPreconditions.CheckNotNull(deserializer, nameof(deserializer));\r\n    }\r\n\r\n    public Marshaller(Func<T, RentedBuffer> serializer, Func<ArraySegment<byte>, T> deserializer)\r\n    {\r\n        this.segmentSerializer = GrpcPreconditions.CheckNotNull(serializer, nameof(serializer));\r\n        this.segmentDeserializer = GrpcPreconditions.CheckNotNull(deserializer, nameof(deserializer));\r\n    }\r\n\r\n    public Func<T, byte[]> Serializer\r\n    {\r\n        get\r\n        {\r\n            if (this.bytesSerializer == null)\r\n            {\r\n                this.bytesSerializer = x =>\r\n                {\r\n                    using (var serializationResult = this.segmentSerializer(x))\r\n                    {\r\n                        var seg = serializationResult.Buffer;\r\n                        // slow, but not used in Grpc.Core\r\n                        var bs = new byte[seg.Count];\r\n                        Buffer.BlockCopy(seg.Array, seg.Offset, bs, 0, seg.Count);\r\n                        return seg;\r\n                    }\r\n                };\r\n            }\r\n\r\n            return this.bytesSerializer;\r\n        }\r\n    }\r\n\r\n    public Func<byte[], T> Deserializer\r\n    {\r\n        get\r\n        {\r\n            if (this.bytesDeserializer == null)\r\n            {\r\n                this.bytesDeserializer = bs => this.segmentDeserializer(new ArraySegment<byte>(bs));\r\n            }\r\n\r\n            return this.bytesDeserializer;\r\n        }\r\n    }\r\n\r\n    public Func<T, RentedBuffer> SegmentSerializer\r\n    {\r\n        get\r\n        {\r\n            if (this.segmentSerializer == null)\r\n            {\r\n                this.segmentSerializer = x => new RentedBuffer(this.bytesSerializer(x));\r\n            }\r\n\r\n            return this.segmentSerializer;\r\n        }\r\n    }\r\n\r\n    public Func<ArraySegment<byte>, T> segmentDeserializer\r\n    {\r\n        get\r\n        {\r\n            if (this.segmentDeserializer == null)\r\n            {\r\n                this.segmentDeserializer = seg =>\r\n                {\r\n                    if (seg.Count == seg.Array.Length)\r\n                    {\r\n                        return this.bytesDeserializer(seg.Array);\r\n                    }\r\n\r\n                    // slow\r\n                    var bs = new byte[seg.Count];\r\n                    Buffer.BlockCopy(seg.Array, seg.Offset, bs, 0, seg.Count);\r\n                    return this.bytesDeserializer(bs);\r\n                }\r\n            }\r\n\r\n            return this.segmentDeserializer;\r\n        }\r\n    }\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/341606077",
    "html_url": "https://github.com/grpc/grpc/issues/13236#issuecomment-341606077",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13236",
    "id": 341606077,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0MTYwNjA3Nw==",
    "user": {
      "login": "kkm000",
      "id": 8228229,
      "node_id": "MDQ6VXNlcjgyMjgyMjk=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8228229?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kkm000",
      "html_url": "https://github.com/kkm000",
      "followers_url": "https://api.github.com/users/kkm000/followers",
      "following_url": "https://api.github.com/users/kkm000/following{/other_user}",
      "gists_url": "https://api.github.com/users/kkm000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kkm000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kkm000/subscriptions",
      "organizations_url": "https://api.github.com/users/kkm000/orgs",
      "repos_url": "https://api.github.com/users/kkm000/repos",
      "events_url": "https://api.github.com/users/kkm000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kkm000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-03T01:50:02Z",
    "updated_at": "2017-11-03T01:50:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "Just to think of, I am using this baby when processing realtime audio, where had the same problem (not with gRPC): https://github.com/Microsoft/Microsoft.IO.RecyclableMemoryStream. It seems very efficient in avoiding the large GCs. But it has a stream interface, not an array. "
  }
]
