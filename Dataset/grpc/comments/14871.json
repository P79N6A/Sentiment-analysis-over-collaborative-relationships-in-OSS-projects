[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/378706725",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-378706725",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 378706725,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3ODcwNjcyNQ==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-04T18:52:08Z",
    "updated_at": "2018-04-04T18:52:08Z",
    "author_association": "MEMBER",
    "body": "I feel that this is a bit overkill. How about some thing like:\r\n```\r\nfunc grpcServiceFactory(address: String, type: some_enum) -> GRPCProtoCall\r\n{\r\n  var service : GRPCProtoCall\r\n  switch type {\r\n    ...\r\n  }\r\n  service.setTlsParameters(...)\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/378800169",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-378800169",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 378800169,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3ODgwMDE2OQ==",
    "user": {
      "login": "dcow",
      "id": 547926,
      "node_id": "MDQ6VXNlcjU0NzkyNg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/547926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dcow",
      "html_url": "https://github.com/dcow",
      "followers_url": "https://api.github.com/users/dcow/followers",
      "following_url": "https://api.github.com/users/dcow/following{/other_user}",
      "gists_url": "https://api.github.com/users/dcow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dcow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dcow/subscriptions",
      "organizations_url": "https://api.github.com/users/dcow/orgs",
      "repos_url": "https://api.github.com/users/dcow/repos",
      "events_url": "https://api.github.com/users/dcow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dcow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-05T02:10:47Z",
    "updated_at": "2018-04-05T02:10:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "Why replicate the job of the type system?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/378832008",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-378832008",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 378832008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3ODgzMjAwOA==",
    "user": {
      "login": "dcow",
      "id": 547926,
      "node_id": "MDQ6VXNlcjU0NzkyNg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/547926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dcow",
      "html_url": "https://github.com/dcow",
      "followers_url": "https://api.github.com/users/dcow/followers",
      "following_url": "https://api.github.com/users/dcow/following{/other_user}",
      "gists_url": "https://api.github.com/users/dcow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dcow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dcow/subscriptions",
      "organizations_url": "https://api.github.com/users/dcow/orgs",
      "repos_url": "https://api.github.com/users/dcow/repos",
      "events_url": "https://api.github.com/users/dcow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dcow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-05T06:21:17Z",
    "updated_at": "2018-04-05T22:58:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "To elaborate a little...\r\n\r\nGenerally things like `switch type ...` are not great because your code has to know about all possible types. It is error prone because the compiler can't verify you've exhausted all types unless those types are associated via some enumerable relationship which is where sealed/case classes in scala/kotlin, associated types/enums in swift, etc. come in. To enable something like that you'd need to give the consumer the ability to know all the possible services/calls at compile time--which _is_ possible because consumers don't add types.\r\n\r\nBut in this case, I'm not sure your suggestion solves the issue. The goal is for a factory function to be able to instantiate a grpc service, do something generic to it that the caller should not need to be responsible for, and then return the service so that the consumer can make call instances as needed, all in a typesafe manner. A call factory does not do any good because then one would need a gigantic surface describing all the calls, and that already exists as methods of the services themselves, so it's really just boilerplate. Traditionally factories are not type safe. \r\n\r\nConsider how a general example of this would look in java (using java because it doesn't have any of the required features):\r\n\r\n```\r\ninterface GRPCProtoService {\r\n    void configureService();\r\n}\r\n\r\nclass A implements GRPCProtoService {\r\n    GRPCCall rpcToDoA() { ... }\r\n}\r\n\r\nclass B implements GRPCProtoService {\r\n    GRPCCall rpcToDoB() { ... }\r\n}\r\n\r\nenum Services { A, B }\r\n\r\nstatic GrpcProtoService serviceFactory(Services type, String host) throws Exception\r\n{\r\n    GrpcProtoService it = null;\r\n    switch type {\r\n    case a: \r\n        A a = new A(host);\r\n        it = a;\r\n        break;\r\n    case b: \r\n        B b = new B(host);\r\n        b.importantThing = sBarThing;\r\n        it = b;\r\n        break;\r\n    default:\r\n        throw new Exception(\"unknown type\");\r\n    }\r\n    it.configureService(stuff)\r\n    return it;\r\n}\r\n\r\n// caller\r\nB b = null;\r\ntry {\r\n    b = (B) serviceFactory(Services.B);\r\n} catch (Exception e) {\r\n    // unknown type\r\n}\r\nCall c = b.rpcToDoBThings(...) // needs to be cast as B so we can make b-related rpcs\r\n```\r\n\r\nA few things are going on here that can be done at compile time instead of runtime:\r\n\r\n1. runtime exception in the factory function. This is what I was talking about initially, we can avoid this, and even leverage it to invoke type-specific constructors, with a stronger language (swift/scala etc)\r\n2. runtime downcast from the interface to the concrete type (see below)\r\n3. parallel type enumeration in the type enum. (Key here is that all the types implementing an interface/protocol _are_ implicitly the enumeration. You already enumerate types in code when you declare them. You don't need a separate type list tracking all the types you have declared, it's a bit silly)\r\n\r\nWith \"reified\" generic types like kotlin, scala, swift family languages have, you don't have to do any of this because you can instantiate generic types if they conform to a protocol describing their constructor. \r\n\r\nYou can turn all of that into:\r\n\r\n```\r\nprotocol GRPCProtobufService {\r\n    func init(host: String)\r\n    // ...\r\n}\r\n\r\nclass A : GRPCProtobufService {\r\n    // ...\r\n}\r\nclass B : GRPCProtobufService {\r\n    func rpcToDoB() -> GRPCCall {}\r\n}\r\n\r\nfunc grpcServiceFactory<S: GRPCProtobufService>(address: String) -> S\r\n{\r\n    let service = S(host: address)\r\n    GRPCCall.setTlsParameters(..., ..., ..., address) // this could be an api on service\r\n    return service\r\n}\r\n\r\n// caller\r\n\r\nlet b: B = grpcServiceFactory(\"addr\")\r\nlet call = b.rpcToDoB()\r\n// ...\r\n```\r\n\r\nall with the advantage of being compile-time typesafe. Am I making sense?\r\n\r\nMaybe I'll take a stab at this if I have any free time.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379066975",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379066975",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379066975,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTA2Njk3NQ==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-05T20:31:06Z",
    "updated_at": "2018-04-05T20:31:06Z",
    "author_association": "MEMBER",
    "body": "I see. Thanks for explaining. I totally agree that doing switch in a factory is bad; was just meant to illustrate that returning `GRPCProtoService` might also be an option. But you are right that it needs a downcast which is not good. So that's right we can put generics here and use it in this way and thanks for stabbing into this.\r\n\r\nI have not used generics in Swift before, but since every generated service class have a `initWithHost` initializer, can you just get rid of `: GRPCProtobufService` in `<...>` (i.e. just use `<S>`) and let compiler match the initializer? Or in other words, if `S` is a generated service class, it is guaranteed to have an `initWithHost` parameter. Then why does this code not work right now?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379102564",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379102564",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379102564,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTEwMjU2NA==",
    "user": {
      "login": "dcow",
      "id": 547926,
      "node_id": "MDQ6VXNlcjU0NzkyNg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/547926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dcow",
      "html_url": "https://github.com/dcow",
      "followers_url": "https://api.github.com/users/dcow/followers",
      "following_url": "https://api.github.com/users/dcow/following{/other_user}",
      "gists_url": "https://api.github.com/users/dcow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dcow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dcow/subscriptions",
      "organizations_url": "https://api.github.com/users/dcow/orgs",
      "repos_url": "https://api.github.com/users/dcow/repos",
      "events_url": "https://api.github.com/users/dcow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dcow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-05T23:06:13Z",
    "updated_at": "2018-04-05T23:09:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "I got your point about how returning calls instead of services could be an option, but for my case I need something to manage the service (like a view controller) and like I said a call factory would just end up being a bunch of boilerplate with not much benefit. But it wasn't a bad idea.\r\n\r\n> I have not used generics in Swift before, but since every generated service class have a `initWithHost` initializer, can you just get rid of `: GRPCProtobufService `in `<...>` (i.e. just use `<S>`) and let compiler match the initializer? Or in other words, if `S` is a generated service class, it is guaranteed to have an `initWithHost` parameter. Then why does this code not work right now?\r\n\r\nBecause `S` could be anything since it's generic. For the compiler to know it can use the `initWithHost` initializer you have to restrict `S` to conform to some protocol that requires an `initWithHost`.  So if you did `let foo: NotAService = grpcServiceFactory(\"addr\")` the compiler wouldn't be able to guarantee it can initialize NotAService like `NotAService(host: \"addr\")`. And so it has to fail to compile unless it allowed a runtime exception to occur when someone calls the serviceFactory with the wrong type. And if it did that it's pretty much back at square 1 (and it wouldn't be doing its job as a compiler). \r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379110583",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379110583",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379110583,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTExMDU4Mw==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-05T23:57:15Z",
    "updated_at": "2018-04-05T23:57:15Z",
    "author_association": "MEMBER",
    "body": "Huh I would say that sounds lame of Swift to me... C++ checks whether a method exists after the type-specific function is instantiated; no need to explicitly specify it. But anyway, the work looks like just adding a protocol in `GRPCProtoService.h` having method `- (void)initWithHost` and have all generated service stubs conform to that protocol?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379112927",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379112927",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379112927,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTExMjkyNw==",
    "user": {
      "login": "dcow",
      "id": 547926,
      "node_id": "MDQ6VXNlcjU0NzkyNg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/547926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dcow",
      "html_url": "https://github.com/dcow",
      "followers_url": "https://api.github.com/users/dcow/followers",
      "following_url": "https://api.github.com/users/dcow/following{/other_user}",
      "gists_url": "https://api.github.com/users/dcow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dcow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dcow/subscriptions",
      "organizations_url": "https://api.github.com/users/dcow/orgs",
      "repos_url": "https://api.github.com/users/dcow/repos",
      "events_url": "https://api.github.com/users/dcow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dcow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-06T00:12:27Z",
    "updated_at": "2018-04-06T00:12:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Huh I would say that sounds lame of Swift to me... C++ checks whether a method exists after the type-specific function is instantiated; no need to explicitly specify it.\r\n\r\nC++ does this at runtime? What happens if you try to call a method that's not available on the type that the function is called under? Runtime exception? Or does the compiler check all usages of a generic function at compile time and infers any type bounds there? If so, this must only work for non-virtual methods?\r\n\r\n> But anyway, the work looks like just adding a protocol in GRPCProtoService.h having method - (void)initWithHost and have all generated service stubs conform to that protocol?\r\n\r\nYep!\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379116498",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379116498",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379116498,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTExNjQ5OA==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-06T00:38:51Z",
    "updated_at": "2018-04-06T00:38:51Z",
    "author_association": "MEMBER",
    "body": "Not runtime; it is build time instantiation (by preprocessor I guess) of the function. If Swift behaves the same as C++, when you use `grpcServiceFactory<HelloWorld>` somewhere, `func grpcServiceFactory<S: GRPCProtobufService>(address: String) -> S` is instantiated to `grpcServiceFactory(address: String) -> HelloWorld` and the compiler can compile this instance successfully. If you instantiate with some class that does not have `init(host:)`, the compiler fails."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379117547",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379117547",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379117547,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTExNzU0Nw==",
    "user": {
      "login": "dcow",
      "id": 547926,
      "node_id": "MDQ6VXNlcjU0NzkyNg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/547926?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dcow",
      "html_url": "https://github.com/dcow",
      "followers_url": "https://api.github.com/users/dcow/followers",
      "following_url": "https://api.github.com/users/dcow/following{/other_user}",
      "gists_url": "https://api.github.com/users/dcow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dcow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dcow/subscriptions",
      "organizations_url": "https://api.github.com/users/dcow/orgs",
      "repos_url": "https://api.github.com/users/dcow/repos",
      "events_url": "https://api.github.com/users/dcow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dcow/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-06T00:46:44Z",
    "updated_at": "2018-04-06T00:46:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "I see. Interesting. Yeah I've been reading more about function templates but it's a big topic. I forgot Templates were entirely compile time (and I've even used them before). Since c++ doesn't have a runtime, this is possible (and necessary). The difference is interesting. Swift _is_ a pretty young language (certainly lame at times), and it has to interoperate with obj-c, and it has a reflection runtime. So that would explain why the difference is necessary."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/379118755",
    "html_url": "https://github.com/grpc/grpc/issues/14871#issuecomment-379118755",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14871",
    "id": 379118755,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3OTExODc1NQ==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-06T00:55:49Z",
    "updated_at": "2018-04-06T00:55:49Z",
    "author_association": "MEMBER",
    "body": "OK anyway. Feel free to make a PR any time (@ me if you do). Otherwise I'll find some time for this, likely some day next week."
  }
]
