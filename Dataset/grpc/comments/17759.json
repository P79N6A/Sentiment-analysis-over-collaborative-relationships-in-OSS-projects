[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/455471813",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-455471813",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 455471813,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NTQ3MTgxMw==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-18T08:53:13Z",
    "updated_at": "2019-01-18T08:53:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "Would it make sense to provide something more type-safe? I'm thinking a bag of values accessed by their type, something like this:\r\n```\r\nvar myData = context.UserData.Get<MyTypedUserDataStorage>();\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/455666524",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-455666524",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 455666524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NTY2NjUyNA==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-18T19:48:39Z",
    "updated_at": "2019-01-18T19:48:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "I like the `.Get<MyTypedUserDataStorage>()` proposal. This also solves the problem of how to avoid stepping on another interceptor stack's toes: they need to use different types. This may end up with some wrapper types just for distinguishing purposes, but that seems like an OK compromise to avoid implementing `UserData.Get<MyType>(\"my name\")`"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/455906064",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-455906064",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 455906064,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NTkwNjA2NA==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-20T21:54:29Z",
    "updated_at": "2019-01-21T22:39:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "If we can settle on a design, it looks like I'll have time to contribute the implementation.\r\n\r\nI think the public interface is just:\r\n\r\n```cs\r\npublic interface IUserData {\r\n    T Get<T>();\r\n    void Set<T>(T instance);\r\n}\r\n```\r\n\r\nThe setter allows resetting the instance if there's a type that someone wants to use the doesn't have a `Reset()` member (e.g., immutable types).\r\n\r\nNot sure if `T` needs a `class` constraint. I'm thinking no, so you can put a `Guid` or similar in the user data without explicitly wrapping in a box."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456039414",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456039414",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456039414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjAzOTQxNA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-21T11:19:16Z",
    "updated_at": "2019-01-21T11:19:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jskeet  @apolcyn  do you have opinions on the proposed API design?\r\n\r\n@JamesNK @JunTaoLuo would this new API be useful for Grpc.AspNetCore.Server?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456119452",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456119452",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456119452,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjExOTQ1Mg==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-21T15:52:43Z",
    "updated_at": "2019-01-21T15:53:37Z",
    "author_association": "NONE",
    "body": "@chwarr if the public interface is the one mentioned in your comment, does it make sense to let it be a getter and a setter of the type `IServiceProvider` instead? I.e. something along the lines of:\r\n\r\n```csharp\r\npublic class ServerCallContext\r\n{\r\n    IServiceProvider ServiceProvider { get; set; }\r\n}\r\n```\r\n\r\nThere already exists a good implementation for `IServiceProvider` and I do not see a reason that justifies reinventing that wheel."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456121301",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456121301",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456121301,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjEyMTMwMQ==",
    "user": {
      "login": "jskeet",
      "id": 17011,
      "node_id": "MDQ6VXNlcjE3MDEx",
      "avatar_url": "https://avatars1.githubusercontent.com/u/17011?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jskeet",
      "html_url": "https://github.com/jskeet",
      "followers_url": "https://api.github.com/users/jskeet/followers",
      "following_url": "https://api.github.com/users/jskeet/following{/other_user}",
      "gists_url": "https://api.github.com/users/jskeet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jskeet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jskeet/subscriptions",
      "organizations_url": "https://api.github.com/users/jskeet/orgs",
      "repos_url": "https://api.github.com/users/jskeet/repos",
      "events_url": "https://api.github.com/users/jskeet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jskeet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-21T15:58:21Z",
    "updated_at": "2019-01-21T15:58:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "I don't know enough about the use case to be of much help, but if this is meant to provide arbitrary context information, the `Get<>` approach works for me."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456216581",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456216581",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456216581,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjIxNjU4MQ==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-21T22:39:18Z",
    "updated_at": "2019-01-21T22:39:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "> does it make sense to let it be a getter and a setter of the type `IServiceProvider` instead? I.e. something along the lines of:\r\n> \r\n> ```cs\r\n> public class ServerCallContext\r\n> {\r\n>     IServiceProvider ServiceProvider { get; set; }\r\n> }\r\n> ```\r\n\r\n@dpsenner, I tried to come up with a way to make just a mutable `IServiceProvider` work, but I can't. The fundamental problem is that `IServiceProvider` doesn't provide any way to add new types to the UserData.\r\n\r\nI see the need to be able to compose multiple sets of collaborating interceptors. For example, a service consumes an authN + authZ set developed by team A, an instrumentation set developed by team B, and a cross-cutting business logic set developed by team C. Each of these sets consists of multiple interceptors, depending on which functionality the service wants to opt-in to.\r\n\r\nThese sets of interceptors don't collaborate with each other to store their per-call data in the same type, but they also don't conflict with each other. (The interceptors within a set do collaborate with each other.)\r\n\r\nA single, settable `IServiceProvider` doesn't work in this case. It either forces them to conflict with each other or it forces them to collaborate with each other.\r\n\r\nThe forced conflict arises when the independent sets perform their per-call initialization. Since each set needs some type to store its per-call data, the first interceptors in each set does something like this:\r\n\r\n```cs\r\nvar sp = new ConcreateServiceProvider.Add<SomeType>().Build();\r\nserverCallContext.ServiceProvider = sp;\r\n```\r\n\r\nNow, whichever initialization interceptor runs last wins, destroying the work the others have done.\r\n\r\nThe forced collaboration arises when trying to solve this. Some sort of initialization interceptor gets added that now knows about all the types across all the sets. ASP.NET Core takes this approach by fully embracing `Microsoft.Extensions.DependencyInjection`. I assume that gRPC C# doesn't want to have an opinion about whether or how to use that library.\r\n\r\nThese problems can be addressed with some changes to the interface, but not without trade-offs.\r\n\r\n```cs\r\ninterface IUserData // attempt 1\r\n{\r\n    IServiceProvider ServiceProvider { get; }\r\n    void AddService<T>(T instance);\r\n}\r\n```\r\n\r\nIn attempt 1, the members exposed are mismatched: there's one to retrieve the collection and one to add an item to it. However, to get an item, a chain of calls is needed: `ServiceProvider.GetService<T>()`.\r\n\r\n```cs\r\ninterface IUserData : IServiceProvider // attempt 2\r\n{\r\n    void AddService(Type forType, object instance);\r\n}\r\n```\r\n\r\nAttempt 2 is better. The members are now `GetService(...)` and `AddService(...)`. This does allows use of *some* `IServiceProvider` extension methods, like `GetRequiredService()`, but not ones like `CreateScope()`.\r\n\r\nHowever, this approach doesn't provide anything from `Microsoft.Extensions.DependencyInjection`, like lifetimes or scopes; I suspect it would confound expectations.\r\n\r\n```cs\r\npublic interface IUserData // original proposal, slightly amended\r\n{\r\n    T Get<T>();\r\n    void Set<T>(T instance);\r\n    // perhaps also\r\n    void Set<TType, TImplementation>(TImplementation instance);\r\n}\r\n```\r\n\r\nThis interface is just paired getter(s) and setters. It's job is to be a per-call state bag. It doesn't depend on the package or the ideas from `Microsoft.Extensions.DependencyInjection`, but it doesn't get in their way. It can be composed with an existing implementation of `IServiceProvider` with some ceremony, but not too much:\r\n\r\n```cs\r\npublic StartScopeInterceptor\r\n{\r\n    private readonly IServiceProvider sp;\r\n\r\n    public override Task<TResponse> UnaryServerHandler<TRequest, TResponse>(TRequest request, ServerCallContext context, UnaryServerMethod<TRequest, TResponse> continuation)\r\n    {\r\n        context.UserData.Set(sp);\r\n        // or, perhaps, if the ServiceProvider is known to support scopes\r\n        context.UserData.Set(sp.CreateScope().ServiceProvider);\r\n        return continuation(request, context);\r\n    }\r\n}\r\n```\r\n\r\nIf anyone is aware of an existing interface with similar semantics elsewhere, let me know. Bonus points for an implementation."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456219619",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456219619",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456219619,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjIxOTYxOQ==",
    "user": {
      "login": "JamesNK",
      "id": 303201,
      "node_id": "MDQ6VXNlcjMwMzIwMQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/303201?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JamesNK",
      "html_url": "https://github.com/JamesNK",
      "followers_url": "https://api.github.com/users/JamesNK/followers",
      "following_url": "https://api.github.com/users/JamesNK/following{/other_user}",
      "gists_url": "https://api.github.com/users/JamesNK/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JamesNK/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JamesNK/subscriptions",
      "organizations_url": "https://api.github.com/users/JamesNK/orgs",
      "repos_url": "https://api.github.com/users/JamesNK/repos",
      "events_url": "https://api.github.com/users/JamesNK/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JamesNK/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-21T22:57:40Z",
    "updated_at": "2019-01-21T22:57:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "> @JamesNK @JunTaoLuo would this new API be useful for Grpc.AspNetCore.Server?\r\n\r\nTo be honest I'm still learning gRPC's capabilities and uses of your API. I'm not sure. Ask me in a couple of weeks 😄 "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456221305",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456221305",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456221305,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjIyMTMwNQ==",
    "user": {
      "login": "JamesNK",
      "id": 303201,
      "node_id": "MDQ6VXNlcjMwMzIwMQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/303201?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JamesNK",
      "html_url": "https://github.com/JamesNK",
      "followers_url": "https://api.github.com/users/JamesNK/followers",
      "following_url": "https://api.github.com/users/JamesNK/following{/other_user}",
      "gists_url": "https://api.github.com/users/JamesNK/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JamesNK/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JamesNK/subscriptions",
      "organizations_url": "https://api.github.com/users/JamesNK/orgs",
      "repos_url": "https://api.github.com/users/JamesNK/repos",
      "events_url": "https://api.github.com/users/JamesNK/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JamesNK/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-21T23:08:42Z",
    "updated_at": "2019-01-21T23:13:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "From https://github.com/grpc/grpc/issues/15757#issuecomment-445053226\r\n\r\n> I've run into the need to pass state between interceptors and call handlers myself.\r\n\r\nI don't think @chwarr's needs will be important for AspNetCore.Server. If I understand interceptors correctly from [here](https://github.com/grpc/proposal/blob/master/L12-csharp-interceptors.md) then they sound similar to ASP.NET Core middleware.\r\n\r\nIn AspNetCore.Server it should be simple enough to have middleware that puts state in the HttpContext and then for you to [get it from the HttpContext in the gRPC method](https://github.com/grpc/grpc-dotnet/issues/36).\r\n\r\nEdit:\r\nAlthough interceptors give you access to the deserialized request and response, which middleware wouldn't let you do. Is the idea of user data similar to [HttpContext.Items](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.items)?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456261624",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456261624",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456261624,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjI2MTYyNA==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-22T03:44:08Z",
    "updated_at": "2019-01-22T03:45:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "> If I understand interceptors correctly from here then they sound similar to ASP.NET Core middleware.\r\n\r\n@JamesNK, they're quite similar.\r\n\r\n> Is the idea of user data similar to HttpContext.Items?\r\n\r\nYes."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456265302",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456265302",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456265302,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjI2NTMwMg==",
    "user": {
      "login": "JamesNK",
      "id": 303201,
      "node_id": "MDQ6VXNlcjMwMzIwMQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/303201?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JamesNK",
      "html_url": "https://github.com/JamesNK",
      "followers_url": "https://api.github.com/users/JamesNK/followers",
      "following_url": "https://api.github.com/users/JamesNK/following{/other_user}",
      "gists_url": "https://api.github.com/users/JamesNK/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JamesNK/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JamesNK/subscriptions",
      "organizations_url": "https://api.github.com/users/JamesNK/orgs",
      "repos_url": "https://api.github.com/users/JamesNK/repos",
      "events_url": "https://api.github.com/users/JamesNK/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JamesNK/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-22T04:11:46Z",
    "updated_at": "2019-01-22T04:26:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "In that case I'd just go with `IDictionary<object, object> UserData { get; set; }`, with the getter lazily allocating the dictionary the first time `UserData` is accessed if it is null. That keeps the feature pay-for-play. If no one ever uses UserData then nothing is ever allocated.\r\n\r\nWhen it comes to a bag of data, dictionaries are hard to beat 😄 "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/456416164",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-456416164",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 456416164,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NjQxNjE2NA==",
    "user": {
      "login": "JunTaoLuo",
      "id": 2030323,
      "node_id": "MDQ6VXNlcjIwMzAzMjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2030323?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JunTaoLuo",
      "html_url": "https://github.com/JunTaoLuo",
      "followers_url": "https://api.github.com/users/JunTaoLuo/followers",
      "following_url": "https://api.github.com/users/JunTaoLuo/following{/other_user}",
      "gists_url": "https://api.github.com/users/JunTaoLuo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JunTaoLuo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JunTaoLuo/subscriptions",
      "organizations_url": "https://api.github.com/users/JunTaoLuo/orgs",
      "repos_url": "https://api.github.com/users/JunTaoLuo/repos",
      "events_url": "https://api.github.com/users/JunTaoLuo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JunTaoLuo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-22T14:21:40Z",
    "updated_at": "2019-01-22T14:24:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "Right, I believe I mentioned in passing that the interceptors in GRPC world is middleware in ASP.NET Core world, and we have the `HttpContext.Items` API to achieve the objective.\r\n\r\n_Edit: Aha, I found the comment https://github.com/grpc/grpc-dotnet/issues/1#issuecomment-452587447. In the list of `Interceptor` types, I mentioned `Not used, Asp.Net Core uses middlewares`_"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/457216780",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-457216780",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 457216780,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzIxNjc4MA==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-24T14:31:01Z",
    "updated_at": "2019-01-24T14:57:15Z",
    "author_association": "NONE",
    "body": "@chwarr  I think you're unaware of an [essential piece](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollection?view=aspnetcore-2.2) and very useful [abstractions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.serviceproviderserviceextensions?view=aspnetcore-2.2) along with [extensions](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectioncontainerbuilderextensions?view=aspnetcore-2.2) that are not part of the interface itself. Most of all, `IServiceProvider` integrates very well because concrete implementations for IoC and DI build upon that interface. Most notable frameworks (redis cache, database providers, entity framework, ...) provide extension methods to be injected into a `IServiceCollection`. Injecting own types comes for free. That makes `IServiceProvider` a good candidate.\r\n\r\nGenerally speaking, there's no need to make the `IServiceProvider` interface mutable when the implementation can be made mutable if needed. In most situations it is however desirable that it is not mutable at all. If it has to be mutable, it is fair to construct a new `IServiceProvider` from a `ServiceCollection` by invoking `serviceCollection.GetServiceProvider()` and replacing the current service provider on the `ServerCallContext` by doing `serverCallContext.ServiceProvider = serviceCollection.GetServiceProvider()`. The application architect is given a plentiful of options like nesting `IServiceProvider` and overriding generic implementations and whatnot."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/457221273",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-457221273",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 457221273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzIyMTI3Mw==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-24T14:43:47Z",
    "updated_at": "2019-01-25T07:36:53Z",
    "author_association": "NONE",
    "body": "> When it comes to a bag of data, dictionaries are hard to beat smile\r\n\r\n@JamesNK .. not if the interface provides access to types that can be anything that is a type, including dictionaries. :smile:"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/457810537",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-457810537",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 457810537,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NzgxMDUzNw==",
    "user": {
      "login": "JamesNK",
      "id": 303201,
      "node_id": "MDQ6VXNlcjMwMzIwMQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/303201?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JamesNK",
      "html_url": "https://github.com/JamesNK",
      "followers_url": "https://api.github.com/users/JamesNK/followers",
      "following_url": "https://api.github.com/users/JamesNK/following{/other_user}",
      "gists_url": "https://api.github.com/users/JamesNK/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JamesNK/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JamesNK/subscriptions",
      "organizations_url": "https://api.github.com/users/JamesNK/orgs",
      "repos_url": "https://api.github.com/users/JamesNK/repos",
      "events_url": "https://api.github.com/users/JamesNK/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JamesNK/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-01-26T07:39:06Z",
    "updated_at": "2019-01-26T07:39:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "An `IServiceProvider` is not mutable. Its intended design is to be setup on application startup and then used for the lifetime of the app. The provider created from `ServiceCollection` does IL gen to resolve types as quickly as possible. Creating a new `ServiceCollection` and then getting a service provider from it for every request would have very bad performance. \r\n\r\nNow you could introduce the concept of a request scoped to Grpc.Core, and then people could register some type as scoped per-request with the service provided, and then resolve that type from a `IServiceProvider` during requests, BUT that would require a dependency on `Microsoft.Extensions.DependencyInjection` which I doubt this project would want to do, and it isn't the pit of success for anyone who just wants to set some state during a call. A dictionary is easy for every developer to understand."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/464397819",
    "html_url": "https://github.com/grpc/grpc/issues/17759#issuecomment-464397819",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/17759",
    "id": 464397819,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NDM5NzgxOQ==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-16T23:09:40Z",
    "updated_at": "2019-02-16T23:09:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "I have started [PR #18086](https://github.com/grpc/grpc/pull/18086) that implements the `IDictionary<object, object>` option that was discussed here. It looks pretty clean to me. Cleaner than the `.Get<T>()` proposal."
  }
]
