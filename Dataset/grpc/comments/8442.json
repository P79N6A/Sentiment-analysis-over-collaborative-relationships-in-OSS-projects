[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255627345",
    "html_url": "https://github.com/grpc/grpc/issues/8442#issuecomment-255627345",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8442",
    "id": 255627345,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTYyNzM0NQ==",
    "user": {
      "login": "mike07026",
      "id": 16629623,
      "node_id": "MDQ6VXNlcjE2NjI5NjIz",
      "avatar_url": "https://avatars3.githubusercontent.com/u/16629623?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mike07026",
      "html_url": "https://github.com/mike07026",
      "followers_url": "https://api.github.com/users/mike07026/followers",
      "following_url": "https://api.github.com/users/mike07026/following{/other_user}",
      "gists_url": "https://api.github.com/users/mike07026/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mike07026/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mike07026/subscriptions",
      "organizations_url": "https://api.github.com/users/mike07026/orgs",
      "repos_url": "https://api.github.com/users/mike07026/repos",
      "events_url": "https://api.github.com/users/mike07026/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mike07026/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-24T00:56:58Z",
    "updated_at": "2016-10-24T00:56:58Z",
    "author_association": "NONE",
    "body": "same requirement in #7305\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/256122140",
    "html_url": "https://github.com/grpc/grpc/issues/8442#issuecomment-256122140",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8442",
    "id": 256122140,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NjEyMjE0MA==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-25T18:21:30Z",
    "updated_at": "2016-10-25T18:21:30Z",
    "author_association": "MEMBER",
    "body": "I wholeheartedly agree we should have such an API.\n\nThe thing I don't know: the CQ keeps track of the number of items it will\neventually complete, to give the nice shutdown semantics it has (and\nfulfill the guarantee that you put a tag in you get a tag out).\n\nTo export that we'd probably want a PrepareNotify()/FinishNotify() pair,\nbut I've always considered that too tricky to explain. Without it though\nwe've undone some important semantics.\n\nOn Thu, Oct 20, 2016, 12:49 PM Jeffrey Rennie notifications@github.com\nwrote:\n\n> Let's say I have one thread and one loop that looks something like this:\n> \n>   do {\n>     bool ok;\n>     Tag\\* tag;\n>     // Wait for a pending operation to complete.  Identify the operation that\n>     // completed by examining tag.\n>     switch (cq.AsyncNext((void**)&tag, &ok, next_write_time_point)) {\n>       case grpc::CompletionQueue::SHUTDOWN:\n>         std::cerr << \"The completion queue unexpectedly shutdown.\" << std::endl;\n>         return -1;\n>       case grpc::CompletionQueue::GOT_EVENT:\n>         std::cout << tag->name << \" completed.\" << std::endl;\n>         ....\n>     }\n>   } while (true);\n> \n> And I'm calling same third-party library that invokes my callback when\n> that third-party library completes a task. I want to act on the third-party\n> libraries task completion in my same do { } while; loop.\n> \n> To synchronize, I need a thread-safe method on CompletionQueue called\n> something like Notify(void\\* tag). Then my callback can look like this:\n> \n>   third_party_library.SomeLongRunningTask(args..., [] {\n>     cq.Notify((void*)LONG_RUNNING_TASK_COMPLETE)\n>   });\n> \n> And I can handle everything in _one thread_, so I don't need mutexes or\n> locks.\n> \n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/grpc/grpc/issues/8442, or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AJpudevjqOHtuQEGoq5cmvGZoUKldCcFks5q18XYgaJpZM4Kch_e\n> .\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/260809575",
    "html_url": "https://github.com/grpc/grpc/issues/8442#issuecomment-260809575",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8442",
    "id": 260809575,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MDgwOTU3NQ==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-15T23:57:10Z",
    "updated_at": "2016-11-15T23:57:10Z",
    "author_association": "MEMBER",
    "body": "Any thoughts on the proposed semantics?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/260818134",
    "html_url": "https://github.com/grpc/grpc/issues/8442#issuecomment-260818134",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8442",
    "id": 260818134,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MDgxODEzNA==",
    "user": {
      "login": "SurferJeffAtGoogle",
      "id": 11778530,
      "node_id": "MDQ6VXNlcjExNzc4NTMw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/11778530?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SurferJeffAtGoogle",
      "html_url": "https://github.com/SurferJeffAtGoogle",
      "followers_url": "https://api.github.com/users/SurferJeffAtGoogle/followers",
      "following_url": "https://api.github.com/users/SurferJeffAtGoogle/following{/other_user}",
      "gists_url": "https://api.github.com/users/SurferJeffAtGoogle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SurferJeffAtGoogle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SurferJeffAtGoogle/subscriptions",
      "organizations_url": "https://api.github.com/users/SurferJeffAtGoogle/orgs",
      "repos_url": "https://api.github.com/users/SurferJeffAtGoogle/repos",
      "events_url": "https://api.github.com/users/SurferJeffAtGoogle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SurferJeffAtGoogle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-16T00:44:50Z",
    "updated_at": "2016-11-16T00:44:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "I don't know if we can save the user from shooting off their own foot, and I see the same potential race conditions around PrepareNotify() as would exist for FinishNotify().  So actually, PrepareNotify() only seems to add complexity, not reduce it.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/385399454",
    "html_url": "https://github.com/grpc/grpc/issues/8442#issuecomment-385399454",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8442",
    "id": 385399454,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NTM5OTQ1NA==",
    "user": {
      "login": "arthur-tacca",
      "id": 20324099,
      "node_id": "MDQ6VXNlcjIwMzI0MDk5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/20324099?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arthur-tacca",
      "html_url": "https://github.com/arthur-tacca",
      "followers_url": "https://api.github.com/users/arthur-tacca/followers",
      "following_url": "https://api.github.com/users/arthur-tacca/following{/other_user}",
      "gists_url": "https://api.github.com/users/arthur-tacca/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arthur-tacca/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arthur-tacca/subscriptions",
      "organizations_url": "https://api.github.com/users/arthur-tacca/orgs",
      "repos_url": "https://api.github.com/users/arthur-tacca/repos",
      "events_url": "https://api.github.com/users/arthur-tacca/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arthur-tacca/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-30T13:34:28Z",
    "updated_at": "2018-04-30T13:34:28Z",
    "author_association": "NONE",
    "body": "I notice that a [`grpc::Alarm`](https://grpc.io/grpc/cpp/classgrpc_1_1_alarm.html) with timeout of `gpr_timespec{0, 0, GPR_TIMESPAN}` would effectively fulfill this role, albeit in a terribly hacky way. Presumably the constructor and destructor correspond to the hypothetical `PrepareNotify` and `FinishNotify` methods mentioned in this thread? \r\n\r\nDoes anyone have any comments on using `Alarm` until an official `post()` API becomes available? Except perhaps for abject horror :-) I guess it does not hold the ordered delivery guarantee I would expect from a dedicated API (assuming one thread reading from the CQ). And could there be performance problems from (ab)using the `Alarm` API like this?"
  }
]
