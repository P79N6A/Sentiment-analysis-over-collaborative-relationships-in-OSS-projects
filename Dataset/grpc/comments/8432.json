[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255172025",
    "html_url": "https://github.com/grpc/grpc/issues/8432#issuecomment-255172025",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8432",
    "id": 255172025,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTE3MjAyNQ==",
    "user": {
      "login": "murgatroid99",
      "id": 961599,
      "node_id": "MDQ6VXNlcjk2MTU5OQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/961599?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murgatroid99",
      "html_url": "https://github.com/murgatroid99",
      "followers_url": "https://api.github.com/users/murgatroid99/followers",
      "following_url": "https://api.github.com/users/murgatroid99/following{/other_user}",
      "gists_url": "https://api.github.com/users/murgatroid99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murgatroid99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murgatroid99/subscriptions",
      "organizations_url": "https://api.github.com/users/murgatroid99/orgs",
      "repos_url": "https://api.github.com/users/murgatroid99/repos",
      "events_url": "https://api.github.com/users/murgatroid99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murgatroid99/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-20T17:26:06Z",
    "updated_at": "2016-10-20T17:26:06Z",
    "author_association": "MEMBER",
    "body": "The whole point of protocol buffers is to describe data with a known structure, so you're not going to get what you're looking for from protocol buffers. Fortunately, gRPC is not restricted to protocol buffers. You can use any serialization and deserialization you want.\n\nFor this purpose, I would suggest plain old JSON. You can define such a service like this:\n\n``` js\nfunction serializeJson(obj) {\n  return new Buffer(JSON.stringify(obj));\n}\nfunction deserializeJson(buffer) {\n  return JSON.parse(buffer.toString());\n}\nvar service = {\n  methodName: {\n    path: method_path,\n    requestStream: false,\n    responseStream: false,\n    requestSerialize: serializeJson,\n    requestDeserialize: deserializeJson,\n    responseSerialize: serializeJson,\n    responseDeserialize: deserializeJson\n  }\n};\n```\n\nThis defines a service with the method `methodName` that can be accessed at `method_path` (this is like the HTTP path, e.g. `\"/ServiceName/MethodName\"`). The method allows for one message to be sent by the client and one response to be sent by the server, instead of a stream of messages (this is what `requestStream` and `responseStream` mean). And at each end, the message provided by the application is assumed to be JSON-serializable, and is stringified, and the message received from the network is assumed to be serialized JSON, and is parsed as JSON.\n\nYou can add this service to a server by calling `server.addService(service, implementation)`, and you can create a client class from it by calling `grpc.makeGenericClientConstructor(service)`.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255220160",
    "html_url": "https://github.com/grpc/grpc/issues/8432#issuecomment-255220160",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8432",
    "id": 255220160,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTIyMDE2MA==",
    "user": {
      "login": "aguerere",
      "id": 14084214,
      "node_id": "MDQ6VXNlcjE0MDg0MjE0",
      "avatar_url": "https://avatars3.githubusercontent.com/u/14084214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aguerere",
      "html_url": "https://github.com/aguerere",
      "followers_url": "https://api.github.com/users/aguerere/followers",
      "following_url": "https://api.github.com/users/aguerere/following{/other_user}",
      "gists_url": "https://api.github.com/users/aguerere/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aguerere/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aguerere/subscriptions",
      "organizations_url": "https://api.github.com/users/aguerere/orgs",
      "repos_url": "https://api.github.com/users/aguerere/repos",
      "events_url": "https://api.github.com/users/aguerere/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aguerere/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-20T20:33:47Z",
    "updated_at": "2016-10-20T20:35:03Z",
    "author_association": "NONE",
    "body": "@murgatroid99 thank you for your thorough reply. I understand what you mean.\nBut what about [google.protobuf.Struct](https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto)?\nIt looks like that would be a way to have a .proto file like this:\n\n```\nsyntax = \"proto3\";\n\nimport \"struct.proto\";\n\nservice Engine {\n  rpc Execute (ExecuteRequest) returns (ExecuteResponse) {}\n}\n\nmessage ExecuteRequest {\n  google.protobuf.Struct context = 1;\n}\n\nmessage ExecuteResponse {\n  google.protobuf.Struct context = 1;\n}\n```\n\nThis actually compiles with the grpc dynamic loader. BUT it fails when doing the actual rpc call if I try to send a plain-old javascript object in the `context` field.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255227995",
    "html_url": "https://github.com/grpc/grpc/issues/8432#issuecomment-255227995",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8432",
    "id": 255227995,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTIyNzk5NQ==",
    "user": {
      "login": "murgatroid99",
      "id": 961599,
      "node_id": "MDQ6VXNlcjk2MTU5OQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/961599?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murgatroid99",
      "html_url": "https://github.com/murgatroid99",
      "followers_url": "https://api.github.com/users/murgatroid99/followers",
      "following_url": "https://api.github.com/users/murgatroid99/following{/other_user}",
      "gists_url": "https://api.github.com/users/murgatroid99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murgatroid99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murgatroid99/subscriptions",
      "organizations_url": "https://api.github.com/users/murgatroid99/orgs",
      "repos_url": "https://api.github.com/users/murgatroid99/repos",
      "events_url": "https://api.github.com/users/murgatroid99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murgatroid99/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-20T21:05:15Z",
    "updated_at": "2016-10-20T21:05:15Z",
    "author_association": "MEMBER",
    "body": "The problem there is that the serialization function uses the exact proto types, not their intended JSON representation. So, if you want to represent this JSON object\n\n``` js\n{\n  number: 1,\n  word: \"test\"\n}\n```\n\nYou would need to pass the following value for your `ExecuteRequest`:\n\n``` js\n{\n  context: {\n    fields: {\n      number: { number_value: 1 },\n      word: { string_value: \"test\" },\n    }\n  }\n}\n```\n\nAnd that object is what the deserializer would give you on the other end. It should be relatively straightforward to convert the simple JSON format to and from that format.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255262444",
    "html_url": "https://github.com/grpc/grpc/issues/8432#issuecomment-255262444",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8432",
    "id": 255262444,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTI2MjQ0NA==",
    "user": {
      "login": "aguerere",
      "id": 14084214,
      "node_id": "MDQ6VXNlcjE0MDg0MjE0",
      "avatar_url": "https://avatars3.githubusercontent.com/u/14084214?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aguerere",
      "html_url": "https://github.com/aguerere",
      "followers_url": "https://api.github.com/users/aguerere/followers",
      "following_url": "https://api.github.com/users/aguerere/following{/other_user}",
      "gists_url": "https://api.github.com/users/aguerere/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aguerere/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aguerere/subscriptions",
      "organizations_url": "https://api.github.com/users/aguerere/orgs",
      "repos_url": "https://api.github.com/users/aguerere/repos",
      "events_url": "https://api.github.com/users/aguerere/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aguerere/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-21T00:17:31Z",
    "updated_at": "2016-10-21T00:18:08Z",
    "author_association": "NONE",
    "body": "@murgatroid99 thank you! At last I understand how to make that work.\nWhat do you think about just using a string type and storing there the JSON.stringify() of the object, then retrieving it back with JSON.parse() ?\nWhich do you think would be the best solution, out of all three choices so far?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255263319",
    "html_url": "https://github.com/grpc/grpc/issues/8432#issuecomment-255263319",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8432",
    "id": 255263319,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTI2MzMxOQ==",
    "user": {
      "login": "murgatroid99",
      "id": 961599,
      "node_id": "MDQ6VXNlcjk2MTU5OQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/961599?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murgatroid99",
      "html_url": "https://github.com/murgatroid99",
      "followers_url": "https://api.github.com/users/murgatroid99/followers",
      "following_url": "https://api.github.com/users/murgatroid99/following{/other_user}",
      "gists_url": "https://api.github.com/users/murgatroid99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murgatroid99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murgatroid99/subscriptions",
      "organizations_url": "https://api.github.com/users/murgatroid99/orgs",
      "repos_url": "https://api.github.com/users/murgatroid99/repos",
      "events_url": "https://api.github.com/users/murgatroid99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murgatroid99/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-21T00:24:43Z",
    "updated_at": "2016-10-21T00:24:43Z",
    "author_association": "MEMBER",
    "body": "If you need to use protobuf for some reason, I think the google.protobuf.Struct option is the best. If you don't need protobuf, the direct JSON serialization seems like the simplest solution.\n\nI don't think your \"JSON string in a proto message\" is a good solution, because it has the inconvenience of double serialization without the benefit of protobuf's type safety.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/404683797",
    "html_url": "https://github.com/grpc/grpc/issues/8432#issuecomment-404683797",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8432",
    "id": 404683797,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNDY4Mzc5Nw==",
    "user": {
      "login": "aguynamedben",
      "id": 107841,
      "node_id": "MDQ6VXNlcjEwNzg0MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/107841?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aguynamedben",
      "html_url": "https://github.com/aguynamedben",
      "followers_url": "https://api.github.com/users/aguynamedben/followers",
      "following_url": "https://api.github.com/users/aguynamedben/following{/other_user}",
      "gists_url": "https://api.github.com/users/aguynamedben/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aguynamedben/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aguynamedben/subscriptions",
      "organizations_url": "https://api.github.com/users/aguynamedben/orgs",
      "repos_url": "https://api.github.com/users/aguynamedben/repos",
      "events_url": "https://api.github.com/users/aguynamedben/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aguynamedben/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-12T23:44:06Z",
    "updated_at": "2018-07-12T23:44:06Z",
    "author_association": "NONE",
    "body": "Thanks for having this discussion. I'm in the exact same boat and this was helpful.\r\n\r\nFWIW I'm using [grpc-promise](https://github.com/carlessistare/grpc-promise) to make RPC calls between Electron processes using ES6 async/await syntax. I don't care as much about being strict on data types, but gRPC + grpc-promise provides a really good API! In my renderer I can do\r\n\r\n```jsx\r\nconst response = await backendClient.API().execute({ action: 'migrate' });\r\n```\r\n\r\n👍 Thanks for the time you put into working on gRPC."
  }
]
