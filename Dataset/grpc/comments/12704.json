[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/332416455",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-332416455",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 332416455,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMjQxNjQ1NQ==",
    "user": {
      "login": "shao1555",
      "id": 249170,
      "node_id": "MDQ6VXNlcjI0OTE3MA==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/249170?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shao1555",
      "html_url": "https://github.com/shao1555",
      "followers_url": "https://api.github.com/users/shao1555/followers",
      "following_url": "https://api.github.com/users/shao1555/following{/other_user}",
      "gists_url": "https://api.github.com/users/shao1555/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shao1555/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shao1555/subscriptions",
      "organizations_url": "https://api.github.com/users/shao1555/orgs",
      "repos_url": "https://api.github.com/users/shao1555/repos",
      "events_url": "https://api.github.com/users/shao1555/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shao1555/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-27T05:53:51Z",
    "updated_at": "2017-09-27T05:53:51Z",
    "author_association": "NONE",
    "body": "me too..."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/334237484",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-334237484",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 334237484,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNDIzNzQ4NA==",
    "user": {
      "login": "sreecha",
      "id": 2754995,
      "node_id": "MDQ6VXNlcjI3NTQ5OTU=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2754995?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sreecha",
      "html_url": "https://github.com/sreecha",
      "followers_url": "https://api.github.com/users/sreecha/followers",
      "following_url": "https://api.github.com/users/sreecha/following{/other_user}",
      "gists_url": "https://api.github.com/users/sreecha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sreecha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sreecha/subscriptions",
      "organizations_url": "https://api.github.com/users/sreecha/orgs",
      "repos_url": "https://api.github.com/users/sreecha/repos",
      "events_url": "https://api.github.com/users/sreecha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sreecha/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-04T17:52:45Z",
    "updated_at": "2017-10-04T17:52:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "- Is your program doing something with unix signals ? (more specifically with signal 40 ? i.e  `SIGRTMIN+6`  ) like masking signals or registering a custom signal handler ? \r\n\r\n- Can you do `ulimit -a` and paste the output here? (I am more interested in seeing the `pending signals` limit) "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335048663",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335048663",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335048663,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTA0ODY2Mw==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-09T00:10:43Z",
    "updated_at": "2017-10-09T00:20:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "@sreecha Thanks for the reply.\r\n\r\nHere are all signals my program explicitly uses: `SIGINT`, `SIGTERM`, `SIGUSR1`, `SIGUSR2`. And I don't think that there are third-party utililites my program depends on use the RT signal mechanism so heavily like in gRPC.\r\n\r\nHere are `ulimit -a`s outputs:\r\n```\r\ncore file size          (blocks, -c) unlimited\r\ndata seg size           (kbytes, -d) unlimited\r\nscheduling priority             (-e) 0\r\nfile size               (blocks, -f) unlimited\r\npending signals                 (-i) 1030587\r\nmax locked memory       (kbytes, -l) 64\r\nmax memory size         (kbytes, -m) unlimited\r\nopen files                      (-n) 655360\r\npipe size            (512 bytes, -p) 8\r\nPOSIX message queues     (bytes, -q) 819200\r\nreal-time priority              (-r) 0\r\nstack size              (kbytes, -s) unlimited\r\ncpu time               (seconds, -t) unlimited\r\nmax user processes              (-u) 655360\r\nvirtual memory          (kbytes, -v) unlimited\r\nfile locks                      (-x) unlimited\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335646161",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335646161",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335646161,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY0NjE2MQ==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T00:28:34Z",
    "updated_at": "2017-10-11T00:28:34Z",
    "author_association": "CONTRIBUTOR",
    "body": "This issue seems more critical now.\r\n\r\nBecause the rt signal is queued tooo many, epoll_pwait always return immediately, which leads to high CPU usage. And, thanks to the error log, mutex (possible) from inside the vsprintf family is highly contended. All these things make the performance of our application degrades terribly."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335647652",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335647652",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335647652,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY0NzY1Mg==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T00:39:29Z",
    "updated_at": "2017-10-11T00:39:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "Here is my questions that you guys maybe enlight me:\r\n * When `pthread_kill` or `pollset_worker_kick` is invoked, in what kind of context.\r\n * I saw the `is_kicked` atomic operation, but how could gRPC can guarantee that the queued signals are consumed up in time, at the same pace with `pthread_kill`. AFAK, invoking the signal handler is completely up to the kernel."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335655074",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335655074",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335655074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY1NTA3NA==",
    "user": {
      "login": "sreecha",
      "id": 2754995,
      "node_id": "MDQ6VXNlcjI3NTQ5OTU=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2754995?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sreecha",
      "html_url": "https://github.com/sreecha",
      "followers_url": "https://api.github.com/users/sreecha/followers",
      "following_url": "https://api.github.com/users/sreecha/following{/other_user}",
      "gists_url": "https://api.github.com/users/sreecha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sreecha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sreecha/subscriptions",
      "organizations_url": "https://api.github.com/users/sreecha/orgs",
      "repos_url": "https://api.github.com/users/sreecha/repos",
      "events_url": "https://api.github.com/users/sreecha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sreecha/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T01:31:48Z",
    "updated_at": "2017-10-11T01:32:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hmm..I am not exactly sure what is going on your application.. it seems like the for some reason, the  signal `SIGMINRT+6` is not getting delivered and getting queued up. In the past the only times I saw such an error was either (a) if the application was explicitly blocking the signal or (b) if it registered a custom signal handler and then re-raising that signal (which is left unhandled)\r\n\r\nNow to answer your questions:\r\n- `pollset_worker_kick` (which calls `pthread_kill`) is called when there is an event on the completion queue - and the thread that is interested in that event is potentially blocked in inside `epoll_pwait`.   So we use this signal (`pthread_kill`) to get that thread out of `epoll_pwait`  \r\n\r\n- `is_kicked` is used to prevent calling another `pthread_kill` on a thread that already received a signal. \r\nThe signal here is used as a mechanism to interrupt a thread and bring it out of `epoll_pwait` - so when exactly the signal handler is invoked isn't super critical (also I do _not_ think the kernel is delaying delivering this signals so much that it results the errors you are seeing. Moreover, your `ulimit -i` i.e the `pending signals` queue size is over a million which is pretty big).\r\n\r\n---\r\n### Solution:\r\nWe will be releasing version 1.7 very soon (in the next couple of weeks or so) and that uses a completely different polling engine by default that does not use signals. Once you upgrade to 1.7 you will not be seeing this issue\r\n\r\n### Short-term mitigation:\r\nTo mitigate this in the **short term**, you can use a different polling engine by setting the environment variable `GRPC_POLL_STRATEGY` to `\"poll\"` before launching your application ?  (i.e `\"export GRPC_POLL_STRATEGY=poll\"`)\r\n\r\nThis will use a different polling engine that does not use signals. Please note that this does not scale well for a large number of file descriptors (i.e thousands of concurrent connections)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335690194",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335690194",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335690194,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY5MDE5NA==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T05:49:17Z",
    "updated_at": "2017-10-11T05:49:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "I added some thread local state counters in `ev_epollsig_linux.c` to trace serveral actions. Here are the counters of one specific CQ(thread) out of 32 ones:\r\n\r\n * `pollset_worker_kick` called 1445968 times.\r\n * `\"finally_kick\"` from `pollset_kick` called 1445968 times.\r\n * `pthread_kill` called 600000 times.\r\n * `pthread_kill` failed with `EAGAIN` 556575 times.\r\n * `epoll_pwait` called 101149 times.\r\n * `epoll_pwait` failed with `EINTR` 8610 times.\r\n * signal handler called 8610 times.\r\n\r\nAs shown, the signal handler is invoked only if (but not every time) `epoll_pwait` called, which is reasonable due to the sigmask. Although `kick`s or `pthread_kill`s are for to other CQ threads from this specific thread, numbers of every thread are overall the same. The peculiar thing is that `pthread_kill` is invoked way more times than signal handler.\r\n\r\n@sreecha \r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335692666",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335692666",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335692666,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY5MjY2Ng==",
    "user": {
      "login": "sreecha",
      "id": 2754995,
      "node_id": "MDQ6VXNlcjI3NTQ5OTU=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2754995?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sreecha",
      "html_url": "https://github.com/sreecha",
      "followers_url": "https://api.github.com/users/sreecha/followers",
      "following_url": "https://api.github.com/users/sreecha/following{/other_user}",
      "gists_url": "https://api.github.com/users/sreecha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sreecha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sreecha/subscriptions",
      "organizations_url": "https://api.github.com/users/sreecha/orgs",
      "repos_url": "https://api.github.com/users/sreecha/repos",
      "events_url": "https://api.github.com/users/sreecha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sreecha/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T06:05:45Z",
    "updated_at": "2017-10-11T06:07:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the info @dutor \r\nYou are right that the `pthread_kill` counts are from the current thread to the _other_ threads but if the counts are this high for every thread, then this is very peculiar..\r\n\r\nIs there a lot of thread-churn in your application ? - i.e are the set of 32 threads polling the cqs changing constantly ? - if so, that might explain this behavior.\r\n(If not all threads, is there a sub-set of threads that poll cq that are constantly changing ?)"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335693167",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335693167",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335693167,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY5MzE2Nw==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T06:09:12Z",
    "updated_at": "2017-10-11T06:09:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "@sreecha \r\n * I wrote a demo application, and it does not use any RT signals.\r\n * `is_kicked` is for every `poolset_worker`, but not an thread.\r\n * Although timing of the invoke of signal handler is not critical for the main logics, but the chances that the handler get invoked are tiny.\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335693706",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335693706",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335693706,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY5MzcwNg==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T06:12:43Z",
    "updated_at": "2017-10-11T06:13:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "@sreecha I don't quite follow what _thread-churn_ and _changing_ mean. I have 32 threads each of which runs its own CQ. In each thread, they handle requests from remotes, and request to remotes at the same time, all in a async way."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335694763",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335694763",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335694763,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTY5NDc2Mw==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T06:19:43Z",
    "updated_at": "2017-10-11T06:26:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "FYR.\r\n\r\nEvery thread runs this:\r\n```cpp\r\n    auto run = [this] (ServerCompletionQueue *cq, GrpcClient *client) {\r\n        new CallData(&service_, cq, client);\r\n        void *tag = NULL;\r\n        bool ok;\r\n        while (true) {\r\n            cq->Next(&tag, &ok);\r\n            if (!ok) {\r\n                break;\r\n            }\r\n            (*reinterpret_cast<Tag*>(tag))();\r\n        }\r\n    };\r\n```\r\n\r\n`Tag` is a `CallData`, whose `operator()` is:\r\n```cpp\r\nCallData::operator()() {\r\n     if (status_ == PROCESS) {\r\n        new CallData(service_, cq_, client_);\r\n        status_ = FINISH;\r\n        if (req_.hop() == 1) {\r\n            resp_.set_msg(req_.msg());\r\n            responder_.Finish(resp_, Status::OK, this);\r\n            return;\r\n        }\r\n        auto cb = [this] (EchoResponse *resp) {\r\n            resp_.set_msg(req_.msg());\r\n            responder_.Finish(resp_, Status::OK, this);\r\n        };\r\n        req_.set_hop(req_.hop() - 1);\r\n        client_->Echo(req_, std::move(cb));\r\n    } else if (status_ == FINISH) {\r\n        delete this;\r\n    } else {\r\n        assert(false);\r\n    }\r\n}\r\n\r\n```\r\n\r\nThe demo is an async echo server. Every echo message has a `hop` field. If the `hop` reaches 0, the server send response directly, or it would redirect the message to another server with `hop` decreased by 1."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/335888657",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-335888657",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 335888657,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTg4ODY1Nw==",
    "user": {
      "login": "sreecha",
      "id": 2754995,
      "node_id": "MDQ6VXNlcjI3NTQ5OTU=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2754995?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sreecha",
      "html_url": "https://github.com/sreecha",
      "followers_url": "https://api.github.com/users/sreecha/followers",
      "following_url": "https://api.github.com/users/sreecha/following{/other_user}",
      "gists_url": "https://api.github.com/users/sreecha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sreecha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sreecha/subscriptions",
      "organizations_url": "https://api.github.com/users/sreecha/orgs",
      "repos_url": "https://api.github.com/users/sreecha/repos",
      "events_url": "https://api.github.com/users/sreecha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sreecha/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T17:35:46Z",
    "updated_at": "2017-10-11T17:35:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "Do you have two servers ? or is the server sending to itself? - Would you be able to share the whole demo program so that I can try to repro the issue here?\r\n\r\nBy the way, we are releasing grpc version 1.7 this week and that will fix the issue you are seeing. If you want to try this out, the changes are already at HEAD."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/336330427",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-336330427",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 336330427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjMzMDQyNw==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-13T02:09:37Z",
    "updated_at": "2017-10-13T02:09:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, I have one async client, and two async server talking to each other. Later, I could extract the main codes of my demo and paste them here.\r\n\r\nI will wait for your release of 1.7."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/336363592",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-336363592",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 336363592,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNjM2MzU5Mg==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-13T06:35:54Z",
    "updated_at": "2017-10-13T06:47:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is the proto definition.\r\n```protobuf\r\nsyntax = \"proto3\";\r\npackage echo.proto;\r\n\r\noption cc_generic_services = false;\r\noption optimize_for = SPEED;\r\nimport \"google/protobuf/empty.proto\";\r\n\r\nmessage EchoRequest\r\n{\r\n    string msg = 1;\r\n    uint32 hop = 2;\r\n}\r\n\r\nmessage EchoResponse\r\n{\r\n    string msg = 1;\r\n}\r\n\r\nservice EchoService\r\n{\r\n    rpc Echo(EchoRequest) returns (EchoResponse);\r\n}\r\n```\r\n\r\nThis is Server.\r\n\r\n```cpp\r\n#include <thread>\r\n#include <mutex>\r\n#include <atomic>\r\n#include <grpc++/grpc++.h>\r\n#include \"proto/echo_api.pb.h\"\r\n#include \"proto/echo_api.grpc.pb.h\"\r\nnamespace echo {\r\n\r\n/**\r\n * GrpcClient, GrpcAsyncServer, etc.\r\n */\r\nclass Tag {\r\npublic:\r\n    virtual ~Tag() {}\r\n    virtual void operator()() = 0;\r\n};\r\n\r\nclass ClosureBase : public Tag {\r\npublic:\r\n    ClosureBase() = default;\r\n    virtual ~ClosureBase() = default;\r\n    grpc::ClientContext& context() {\r\n        return context_;\r\n    }\r\n\r\n    grpc::Status& status() {\r\n        return status_;\r\n    }\r\n\r\nprotected:\r\n    grpc::ClientContext         context_;\r\n    grpc::Status                status_;\r\n};\r\ntemplate <typename Resp>\r\nclass Closure : public ClosureBase {\r\npublic:\r\n    explicit Closure(std::function<void(Resp*)> &&);\r\n    virtual ~Closure() = default;\r\n    using AsyncPtr = std::unique_ptr<grpc::ClientAsyncResponseReader<Resp>>;\r\n    void finish(AsyncPtr ptr);\r\n    void operator()() override;\r\nprivate:\r\n    AsyncPtr                    asyncPtr_;\r\n    Resp                        resp_;\r\n    std::function<void(Resp*)>  callback_;\r\n};\r\n\r\nclass GrpcClient {\r\npublic:\r\n    using CompletionQueue = grpc::CompletionQueue;\r\n    using EchoService = echo::proto::EchoService;\r\n    using Stub = EchoService::Stub;\r\n    using EchoRequest = echo::proto::EchoRequest;\r\n    using EchoResponse = echo::proto::EchoResponse;\r\n\r\n    GrpcClient(std::shared_ptr<CompletionQueue> cq, std::unique_ptr<Stub> stub);\r\n    ~GrpcClient();\r\n\r\n    void Echo(const EchoRequest &request, std::function<void(EchoResponse*)> callback);\r\n\r\nprivate:\r\n    std::shared_ptr<CompletionQueue>            cq_;\r\n    std::unique_ptr<Stub>                       stub_;\r\n};\r\n\r\ntemplate <typename Resp>\r\nClosure<Resp>::Closure(std::function<void(Resp*)> &&callback)\r\n    : callback_(std::move(callback)) {\r\n}\r\n\r\ntemplate <typename Resp>\r\nvoid Closure<Resp>::finish(AsyncPtr ptr) {\r\n    //asyncPtr_ = std::move(ptr);\r\n    //asyncPtr_->Finish(&resp_, &status_, reinterpret_cast<void*>(this));\r\n    ptr->Finish(&resp_, &status_, reinterpret_cast<void*>(this));\r\n}\r\n\r\ntemplate <typename Resp>\r\nvoid Closure<Resp>::operator()() {\r\n    if (status_.ok()) {\r\n        callback_(&resp_);\r\n    } else {\r\n        callback_(nullptr);\r\n    }\r\n    delete this;\r\n}\r\n\r\nGrpcClient::GrpcClient(std::shared_ptr<CompletionQueue> cq, std::unique_ptr<Stub> stub) {\r\n    cq_ = std::move(cq);\r\n    stub_ = std::move(stub);\r\n}\r\n\r\nGrpcClient::~GrpcClient() {\r\n}\r\n\r\nvoid GrpcClient::Echo(const EchoRequest &req, std::function<void(EchoResponse*)> callback) {\r\n    auto closure = new Closure<EchoResponse>(std::move(callback));\r\n\r\n    closure->finish(stub_->AsyncEcho(&closure->context(), req, cq_.get()));\r\n}\r\n\r\n\r\nclass GrpcAsyncServer {\r\npublic:\r\n    GrpcAsyncServer(std::string local, std::string remote, size_t nr_cq);\r\n    void stop();\r\n    void wait();\r\nprivate:\r\n    using Status = grpc::Status;\r\n    using ServerContext = grpc::ServerContext;\r\n    using Server = grpc::Server;\r\n    using ServerBuilder = grpc::ServerBuilder;\r\n    using ServerCompletionQueue = grpc::ServerCompletionQueue;\r\n    using EchoRequest = echo::proto::EchoRequest;\r\n    using EchoResponse = echo::proto::EchoResponse;\r\n\r\n    class CallData : public Tag {\r\n    public:\r\n        using Status = grpc::Status;\r\n        using ServerContext = grpc::ServerContext;\r\n        using ServerCompletionQueue = grpc::ServerCompletionQueue;\r\n        using EchoRequest = echo::proto::EchoRequest;\r\n        using EchoResponse = echo::proto::EchoResponse;\r\n\r\n        CallData(proto::EchoService::AsyncService *service,\r\n                ServerCompletionQueue *cq, GrpcClient *client);\r\n        void operator()() override;\r\n\r\n    private:\r\n        enum CallStatus {\r\n            PROCESS,\r\n            FINISH,\r\n        };\r\n        CallStatus                                  status_;\r\n        proto::EchoService::AsyncService           *service_;\r\n        ServerCompletionQueue                      *cq_;\r\n        GrpcClient                                 *client_;\r\n        ServerContext                               ctx_;\r\n        EchoRequest                                 req_;\r\n        EchoResponse                                resp_;\r\n        grpc::ServerAsyncResponseWriter<EchoResponse>     responder_;\r\n    };\r\n\r\nprivate:\r\n    std::atomic<bool>                                       stopped_{false};\r\n    ServerBuilder                                           builder_;\r\n    std::vector<std::unique_ptr<std::thread>>               threads_;\r\n    std::vector<std::shared_ptr<ServerCompletionQueue>>     cqs_;\r\n    proto::EchoService::AsyncService                        service_;\r\n    std::unique_ptr<Server>                                 server_;\r\n    std::vector<std::unique_ptr<GrpcClient>>                clients_;\r\n};\r\n\r\nGrpcServer::GrpcServer() {\r\n}\r\n\r\nGrpcServer::~GrpcServer() {\r\n}\r\n\r\ngrpc::Status GrpcServer::Echo(ServerContext *ctx, const proto::EchoRequest *req,\r\n                             proto::EchoResponse *result) {\r\n    result->set_msg(req->msg());\r\n    return Status::OK;\r\n}\r\n\r\nGrpcAsyncServer::GrpcAsyncServer(std::string local, std::string remote, size_t nr_cq) {\r\n    builder_.AddListeningPort(local, grpc::InsecureServerCredentials());\r\n    builder_.RegisterService(&service_);\r\n    auto run = [this] (ServerCompletionQueue *cq, GrpcClient *client) {\r\n        new CallData(&service_, cq, client);\r\n        void *tag = NULL;\r\n        bool ok;\r\n        while (true) {\r\n            cq->Next(&tag, &ok);\r\n            if (!ok) {\r\n                break;\r\n            }\r\n            (*reinterpret_cast<Tag*>(tag))();\r\n        }\r\n    };\r\n    for (auto i = 0; i < nr_cq; i++) {\r\n        std::shared_ptr<ServerCompletionQueue> cq = builder_.AddCompletionQueue();\r\n        auto channel = std::shared_ptr<grpc::Channel>(\r\n                grpc::CreateChannel(remote, grpc::InsecureChannelCredentials()));\r\n        auto stub = echo::proto::EchoService::NewStub(std::move(channel));\r\n        clients_.emplace_back(std::make_unique<GrpcClient>(cq, std::move(stub)));\r\n        cqs_.emplace_back(cq);\r\n    }\r\n    server_ = builder_.BuildAndStart();\r\n\r\n    for (auto i = 0; i < cqs_.size(); i++) {\r\n        threads_.emplace_back(std::make_unique<std::thread>(run, cqs_[i].get(),\r\n                                                            clients_[i].get()));\r\n    }\r\n}\r\n\r\nvoid GrpcAsyncServer::stop() {\r\n    if (!stopped_) {\r\n        stopped_ = true;\r\n        server_->Shutdown();\r\n        for (auto &cq : cqs_) {\r\n            cq->Shutdown();\r\n        }\r\n    }\r\n}\r\n\r\nvoid GrpcAsyncServer::wait() {\r\n    for (auto &th : threads_) {\r\n        th->join();\r\n    }\r\n}\r\n\r\nGrpcAsyncServer::CallData::CallData(proto::EchoService::AsyncService *service,\r\n        ServerCompletionQueue *cq, GrpcClient *client)\r\n    : service_(service),\r\n      cq_(cq),\r\n      client_(client),\r\n      responder_(&ctx_) {\r\n    service_->RequestEcho(&ctx_, &req_, &responder_, cq_, cq_, this);\r\n    status_ = PROCESS;\r\n}\r\n\r\nvoid GrpcAsyncServer::CallData::operator()() {\r\n     if (status_ == PROCESS) {\r\n        new CallData(service_, cq_, client_);\r\n        status_ = FINISH;\r\n        if (req_.hop() == 1) {    // this is the last hop\r\n            resp_.set_msg(req_.msg());\r\n            responder_.Finish(resp_, Status::OK, this);\r\n            return;\r\n        }\r\n        auto cb = [this] (EchoResponse *resp) {\r\n            resp_.set_msg(req_.msg());\r\n            responder_.Finish(resp_, Status::OK, this);\r\n        };\r\n        req_.set_hop(req_.hop() - 1);   // redirect to another server\r\n        client_->Echo(req_, std::move(cb));\r\n    } else if (status_ == FINISH) {\r\n        delete this;\r\n    } else {\r\n        assert(false);\r\n    }\r\n}\r\n\r\n}\r\n```\r\n\r\nThe client logics is like this:\r\n```cpp\r\nRateLimiter limiter;\r\nGrpcAsyncClient clients[];\r\nauto run = [] () {    // many threads run this\r\n    while (!stopped) {\r\n        limiter.take();    // rate limiter controls rate of request sending\r\n        auto cb = [] (EchoResponse *resp) {\r\n            limiter.release();\r\n            // handle responses\r\n        };\r\n        // prepare requests\r\n        req.set_hop(2);\r\n        auto client = pickClientRandomly();\r\n        client->Echo(req, cb);\r\n    }\r\n};\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/344862669",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-344862669",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 344862669,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NDg2MjY2OQ==",
    "user": {
      "login": "wylazy",
      "id": 1896790,
      "node_id": "MDQ6VXNlcjE4OTY3OTA=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1896790?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wylazy",
      "html_url": "https://github.com/wylazy",
      "followers_url": "https://api.github.com/users/wylazy/followers",
      "following_url": "https://api.github.com/users/wylazy/following{/other_user}",
      "gists_url": "https://api.github.com/users/wylazy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wylazy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wylazy/subscriptions",
      "organizations_url": "https://api.github.com/users/wylazy/orgs",
      "repos_url": "https://api.github.com/users/wylazy/repos",
      "events_url": "https://api.github.com/users/wylazy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wylazy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-16T09:19:10Z",
    "updated_at": "2017-11-16T09:19:10Z",
    "author_association": "NONE",
    "body": "This problem may be solved by call service_->RequestEcho() many times before while loop to eliminate pthread_kill\r\n```\r\n    auto run = [this] (ServerCompletionQueue *cq, GrpcClient *client) {\r\n        // Add for loop here\r\n        for (int i = 0; i < 1024; i++) {\r\n            new CallData(&service_, cq, client);  // call service_->RequestEcho()\r\n        }\r\n        void *tag = NULL;\r\n        bool ok;\r\n        while (true) {\r\n            cq->Next(&tag, &ok);\r\n            if (!ok) {\r\n                break;\r\n            }\r\n            (*reinterpret_cast<Tag*>(tag))();\r\n        }\r\n    };\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/345174704",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-345174704",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 345174704,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTE3NDcwNA==",
    "user": {
      "login": "dutor",
      "id": 440396,
      "node_id": "MDQ6VXNlcjQ0MDM5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/440396?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dutor",
      "html_url": "https://github.com/dutor",
      "followers_url": "https://api.github.com/users/dutor/followers",
      "following_url": "https://api.github.com/users/dutor/following{/other_user}",
      "gists_url": "https://api.github.com/users/dutor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dutor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dutor/subscriptions",
      "organizations_url": "https://api.github.com/users/dutor/orgs",
      "repos_url": "https://api.github.com/users/dutor/repos",
      "events_url": "https://api.github.com/users/dutor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dutor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-17T08:13:40Z",
    "updated_at": "2017-11-17T08:13:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "@wylazy Thanks for reply, but what's the rationale?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/345492694",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-345492694",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 345492694,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTQ5MjY5NA==",
    "user": {
      "login": "wylazy",
      "id": 1896790,
      "node_id": "MDQ6VXNlcjE4OTY3OTA=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1896790?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wylazy",
      "html_url": "https://github.com/wylazy",
      "followers_url": "https://api.github.com/users/wylazy/followers",
      "following_url": "https://api.github.com/users/wylazy/following{/other_user}",
      "gists_url": "https://api.github.com/users/wylazy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wylazy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wylazy/subscriptions",
      "organizations_url": "https://api.github.com/users/wylazy/orgs",
      "repos_url": "https://api.github.com/users/wylazy/repos",
      "events_url": "https://api.github.com/users/wylazy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wylazy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-19T05:09:29Z",
    "updated_at": "2017-11-19T05:09:29Z",
    "author_association": "NONE",
    "body": "@dutor Because your server has many CompletionQueues which are waiting at epoll_pwait(). When clients request so many RPC calls at the same time. One CompletionQueue will be awake first and read the requests from clients, but it can process only one request. So it put remainded requests to other CompletionQueues, and then call pthread_kill() many times to notify. \r\n    When clients send so many requests concurently, and epoll_pwait() returns, a notified worker thread can process many requests, but consume only one signal (other signals are queued). If your clients send requests constantly, pending signals will accumulate. \r\n    But if you call service_->RequestEcho() many times when init, this requests are queued at the CompletionQueue. When this CompletionQueue receive many RPC call from a client. It can process the RPC call itself. There is no need to call pthread_kill()."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/350884047",
    "html_url": "https://github.com/grpc/grpc/issues/12704#issuecomment-350884047",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/12704",
    "id": 350884047,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MDg4NDA0Nw==",
    "user": {
      "login": "sreecha",
      "id": 2754995,
      "node_id": "MDQ6VXNlcjI3NTQ5OTU=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2754995?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sreecha",
      "html_url": "https://github.com/sreecha",
      "followers_url": "https://api.github.com/users/sreecha/followers",
      "following_url": "https://api.github.com/users/sreecha/following{/other_user}",
      "gists_url": "https://api.github.com/users/sreecha/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sreecha/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sreecha/subscriptions",
      "organizations_url": "https://api.github.com/users/sreecha/orgs",
      "repos_url": "https://api.github.com/users/sreecha/repos",
      "events_url": "https://api.github.com/users/sreecha/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sreecha/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-11T22:47:43Z",
    "updated_at": "2017-12-11T22:47:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "@dutor , you should not be seeing this from 1.7 release onwards since 'epollsig' is no longer the default polling engine.\r\n\r\nI am closing this issue."
  }
]
