[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/188313502",
    "html_url": "https://github.com/grpc/grpc/issues/5377#issuecomment-188313502",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5377",
    "id": 188313502,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4ODMxMzUwMg==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-24T15:48:57Z",
    "updated_at": "2016-02-24T15:48:57Z",
    "author_association": "MEMBER",
    "body": "I wouldn't be opposed. We need to give some thought to API.\n\n@makdharma - assigning to you to figure out, as the default backoff algorithm seems like it'd be problematic for some mobile use cases also.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/188396843",
    "html_url": "https://github.com/grpc/grpc/issues/5377#issuecomment-188396843",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5377",
    "id": 188396843,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4ODM5Njg0Mw==",
    "user": {
      "login": "aisotton",
      "id": 1138476,
      "node_id": "MDQ6VXNlcjExMzg0NzY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1138476?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/aisotton",
      "html_url": "https://github.com/aisotton",
      "followers_url": "https://api.github.com/users/aisotton/followers",
      "following_url": "https://api.github.com/users/aisotton/following{/other_user}",
      "gists_url": "https://api.github.com/users/aisotton/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/aisotton/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/aisotton/subscriptions",
      "organizations_url": "https://api.github.com/users/aisotton/orgs",
      "repos_url": "https://api.github.com/users/aisotton/repos",
      "events_url": "https://api.github.com/users/aisotton/events{/privacy}",
      "received_events_url": "https://api.github.com/users/aisotton/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-24T18:32:48Z",
    "updated_at": "2016-02-24T18:32:48Z",
    "author_association": "NONE",
    "body": "For what it's worth, we don't care about how exactly the increasing backoff is calculated. We just want to be able to set a maximum value for the backoff. We also don't care about jittering (but it doesn't hurt either).\n\nHaving a hardcoded algorithm with the ability to set the maximum, or having the ability to plug in our own algorithm would work equally well for us. Just setting the maximum would require less coding from our side, but even if we had to write our own algorithm that wouldn't be a big deal.\n\nA channel argument seems like it would work well to change the maximum. I'd be happy to add that. I don't know what the best way would be to plug in a custom algorithm.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/188399107",
    "html_url": "https://github.com/grpc/grpc/issues/5377#issuecomment-188399107",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5377",
    "id": 188399107,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4ODM5OTEwNw==",
    "user": {
      "login": "larsonmpdx",
      "id": 12436438,
      "node_id": "MDQ6VXNlcjEyNDM2NDM4",
      "avatar_url": "https://avatars2.githubusercontent.com/u/12436438?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/larsonmpdx",
      "html_url": "https://github.com/larsonmpdx",
      "followers_url": "https://api.github.com/users/larsonmpdx/followers",
      "following_url": "https://api.github.com/users/larsonmpdx/following{/other_user}",
      "gists_url": "https://api.github.com/users/larsonmpdx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/larsonmpdx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/larsonmpdx/subscriptions",
      "organizations_url": "https://api.github.com/users/larsonmpdx/orgs",
      "repos_url": "https://api.github.com/users/larsonmpdx/repos",
      "events_url": "https://api.github.com/users/larsonmpdx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/larsonmpdx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-24T18:39:08Z",
    "updated_at": "2016-02-24T18:39:08Z",
    "author_association": "NONE",
    "body": "I'd use this feature.  I have a desktop application where I want to give the user control over manual retries, and mobile clients where I want a little more control.  Currently I'm using a second thread that calls (in c++) TryCancel() in order to enforce a max limit, but I'd love to get rid of that code.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/188401214",
    "html_url": "https://github.com/grpc/grpc/issues/5377#issuecomment-188401214",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5377",
    "id": 188401214,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4ODQwMTIxNA==",
    "user": {
      "login": "larsonmpdx",
      "id": 12436438,
      "node_id": "MDQ6VXNlcjEyNDM2NDM4",
      "avatar_url": "https://avatars2.githubusercontent.com/u/12436438?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/larsonmpdx",
      "html_url": "https://github.com/larsonmpdx",
      "followers_url": "https://api.github.com/users/larsonmpdx/followers",
      "following_url": "https://api.github.com/users/larsonmpdx/following{/other_user}",
      "gists_url": "https://api.github.com/users/larsonmpdx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/larsonmpdx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/larsonmpdx/subscriptions",
      "organizations_url": "https://api.github.com/users/larsonmpdx/orgs",
      "repos_url": "https://api.github.com/users/larsonmpdx/repos",
      "events_url": "https://api.github.com/users/larsonmpdx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/larsonmpdx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-24T18:46:13Z",
    "updated_at": "2016-02-24T18:46:13Z",
    "author_association": "NONE",
    "body": "semi-related: for long-running streaming RPCs where there is an infinite timeout used, the second-thread approach is all but required if I want to be able to cancel during a connection attempt using the sync api.  If I could set a timeout on connecting, but still have an infinite timeout during the stream, that would let me remove the watchdog thread (and bring this complexity into grpc, nothing's free)\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/188939912",
    "html_url": "https://github.com/grpc/grpc/issues/5377#issuecomment-188939912",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5377",
    "id": 188939912,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE4ODkzOTkxMg==",
    "user": {
      "login": "makdharma",
      "id": 17325098,
      "node_id": "MDQ6VXNlcjE3MzI1MDk4",
      "avatar_url": "https://avatars0.githubusercontent.com/u/17325098?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/makdharma",
      "html_url": "https://github.com/makdharma",
      "followers_url": "https://api.github.com/users/makdharma/followers",
      "following_url": "https://api.github.com/users/makdharma/following{/other_user}",
      "gists_url": "https://api.github.com/users/makdharma/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/makdharma/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/makdharma/subscriptions",
      "organizations_url": "https://api.github.com/users/makdharma/orgs",
      "repos_url": "https://api.github.com/users/makdharma/repos",
      "events_url": "https://api.github.com/users/makdharma/events{/privacy}",
      "received_events_url": "https://api.github.com/users/makdharma/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-25T19:23:46Z",
    "updated_at": "2016-02-25T19:23:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "The idea of exposing maximum backoff period through API seems OK to me, and\nuseful in mobile context also. Aaron, please go ahead and submit your patch\nand we can debate on the mechanism.\n\nOn Wed, Feb 24, 2016 at 10:46 AM, larsonmpdx notifications@github.com\nwrote:\n\n> semi-related: for long-running streaming RPCs where there is an infinite\n> timeout used, the second-thread approach is all but required if I want to\n> be able to cancel during a connection attempt using the sync api. If I\n> could set a timeout on connecting, but still have an infinite timeout\n> during the stream, that would let me remove the watchdog thread (and bring\n> this complexity into grpc, nothing's free)\n> \n> â€”\n> Reply to this email directly or view it on GitHub\n> https://github.com/grpc/grpc/issues/5377#issuecomment-188401214.\n"
  }
]
