[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/463507917",
    "html_url": "https://github.com/grpc/grpc/issues/18055#issuecomment-463507917",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/18055",
    "id": 463507917,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MzUwNzkxNw==",
    "user": {
      "login": "yiakwy",
      "id": 8510840,
      "node_id": "MDQ6VXNlcjg1MTA4NDA=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8510840?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yiakwy",
      "html_url": "https://github.com/yiakwy",
      "followers_url": "https://api.github.com/users/yiakwy/followers",
      "following_url": "https://api.github.com/users/yiakwy/following{/other_user}",
      "gists_url": "https://api.github.com/users/yiakwy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yiakwy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yiakwy/subscriptions",
      "organizations_url": "https://api.github.com/users/yiakwy/orgs",
      "repos_url": "https://api.github.com/users/yiakwy/repos",
      "events_url": "https://api.github.com/users/yiakwy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yiakwy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-14T06:29:48Z",
    "updated_at": "2019-02-14T06:29:48Z",
    "author_association": "NONE",
    "body": "@ZhouyihaiDing Could you help on this topic?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/465379008",
    "html_url": "https://github.com/grpc/grpc/issues/18055#issuecomment-465379008",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/18055",
    "id": 465379008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTM3OTAwOA==",
    "user": {
      "login": "lidizheng",
      "id": 7394928,
      "node_id": "MDQ6VXNlcjczOTQ5Mjg=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/7394928?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lidizheng",
      "html_url": "https://github.com/lidizheng",
      "followers_url": "https://api.github.com/users/lidizheng/followers",
      "following_url": "https://api.github.com/users/lidizheng/following{/other_user}",
      "gists_url": "https://api.github.com/users/lidizheng/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lidizheng/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lidizheng/subscriptions",
      "organizations_url": "https://api.github.com/users/lidizheng/orgs",
      "repos_url": "https://api.github.com/users/lidizheng/repos",
      "events_url": "https://api.github.com/users/lidizheng/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lidizheng/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T01:17:21Z",
    "updated_at": "2019-02-20T01:17:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "@yiakwy Can you post this question to our Google Group [grpc-io](https://groups.google.com/forum/#!forum/grpc-io)? You may get more attention there, and the GitHub issues are not meant for questions."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/465434859",
    "html_url": "https://github.com/grpc/grpc/issues/18055#issuecomment-465434859",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/18055",
    "id": 465434859,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTQzNDg1OQ==",
    "user": {
      "login": "yiakwy",
      "id": 8510840,
      "node_id": "MDQ6VXNlcjg1MTA4NDA=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8510840?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yiakwy",
      "html_url": "https://github.com/yiakwy",
      "followers_url": "https://api.github.com/users/yiakwy/followers",
      "following_url": "https://api.github.com/users/yiakwy/following{/other_user}",
      "gists_url": "https://api.github.com/users/yiakwy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yiakwy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yiakwy/subscriptions",
      "organizations_url": "https://api.github.com/users/yiakwy/orgs",
      "repos_url": "https://api.github.com/users/yiakwy/repos",
      "events_url": "https://api.github.com/users/yiakwy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yiakwy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T05:51:01Z",
    "updated_at": "2019-02-20T05:51:01Z",
    "author_association": "NONE",
    "body": "@lidizheng Got it. I think have already solved the problem and now I am stuck in async grpc cpp server threading models. I am confused about how to write threads and manage them with our completion queue. \r\n\r\nFrom https://github.com/grpc/grpc/blob/master/test/cpp/qps/server_async.cc, I found that each thread handles a different CallData instance (a ServerRpcContext instance, similar to a CallData instance in grpc c++ demo) and a completion queue.\r\n\r\nMay I know differences and how to implement the following models ?\r\n1 Compleiton Queue - 1 Thread\r\n1 Completion Queue - Many Threads\r\nMany Completion Queue - Many Threads"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/465694202",
    "html_url": "https://github.com/grpc/grpc/issues/18055#issuecomment-465694202",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/18055",
    "id": 465694202,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTY5NDIwMg==",
    "user": {
      "login": "yang-g",
      "id": 10122250,
      "node_id": "MDQ6VXNlcjEwMTIyMjUw",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10122250?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yang-g",
      "html_url": "https://github.com/yang-g",
      "followers_url": "https://api.github.com/users/yang-g/followers",
      "following_url": "https://api.github.com/users/yang-g/following{/other_user}",
      "gists_url": "https://api.github.com/users/yang-g/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yang-g/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yang-g/subscriptions",
      "organizations_url": "https://api.github.com/users/yang-g/orgs",
      "repos_url": "https://api.github.com/users/yang-g/repos",
      "events_url": "https://api.github.com/users/yang-g/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yang-g/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-20T18:16:13Z",
    "updated_at": "2019-02-20T18:16:13Z",
    "author_association": "MEMBER",
    "body": "@yiakwy \r\nThe c++ async server is not trivial to write and all the 3 threading models are possible and may suit different traffic patterns and work loads. But unless you are very performance-sensitive, you can use a single completion queue with a bunch of threads all calling Next on it.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/465879224",
    "html_url": "https://github.com/grpc/grpc/issues/18055#issuecomment-465879224",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/18055",
    "id": 465879224,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTg3OTIyNA==",
    "user": {
      "login": "yiakwy",
      "id": 8510840,
      "node_id": "MDQ6VXNlcjg1MTA4NDA=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8510840?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yiakwy",
      "html_url": "https://github.com/yiakwy",
      "followers_url": "https://api.github.com/users/yiakwy/followers",
      "following_url": "https://api.github.com/users/yiakwy/following{/other_user}",
      "gists_url": "https://api.github.com/users/yiakwy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yiakwy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yiakwy/subscriptions",
      "organizations_url": "https://api.github.com/users/yiakwy/orgs",
      "repos_url": "https://api.github.com/users/yiakwy/repos",
      "events_url": "https://api.github.com/users/yiakwy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yiakwy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-21T06:32:46Z",
    "updated_at": "2019-03-04T07:31:34Z",
    "author_association": "NONE",
    "body": "Thanks for your comment. Let us  begin to discuss 1 Cq threading models. Suppose we have the following methods\r\n\r\n```\r\nSubscriber {\r\n...\r\n rpc Pull(Identity) return {stream Payload};\r\n}\r\n```\r\n\r\nIn the server side, I tried some schemes.  Which version of threading model do you suggest?\r\n\r\n```c++\r\n    // CPP server side\r\n    // @todo : TODO\r\n    Status Unsubscribe(ServerContext* ctx, const SubRequest* request, SubReply* reply) override {\r\n        \r\n        return Status::OK;\r\n    }\r\n\r\n    Status Pull(ServerContext* ctx, const Identity* identity, ServerWriter<Payload>* writer) override {\r\n        ::registry::Client* client = clientRegistry_->getClient(request->identity());\r\n        if (client == nullptr) {\r\n            stringstream stream;\r\n            stream << \"Error, CLIENT_ID \" << identity->clientid() << \" from <\" ctx->peer( << \"> is already registered!\") << std::endl;\r\n            std::cout << stream.str();\r\n            return Satus(INTERNAL, \"client not registered!\");\r\n        }\r\n        std::cout << \"Pulling subscribed messages to CLIENT_ID \" << identity()->clientid() << \" from <\" << ctx->peer() << \">\" << std::endl;\r\n        \r\n        client->mtx.Lock()\r\n        client->connected = true;\r\n        client->mtx.Unlock()\r\n        \r\n        Payload payload;\r\n        while (client->channel->recv(&payload, wait=\"10s\")) {\r\n            writer.Write(payload);\r\n        }\r\n        \r\n        return Status::OK;\r\n    }\r\n\r\n```\r\n\r\nIn this case the thread which executes Pull handler in async server, will take a long time return to the thread pool.\r\n\r\n```c++\r\n    void HandleRpcs() {\r\n        void* tag;  // uniquely identifies a request.\r\n        bool ok;\r\n        while (true) {\r\n            // Block waiting to read the next event from the completion queue. The\r\n            // event is uniquely identified by its tag, which in this case is the\r\n            // memory address of a CallData instance.\r\n            // The return value of Next should always be checked. This return value\r\n            // tells us whether there is any kind of event or cq_ is shutting down.\r\n            GPR_ASSERT(cq_->Next(&tag, &ok));\r\n            GPR_ASSERT(ok);\r\n            // c++ polymorphism handles different Proceed calls\r\n            // templated class CallData inherits from CallDataBase and implements virtual Proceed() = 0 method\r\n            CallData* ctx = static_cast<CallData*>(tag);\r\n            pool_.enqueue([&, this, ctx] {\r\n                ctx->Proceed();\r\n            });\r\n        }\r\n    }\r\n```\r\n\r\nOr as you suggest make a bunch of threads calling get `Next` like this\r\n\r\n```c++\r\n// run in ServerImpl constructor after a server and the attched completion queue is ready.\r\nvector<std::thread> threads_;\r\n\r\nfor (int i=0; i < num_threads; i++) {\r\nthreads_.emplace_back(&HandleRpcs, this);\r\n}\r\n\r\n\r\n//\r\n    ~SeverImpl () {\r\n       for (auto th = threads_.begin(); th != threads_.end(); th++)\r\n       th->join();\r\n    }\r\n\r\n    void HandleRpcs() {\r\n        void* tag;  // uniquely identifies a request.\r\n        bool ok;\r\n        while (true) {\r\n            // Block waiting to read the next event from the completion queue. The\r\n            // event is uniquely identified by its tag, which in this case is the\r\n            // memory address of a CallData instance.\r\n            // The return value of Next should always be checked. This return value\r\n            // tells us whether there is any kind of event or cq_ is shutting down.\r\n            GPR_ASSERT(cq_->Next(&tag, &ok));\r\n            GPR_ASSERT(ok);\r\n            // c++ polymorphism handles different Proceed calls\r\n            CallData* call = static_cast<CallData*>(tag);\r\n            /*\r\n            pool_.enqueue([&, this, call] {\r\n                call->Proceed();\r\n            });\r\n             */\r\n                call->Proceed();\r\n        }\r\n    }\r\n```\r\n\r\nOr could we have a hybrid threading model scheme?\r\n\r\nWhat thread model do you suggest? Thank you in advance! @AspirinSJL @vjpai "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/465897399",
    "html_url": "https://github.com/grpc/grpc/issues/18055#issuecomment-465897399",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/18055",
    "id": 465897399,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTg5NzM5OQ==",
    "user": {
      "login": "yiakwy",
      "id": 8510840,
      "node_id": "MDQ6VXNlcjg1MTA4NDA=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8510840?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yiakwy",
      "html_url": "https://github.com/yiakwy",
      "followers_url": "https://api.github.com/users/yiakwy/followers",
      "following_url": "https://api.github.com/users/yiakwy/following{/other_user}",
      "gists_url": "https://api.github.com/users/yiakwy/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yiakwy/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yiakwy/subscriptions",
      "organizations_url": "https://api.github.com/users/yiakwy/orgs",
      "repos_url": "https://api.github.com/users/yiakwy/repos",
      "events_url": "https://api.github.com/users/yiakwy/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yiakwy/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-21T07:51:55Z",
    "updated_at": "2019-02-21T09:16:23Z",
    "author_association": "NONE",
    "body": "@yang-g I am not sure whether I am sensitive to the performance. I developed it as a baseline system to be integrated my services developed in c++ and Python respectively. Hence I want it to be robust so that I do not need to always keep an eye upon it. "
  }
]
