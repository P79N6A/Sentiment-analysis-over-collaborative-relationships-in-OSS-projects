[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/169215186",
    "html_url": "https://github.com/grpc/grpc/issues/4628#issuecomment-169215186",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4628",
    "id": 169215186,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTIxNTE4Ng==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-06T04:06:31Z",
    "updated_at": "2016-01-06T04:06:31Z",
    "author_association": "NONE",
    "body": "the result in PerformOpsOnCall is 'GRPC_CALL_ERROR_TOO_MANY_OPERATIONS'\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/169223694",
    "html_url": "https://github.com/grpc/grpc/issues/4628#issuecomment-169223694",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4628",
    "id": 169223694,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTIyMzY5NA==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-06T05:04:03Z",
    "updated_at": "2016-01-06T05:17:51Z",
    "author_association": "NONE",
    "body": "I try send one msg, the size is 65536*1.5 bytes, and it is ok(the client recieve it)\nBut with a msg size more than 65536, only after 1-3 msg sended it will be dump.\nIn normal case, the dump is often after thousands sending calls.\nAnd I also find that, when the msg was send more frequently, it will have more chance to dump.\ne.g. If i insert a 'printf' among each send call, the dump chance will reduce.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/169251524",
    "html_url": "https://github.com/grpc/grpc/issues/4628#issuecomment-169251524",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4628",
    "id": 169251524,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTI1MTUyNA==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-06T06:54:10Z",
    "updated_at": "2016-01-06T06:54:10Z",
    "author_association": "NONE",
    "body": "the error GRPC_CALL_ERROR_TOO_MANY_OPERATIONS' is due to here:\ncall.c: static grpc_call_error call_start_batch(grpc_exec_ctx *exec_ctx,\n...\n  if (call->sending_message) {\n          error = GRPC_CALL_ERROR_TOO_MANY_OPERATIONS;\n          goto done_with_error;\n        }\n\nand after debug the procedure,I find that, \nin normal cast:\n'call_start_batch' will set the call->sending_message\nand 'finish_batch' will reset it.\n\nbut in the wrong case:\nfinish_batch was not been called before the next 'call_start_batch'\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/169357969",
    "html_url": "https://github.com/grpc/grpc/issues/4628#issuecomment-169357969",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4628",
    "id": 169357969,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2OTM1Nzk2OQ==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-06T15:29:58Z",
    "updated_at": "2016-01-06T15:29:58Z",
    "author_association": "MEMBER",
    "body": "So I suspect you're breaking a contract (which should admittedly be spelled out a little more clearly) with the async API.\n\nYou're only allowed to have one write outstanding on a stream at a time, and must receive the completion tag for that write from the completion queue BEFORE issuing the next write.\n\nThe detection logic you're seeing can only sometimes detect this usage error (doing so all the time would be prohibitively expensive performance wise).\n\nI'll take an AI to update the documentation in stream.h to cover this.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/171275662",
    "html_url": "https://github.com/grpc/grpc/issues/4628#issuecomment-171275662",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4628",
    "id": 171275662,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTI3NTY2Mg==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-13T12:22:42Z",
    "updated_at": "2016-01-13T12:22:42Z",
    "author_association": "NONE",
    "body": "If I add the code below after each 'Write', it will not crash any more, but result in a low 'SendRpc' efficiency. The client will get a the list which send from the server very slowly by this way.\n\n```\ngrpc::CompletionQueue::NextStatus ns = cq_->AsyncNext(&tag, &ok,gpr_inf_future(GPR_CLOCK_PRECISE))\n```\n\nBefore,I use the 'gpr_inf_past'  as the wait param, in most case it was quickly but sometime crashed.\nthe code is:\n\n```\nwhile (true){\n    grpc::CompletionQueue::NextStatus ns = cq_->AsyncNext(&tag, &ok, gpr_inf_past(GPR_CLOCK_PRECISE));\n    if (ns != grpc::CompletionQueue::NextStatus::GOT_EVENT){\n        break;\n    }\n    if (tag != nullptr)\n    {\n        static_cast<IFlowRPC*>(tag)->OnNotify();\n    }\n}\n```\n\nIs there something error with my usage? or what I can do to improve this situation?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/171540192",
    "html_url": "https://github.com/grpc/grpc/issues/4628#issuecomment-171540192",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4628",
    "id": 171540192,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3MTU0MDE5Mg==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-14T06:06:10Z",
    "updated_at": "2016-01-14T06:06:10Z",
    "author_association": "NONE",
    "body": "Now I work around by changing from send a list rpc with stream to just one rpc with repeated field.\n"
  }
]
