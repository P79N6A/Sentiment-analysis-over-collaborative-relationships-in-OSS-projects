[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/359893180",
    "html_url": "https://github.com/grpc/grpc/issues/14043#issuecomment-359893180",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14043",
    "id": 359893180,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTg5MzE4MA==",
    "user": {
      "login": "apolcyn",
      "id": 9566254,
      "node_id": "MDQ6VXNlcjk1NjYyNTQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9566254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolcyn",
      "html_url": "https://github.com/apolcyn",
      "followers_url": "https://api.github.com/users/apolcyn/followers",
      "following_url": "https://api.github.com/users/apolcyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolcyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolcyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolcyn/subscriptions",
      "organizations_url": "https://api.github.com/users/apolcyn/orgs",
      "repos_url": "https://api.github.com/users/apolcyn/repos",
      "events_url": "https://api.github.com/users/apolcyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolcyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-23T18:56:23Z",
    "updated_at": "2018-01-23T18:56:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "Unfortunately I think this needs a tweak to application-level code to work. \r\nFor example, the [greeter_server.rb](https://github.com/grpc/grpc/blob/master/examples/ruby/greeter_server.rb) should handle SIGINT gracefully after this tweak:\r\n\r\n```\r\n# GreeterServer is simple server that implements the Helloworld Greeter server.\r\nclass GreeterServer < Helloworld::Greeter::Service\r\n  # say_hello implements the SayHello rpc method.\r\n  def say_hello(hello_req, _unused_call)\r\n    Helloworld::HelloReply.new(message: \"Hello #{hello_req.name}\")\r\n  end\r\nend\r\n\r\n# main starts an RpcServer that receives requests to GreeterServer at the sample\r\n# server port.\r\ndef main\r\n  Thread.abort_on_exception = true\r\n  s = GRPC::RpcServer.new\r\n  stop_server = false\r\n  stop_server_cv = ConditionVariable.new\r\n  stop_server_mu = Mutex.new\r\n  stop_server_thread = Thread.new do\r\n    loop do\r\n      break if stop_server\r\n      stop_server_mu.synchronize { stop_server_cv.wait(stop_server_mu, 60) }\r\n    end\r\n    s.stop\r\n  end\r\n  trap('INT') do\r\n    stop_server = true\r\n    stop_server_cv.broadcast\r\n  end\r\n  s.add_http2_port('0.0.0.0:50051', :this_port_is_insecure)\r\n  s.handle(GreeterServer)\r\n  s.run_till_terminated\r\n  stop_server_thread.join\r\nend\r\n\r\nmain\r\n```\r\n\r\nIf the server process needs to exit gracefully upon a SIGINT, then I think there needs to be some application-level handling of the `SIGINT` signal. The grpc-ruby server has never installed signal handlers itself, and I think it should continue not to do so... I'm afraid that graceful termination upon SIGINT is something that just <i>happened</i> to work in earlier releases."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/360965896",
    "html_url": "https://github.com/grpc/grpc/issues/14043#issuecomment-360965896",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14043",
    "id": 360965896,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MDk2NTg5Ng==",
    "user": {
      "login": "rurounijones",
      "id": 21911,
      "node_id": "MDQ6VXNlcjIxOTEx",
      "avatar_url": "https://avatars0.githubusercontent.com/u/21911?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rurounijones",
      "html_url": "https://github.com/rurounijones",
      "followers_url": "https://api.github.com/users/rurounijones/followers",
      "following_url": "https://api.github.com/users/rurounijones/following{/other_user}",
      "gists_url": "https://api.github.com/users/rurounijones/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rurounijones/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rurounijones/subscriptions",
      "organizations_url": "https://api.github.com/users/rurounijones/orgs",
      "repos_url": "https://api.github.com/users/rurounijones/repos",
      "events_url": "https://api.github.com/users/rurounijones/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rurounijones/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-27T07:06:50Z",
    "updated_at": "2018-01-27T07:41:36Z",
    "author_association": "NONE",
    "body": "[EDIT - I missed the reference to other issues so this may already have been fixed and just needs merging. My entire comment below has therefore probably been rendered obsolete. Apologies for the confusion]\r\n\r\nAhoi apolcyn. Thanks for looking into this.\r\n\r\nI agree completely that it is not the GRPC server's responsibility to trap the sigint itself and that that should be handled by the application.\r\n\r\nThe example you showed above seems like a lot of boilerplate to ask application writers to have to write (Although I confirmed that it does work) and it seems like it should be the responsibility of the server itself.\r\n\r\nIt seems to me that the .stop method should be the only thing the client should have to worry about. So \r\n\r\n```\r\ntrap('INT') do\r\n  s.stop\r\nend\r\ns.run_till_terminated\r\n\r\n```\r\n\r\nand\r\n\r\n```\r\nbegin\r\n  s.run_till_terminated\r\nrescue SystemExit, Interrupt\r\n  s.stop\r\nend\r\n```\r\n\r\nWould work. Both still currently throw ```E0127 15:57:48.329747416   30611 completion_queue.cc:510] assertion failed: cqd->completed_head.next == (uintptr_t)&cqd->completed_head```\r\n\r\nI think the server should not trap the signals but should be responsible for performing its own shutdown so I would say we should move your above code into the ```run_till_terminated``` (To setup and start the loop) and ```.stop``` (To do the synch + stop as your code does) methods so that clients only have to do what I wrote above.\r\n\r\nDoes that sound reasonable?\r\n\r\n[EDIT] So I looked at the rpc_server.rb code itself and there is already a lot of this stuff in it, I just guess it isn't working in its current state."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/362652642",
    "html_url": "https://github.com/grpc/grpc/issues/14043#issuecomment-362652642",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14043",
    "id": 362652642,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjY1MjY0Mg==",
    "user": {
      "login": "dgquintas",
      "id": 120217,
      "node_id": "MDQ6VXNlcjEyMDIxNw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/120217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dgquintas",
      "html_url": "https://github.com/dgquintas",
      "followers_url": "https://api.github.com/users/dgquintas/followers",
      "following_url": "https://api.github.com/users/dgquintas/following{/other_user}",
      "gists_url": "https://api.github.com/users/dgquintas/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dgquintas/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dgquintas/subscriptions",
      "organizations_url": "https://api.github.com/users/dgquintas/orgs",
      "repos_url": "https://api.github.com/users/dgquintas/repos",
      "events_url": "https://api.github.com/users/dgquintas/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dgquintas/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-02T17:37:27Z",
    "updated_at": "2018-02-02T17:37:27Z",
    "author_association": "NONE",
    "body": "I've just notice this issue as part of a PR's tests: https://sponge.corp.google.com/target?id=3378d5d3-55e0-43a7-9c03-170207fb4a73&target=github/grpc/ruby_linux_opt_native&searchFor=&show=FAILED&sortBy=STATUS\r\n\r\nApologies for the internal link (those will be publicly available soon). Reproduced below:\r\n```\r\nFinished in 1.25 seconds (files took 0.25149 seconds to load)\r\n171 examples, 0 failures\r\n\r\nCoverage report generated for wrapper to /var/local/git/grpc/coverage. 919 / 1066 LOC (86.21%) covered.\r\nE0202 00:44:46.536623159   10603 backup_poller.cc:108]       run_poller: {\"created\":\"@1517532286.536593314\",\"description\":\"Timer list shutdown\",\"file\":\"src/core/lib/iomgr/timer_generic.cc\",\"file_line\":273}\r\n/usr/local/rvm/rubies/ruby-2.1.10/bin/ruby -I/usr/local/rvm/gems/ruby-2.1.10/gems/rspec-core-3.7.1/lib:/usr/local/rvm/gems/ruby-2.1.10/gems/rspec-support-3.7.1/lib /usr/local/rvm/gems/ruby-2.1.10/gems/rspec-core-3.7.1/exe/rspec src/ruby/spec/generic/active_call_spec.rb src/ruby/spec/generic/client_interceptors_spec.rb src/ruby/spec/generic/client_stub_spec.rb src/ruby/spec/generic/interceptor_registry_spec.rb src/ruby/spec/generic/rpc_desc_spec.rb src/ruby/spec/generic/rpc_server_pool_spec.rb src/ruby/spec/generic/rpc_server_spec.rb src/ruby/spec/generic/server_interceptors_spec.rb src/ruby/spec/generic/service_spec.rb src/ruby/spec/spec_helper.rb --tag ~bidi --tag ~server\r\nRun options: exclude {:bidi=>true, :server=>true}\r\n\r\nGRPC::ActiveCall\r\n  restricted view methods\r\n    #multi_req_view\r\n      exposes a fixed subset of the ActiveCall.methods\r\n    #single_req_view\r\n      exposes a fixed subset of the ActiveCall.methods\r\n    #interceptable\r\n      exposes a fixed subset of the ActiveCall.methods\r\n  #remote_send\r\n    allows a client to send a payload to the server\r\n    marshals the payload using the marshal func\r\n    successfully makes calls with write_flag set to 1\r\n    successfully makes calls with write_flag set to 2\r\n  sending initial metadata\r\n    sends metadata before sending a message if it hasnt been sent yet\r\n    doesnt send metadata if it thinks its already been sent\r\n    sends metadata if it is explicitly sent and ok to do so\r\n    explicit sending does nothing if metadata has already been sent\r\n  #merge_metadata_to_send\r\n    adds to existing metadata when there is existing metadata to send\r\n    fails when initial metadata has already been sent\r\n  #client_invoke\r\n    sends metadata to the server when present\r\n  #send_status\r\n    works when no metadata or messages have been sent yet\r\n  #remote_read\r\n    reads the response sent by a server\r\n    saves no metadata when the server adds no metadata\r\n    saves metadata add by the server\r\n    get a status from server when nothing else sent from server\r\n    get a nil msg before a status when an OK status is sent\r\n    unmarshals the response using the unmarshal func\r\n  #each_remote_read\r\n    creates an Enumerator\r\n    the returned enumerator can read n responses\r\n    the returns an enumerator that stops after an OK Status\r\n  #closing the call from the client\r\n    finishes ok if the server sends a status response\r\n    finishes ok if the server sends an early status response\r\n    finishes ok if SEND_CLOSE and RECV_STATUS has been sent\r\n  #run_server_bidi metadata sending tests\r\n    sends the initial metadata implicitly if not already sent\r\n    sends the metadata when sent explicitly and not already sent\r\n\r\nClientStub\r\n  #new\r\n    can be created from a host and args\r\n    can be created with an channel override\r\n    cannot be created with a bad channel override\r\n    cannot be created with bad credentials\r\n    can be created with test test credentials\r\n  #request_response\r\n    without a call operation\r\n      behaves like request response\r\nnil\r\n        should send a request to/receive a reply from a server\r\nnil\r\n        should send metadata to the server ok\r\nnil\r\n        should send metadata with multiple large md to the server ok\r\nnil\r\n        should send a request when configured using an override channel\r\nnil\r\n        should raise an error if the status is not OK\r\n#<GRPC::Core::CallCredentials:0x00000002f2e318>\r\nE0202 00:44:47.583886861   10835 client_auth_filter.cc:133]  No '/' found in fully qualified method name\r\nE0202 00:44:47.585127119   10830 completion_queue.cc:487]    assertion failed: cqd->completed_head.next == (uintptr_t)&cqd->completed_head\r\nAborted (core dumped)\r\n/usr/local/rvm/rubies/ruby-2.1.10/bin/ruby -I/usr/local/rvm/gems/ruby-2.1.10/gems/rspec-core-3.7.1/lib:/usr/local/rvm/gems/ruby-2.1.10/gems/rspec-support-3.7.1/lib /usr/local/rvm/gems/ruby-2.1.10/gems/rspec-core-3.7.1/exe/rspec src/ruby/spec/generic/active_call_spec.rb src/ruby/spec/generic/client_interceptors_spec.rb src/ruby/spec/generic/client_stub_spec.rb src/ruby/spec/generic/interceptor_registry_spec.rb src/ruby/spec/generic/rpc_desc_spec.rb src/ruby/spec/generic/rpc_server_pool_spec.rb src/ruby/spec/generic/rpc_server_spec.rb src/ruby/spec/generic/server_interceptors_spec.rb src/ruby/spec/generic/service_spec.rb src/ruby/spec/spec_helper.rb --tag ~bidi --tag ~server failed\r\n\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/362760596",
    "html_url": "https://github.com/grpc/grpc/issues/14043#issuecomment-362760596",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14043",
    "id": 362760596,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2Mjc2MDU5Ng==",
    "user": {
      "login": "apolcyn",
      "id": 9566254,
      "node_id": "MDQ6VXNlcjk1NjYyNTQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9566254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolcyn",
      "html_url": "https://github.com/apolcyn",
      "followers_url": "https://api.github.com/users/apolcyn/followers",
      "following_url": "https://api.github.com/users/apolcyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolcyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolcyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolcyn/subscriptions",
      "organizations_url": "https://api.github.com/users/apolcyn/orgs",
      "repos_url": "https://api.github.com/users/apolcyn/repos",
      "events_url": "https://api.github.com/users/apolcyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolcyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-03T01:27:19Z",
    "updated_at": "2018-02-03T01:27:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "To be clear, the failure shown in that test log above has the same failure but a different cause as the one in the OP of this issue.\r\n\r\n@rurounijones, as to your comments, I agree that my first suggestion is a lot of boiler plate. Perhaps grpc can provide a convenience utility to something along those lines though.\r\n\r\nI can't think of any good way to allow doing:\r\n\r\n```\r\nbegin\r\n  s.run_till_terminated\r\nrescue SystemExit, Interrupt\r\n  s.stop\r\nend\r\n```\r\n\r\n\r\nbut we might be able to provide some wrapper that could look like:\r\n\r\n```\r\n  s = GRPC::RpcServer.new\r\n  s.add_http2_port('0.0.0.0:50051', :this_port_is_insecure)\r\n  s.handle(GreeterServer)\r\n  \r\n  # this method would internally register signal handlers:\r\n  s.run_till_terminated_or_interrupted(.. # pass a list of signals to exit gracefully on).\r\n```\r\n\r\nAny thoughts on that?\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/363440674",
    "html_url": "https://github.com/grpc/grpc/issues/14043#issuecomment-363440674",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14043",
    "id": 363440674,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MzQ0MDY3NA==",
    "user": {
      "login": "rurounijones",
      "id": 21911,
      "node_id": "MDQ6VXNlcjIxOTEx",
      "avatar_url": "https://avatars0.githubusercontent.com/u/21911?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rurounijones",
      "html_url": "https://github.com/rurounijones",
      "followers_url": "https://api.github.com/users/rurounijones/followers",
      "following_url": "https://api.github.com/users/rurounijones/following{/other_user}",
      "gists_url": "https://api.github.com/users/rurounijones/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rurounijones/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rurounijones/subscriptions",
      "organizations_url": "https://api.github.com/users/rurounijones/orgs",
      "repos_url": "https://api.github.com/users/rurounijones/repos",
      "events_url": "https://api.github.com/users/rurounijones/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rurounijones/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-06T14:36:01Z",
    "updated_at": "2018-02-06T14:36:47Z",
    "author_association": "NONE",
    "body": "Ahoi apolcyn.\r\n\r\nI just realised that I screwed up one of my examples. I meant to type:\r\n\r\n     s = GRPC::RpcServer.new\r\n     ...\r\n     begin\r\n       s.start\r\n     rescue SystemExit, Interrupt\r\n       s.stop\r\n    end\r\n\r\nBasically go with your idea of letting the server itself manage its shutdown but have the application be responsible for triggering it. It looks like this is already sorta half-implemented in http://www.rubydoc.info/github/grpc/grpc/7131c62/GRPC/RpcServer but I am not sure about the current status of the code.\r\n\r\nYour suggestion works as well. I am mainly concerned with allow the application to be able to gracefully shutdown other things. e.g.\r\n\r\n     s = GRPC::RpcServer.new\r\n     ...\r\n     begin\r\n       s.start\r\n     rescue SystemExit, Interrupt\r\n       s.stop\r\n       # Code to clean-up database connections, send metrics, notify things etc. etc.\r\n    end\r\n\r\nAlthough \r\n\r\n    s.run_till_terminated_or_interrupted(.. # pass a list of signals to exit gracefully on).\r\n    # Code to clean-up database connections\r\n\r\nwould work as well I think. Just doesn't seem as OO.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/470951500",
    "html_url": "https://github.com/grpc/grpc/issues/14043#issuecomment-470951500",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14043",
    "id": 470951500,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MDk1MTUwMA==",
    "user": {
      "login": "danp",
      "id": 2182,
      "node_id": "MDQ6VXNlcjIxODI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2182?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/danp",
      "html_url": "https://github.com/danp",
      "followers_url": "https://api.github.com/users/danp/followers",
      "following_url": "https://api.github.com/users/danp/following{/other_user}",
      "gists_url": "https://api.github.com/users/danp/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/danp/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/danp/subscriptions",
      "organizations_url": "https://api.github.com/users/danp/orgs",
      "repos_url": "https://api.github.com/users/danp/repos",
      "events_url": "https://api.github.com/users/danp/events{/privacy}",
      "received_events_url": "https://api.github.com/users/danp/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-08T14:43:03Z",
    "updated_at": "2019-03-08T14:43:03Z",
    "author_association": "NONE",
    "body": "Can this be closed with https://github.com/grpc/grpc/pull/17348 merged and released some time ago?"
  }
]
