[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/327420568",
    "html_url": "https://github.com/grpc/grpc/issues/10569#issuecomment-327420568",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/10569",
    "id": 327420568,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyNzQyMDU2OA==",
    "user": {
      "login": "robertwpowell",
      "id": 11850899,
      "node_id": "MDQ6VXNlcjExODUwODk5",
      "avatar_url": "https://avatars2.githubusercontent.com/u/11850899?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/robertwpowell",
      "html_url": "https://github.com/robertwpowell",
      "followers_url": "https://api.github.com/users/robertwpowell/followers",
      "following_url": "https://api.github.com/users/robertwpowell/following{/other_user}",
      "gists_url": "https://api.github.com/users/robertwpowell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/robertwpowell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/robertwpowell/subscriptions",
      "organizations_url": "https://api.github.com/users/robertwpowell/orgs",
      "repos_url": "https://api.github.com/users/robertwpowell/repos",
      "events_url": "https://api.github.com/users/robertwpowell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/robertwpowell/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-06T08:57:08Z",
    "updated_at": "2017-09-06T08:57:08Z",
    "author_association": "NONE",
    "body": "Have you tried client.getChannel().getConnectivityState(true); \r\ngetChannel() is the accessor for getting channel. I'm inspecting it when waitforReady times out to see the connection state "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/389349601",
    "html_url": "https://github.com/grpc/grpc/issues/10569#issuecomment-389349601",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/10569",
    "id": 389349601,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTM0OTYwMQ==",
    "user": {
      "login": "murgatroid99",
      "id": 961599,
      "node_id": "MDQ6VXNlcjk2MTU5OQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/961599?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murgatroid99",
      "html_url": "https://github.com/murgatroid99",
      "followers_url": "https://api.github.com/users/murgatroid99/followers",
      "following_url": "https://api.github.com/users/murgatroid99/following{/other_user}",
      "gists_url": "https://api.github.com/users/murgatroid99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murgatroid99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murgatroid99/subscriptions",
      "organizations_url": "https://api.github.com/users/murgatroid99/orgs",
      "repos_url": "https://api.github.com/users/murgatroid99/repos",
      "events_url": "https://api.github.com/users/murgatroid99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murgatroid99/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-15T23:47:53Z",
    "updated_at": "2018-05-15T23:47:53Z",
    "author_association": "MEMBER",
    "body": "Can you explain why you you are trying to check the connectivity state? Normally, handling disconnections and reconnecting are handled by the gRPC internals. Are you having a connectivity issue that isn't being handled properly?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/389422674",
    "html_url": "https://github.com/grpc/grpc/issues/10569#issuecomment-389422674",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/10569",
    "id": 389422674,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTQyMjY3NA==",
    "user": {
      "login": "robertwpowell",
      "id": 11850899,
      "node_id": "MDQ6VXNlcjExODUwODk5",
      "avatar_url": "https://avatars2.githubusercontent.com/u/11850899?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/robertwpowell",
      "html_url": "https://github.com/robertwpowell",
      "followers_url": "https://api.github.com/users/robertwpowell/followers",
      "following_url": "https://api.github.com/users/robertwpowell/following{/other_user}",
      "gists_url": "https://api.github.com/users/robertwpowell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/robertwpowell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/robertwpowell/subscriptions",
      "organizations_url": "https://api.github.com/users/robertwpowell/orgs",
      "repos_url": "https://api.github.com/users/robertwpowell/repos",
      "events_url": "https://api.github.com/users/robertwpowell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/robertwpowell/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T07:29:27Z",
    "updated_at": "2018-05-16T07:29:27Z",
    "author_association": "NONE",
    "body": "I'm checking the connectivity state of service A for a heartbeat service that provides the state of service A so that clients will know if they should continue to call the service or its truly down and to stop calling the service and disable the feature/s that the service supports. "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/389599361",
    "html_url": "https://github.com/grpc/grpc/issues/10569#issuecomment-389599361",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/10569",
    "id": 389599361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4OTU5OTM2MQ==",
    "user": {
      "login": "murgatroid99",
      "id": 961599,
      "node_id": "MDQ6VXNlcjk2MTU5OQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/961599?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/murgatroid99",
      "html_url": "https://github.com/murgatroid99",
      "followers_url": "https://api.github.com/users/murgatroid99/followers",
      "following_url": "https://api.github.com/users/murgatroid99/following{/other_user}",
      "gists_url": "https://api.github.com/users/murgatroid99/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/murgatroid99/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/murgatroid99/subscriptions",
      "organizations_url": "https://api.github.com/users/murgatroid99/orgs",
      "repos_url": "https://api.github.com/users/murgatroid99/repos",
      "events_url": "https://api.github.com/users/murgatroid99/events{/privacy}",
      "received_events_url": "https://api.github.com/users/murgatroid99/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-16T17:23:19Z",
    "updated_at": "2018-05-16T17:23:19Z",
    "author_association": "MEMBER",
    "body": "I think the connectivity state list doesn't map cleanly to what you're trying to do. I believe that the current state machine does not actually ever enter the `FATAL_FAILURE` state, and the `TRANSIENT_FAILURE` state is exactly that, transient. Specifically, `TRANSIENT_FAILURE` means that the channel is just waiting for a timeout before transitioning to `CONNECTING`. The gRPC channel never treats a connection as permanently broken.\r\n\r\nI would suggest that a more effective strategy would be to simply use the service's methods with a deadline, and if those requests start failing, treat the service as unavailable and try making new requests in the background until they start succeeding again. Alternatively, you could define a heartbeat method on the service that is a stream in both directions. You could send messages and check the responses to verify that the connection is alive, and in most cases the stream should end with an error if that connection breaks."
  }
]
