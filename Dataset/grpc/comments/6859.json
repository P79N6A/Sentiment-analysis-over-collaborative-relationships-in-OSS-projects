[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/225902952",
    "html_url": "https://github.com/grpc/grpc/issues/6859#issuecomment-225902952",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/6859",
    "id": 225902952,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNTkwMjk1Mg==",
    "user": {
      "login": "larsonmpdx",
      "id": 12436438,
      "node_id": "MDQ6VXNlcjEyNDM2NDM4",
      "avatar_url": "https://avatars2.githubusercontent.com/u/12436438?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/larsonmpdx",
      "html_url": "https://github.com/larsonmpdx",
      "followers_url": "https://api.github.com/users/larsonmpdx/followers",
      "following_url": "https://api.github.com/users/larsonmpdx/following{/other_user}",
      "gists_url": "https://api.github.com/users/larsonmpdx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/larsonmpdx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/larsonmpdx/subscriptions",
      "organizations_url": "https://api.github.com/users/larsonmpdx/orgs",
      "repos_url": "https://api.github.com/users/larsonmpdx/repos",
      "events_url": "https://api.github.com/users/larsonmpdx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/larsonmpdx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-14T14:39:47Z",
    "updated_at": "2016-06-14T14:39:47Z",
    "author_association": "NONE",
    "body": "setting fast_fail=false makes this work as expected (see #6730)\n\nthe odd thing is that during a streaming RPC, with fast_fail=true (default now), a non-ssl RPC will fail at the first attempt and then spin with \"timeout occurred\" without trying to connect again (run route_guide_client with no server, then turn on the server after it's into ListFeatures() to see this).  But an SSL version of the same RPC will somehow continue tickling the server with each \"timeout occurred\" event, but never connect.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/227475925",
    "html_url": "https://github.com/grpc/grpc/issues/6859#issuecomment-227475925",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/6859",
    "id": 227475925,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzQ3NTkyNQ==",
    "user": {
      "login": "larsonmpdx",
      "id": 12436438,
      "node_id": "MDQ6VXNlcjEyNDM2NDM4",
      "avatar_url": "https://avatars2.githubusercontent.com/u/12436438?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/larsonmpdx",
      "html_url": "https://github.com/larsonmpdx",
      "followers_url": "https://api.github.com/users/larsonmpdx/followers",
      "following_url": "https://api.github.com/users/larsonmpdx/following{/other_user}",
      "gists_url": "https://api.github.com/users/larsonmpdx/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/larsonmpdx/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/larsonmpdx/subscriptions",
      "organizations_url": "https://api.github.com/users/larsonmpdx/orgs",
      "repos_url": "https://api.github.com/users/larsonmpdx/repos",
      "events_url": "https://api.github.com/users/larsonmpdx/events{/privacy}",
      "received_events_url": "https://api.github.com/users/larsonmpdx/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-21T15:25:12Z",
    "updated_at": "2016-06-21T15:26:38Z",
    "author_association": "NONE",
    "body": "my thoughts so far are:\n- fail_fast=true with a sync streaming RPC in c++ is pretty confusing, since the stream isn't cancelled, but is in a broken state that will never connect after the first fail_fast-triggering event\n- I'm currently doing my own heartbeat-type timeout on streams (N seconds without packets received gets the stream cancelled, but stream duration is indefinite).  That's what eventually catches this with fail_fast=on.  I'd love to see grpc support for this because (at least in c++) the required code is pretty ugly\n- the fact that the SSL stuff continues to send packets after the fail_fast bits have decided to give up is annoying for troubleshooting/ maybe inconsistent, but it's basically still working\n"
  }
]
