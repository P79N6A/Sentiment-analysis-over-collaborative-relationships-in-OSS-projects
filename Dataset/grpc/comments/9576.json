[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/277251041",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-277251041",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 277251041,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3NzI1MTA0MQ==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-03T13:51:47Z",
    "updated_at": "2017-02-03T13:51:47Z",
    "author_association": "MEMBER",
    "body": "Which language are you asking for?\n\nOn Fri, Feb 3, 2017, 12:53 AM HJ <notifications@github.com> wrote:\n\n> I wonder if there is a way to add before and after request handler\n> functions? For instance, automatically log request info of each RPC instead\n> of repeatedly logging in callbacks.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/grpc/grpc/issues/9576>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AJpudXxbq7vYn4kMMQgCfjKWIkWMEpoFks5rYusNgaJpZM4L2Fm8>\n> .\n>\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278178215",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-278178215",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 278178215,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODE3ODIxNQ==",
    "user": {
      "login": "nathanielmanistaatgoogle",
      "id": 10131044,
      "node_id": "MDQ6VXNlcjEwMTMxMDQ0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10131044?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nathanielmanistaatgoogle",
      "html_url": "https://github.com/nathanielmanistaatgoogle",
      "followers_url": "https://api.github.com/users/nathanielmanistaatgoogle/followers",
      "following_url": "https://api.github.com/users/nathanielmanistaatgoogle/following{/other_user}",
      "gists_url": "https://api.github.com/users/nathanielmanistaatgoogle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nathanielmanistaatgoogle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nathanielmanistaatgoogle/subscriptions",
      "organizations_url": "https://api.github.com/users/nathanielmanistaatgoogle/orgs",
      "repos_url": "https://api.github.com/users/nathanielmanistaatgoogle/repos",
      "events_url": "https://api.github.com/users/nathanielmanistaatgoogle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nathanielmanistaatgoogle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-07T23:26:03Z",
    "updated_at": "2017-02-07T23:26:03Z",
    "author_association": "MEMBER",
    "body": "There's not currently a generic mechanism for running code on every RPC. With the API in its current shape, I would recommend implementing the `grpc.Channel` interface with a proxy object that does the logging you want before invoking the RPC on a \"real\" channel. Would that be sufficient for your case?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278385289",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-278385289",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 278385289,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODM4NTI4OQ==",
    "user": {
      "login": "Hujun",
      "id": 835329,
      "node_id": "MDQ6VXNlcjgzNTMyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/835329?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Hujun",
      "html_url": "https://github.com/Hujun",
      "followers_url": "https://api.github.com/users/Hujun/followers",
      "following_url": "https://api.github.com/users/Hujun/following{/other_user}",
      "gists_url": "https://api.github.com/users/Hujun/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Hujun/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Hujun/subscriptions",
      "organizations_url": "https://api.github.com/users/Hujun/orgs",
      "repos_url": "https://api.github.com/users/Hujun/repos",
      "events_url": "https://api.github.com/users/Hujun/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Hujun/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-08T16:47:32Z",
    "updated_at": "2017-02-08T16:49:38Z",
    "author_association": "NONE",
    "body": "I'm doing class decorator as:\r\n\r\n```Python\r\ndef request_wrapper(func):\r\n    def deco(*args, **kwargs):\r\n        # Before request handlers\r\n        print('Before request')\r\n\r\n        rtn = func(*args, **kwargs)\r\n        \r\n        # After request handlers\r\n        print('After request')\r\n\r\n        return rtn\r\n    return deco\r\n\r\n\r\ndef GrpcServerWrapper(cls):\r\n    class ClassWrapper(object):\r\n        def __init__(self, *args, **kwargs):\r\n            self.instance = cls(*args, **kwargs)\r\n\r\n        def __getattribute__(self, k):\r\n            try:\r\n                v = super(ClassWrapper, self).__getattribute__(k)\r\n            except AttributeError:\r\n                pass\r\n            else:\r\n                return v\r\n            v = self.instance.__getattribute__(k)\r\n            if type(v) == type(self.__init__):\r\n                return request_wrapper(v)\r\n            else:\r\n                return v\r\n    return ClassWrapper\r\n\r\n@GrpcServerWrapper\r\nclass Foo(foo_server_pb2.FooServer):\r\n\r\n    def Ping(self, req, ctx):\r\n         .....\r\n \r\n\r\n```\r\n\r\nFrom my view, it would be more elegant if a similar request wrapper could be automatically set in server class when python stub is generated. \r\n\r\nnot really understand the grpc.Channel proxy solution mentioned. Could you please give more details?\r\n\r\n "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278415785",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-278415785",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 278415785,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODQxNTc4NQ==",
    "user": {
      "login": "nathanielmanistaatgoogle",
      "id": 10131044,
      "node_id": "MDQ6VXNlcjEwMTMxMDQ0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10131044?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nathanielmanistaatgoogle",
      "html_url": "https://github.com/nathanielmanistaatgoogle",
      "followers_url": "https://api.github.com/users/nathanielmanistaatgoogle/followers",
      "following_url": "https://api.github.com/users/nathanielmanistaatgoogle/following{/other_user}",
      "gists_url": "https://api.github.com/users/nathanielmanistaatgoogle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nathanielmanistaatgoogle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nathanielmanistaatgoogle/subscriptions",
      "organizations_url": "https://api.github.com/users/nathanielmanistaatgoogle/orgs",
      "repos_url": "https://api.github.com/users/nathanielmanistaatgoogle/repos",
      "events_url": "https://api.github.com/users/nathanielmanistaatgoogle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nathanielmanistaatgoogle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-08T18:19:58Z",
    "updated_at": "2017-02-08T18:19:58Z",
    "author_association": "MEMBER",
    "body": "Oh, so you're looking for this mechanism server-side?\r\n\r\nIn that case you may want to look at how your generated code constructs a `grpc.ServiceRpcHandler` and passes that to your `grpc.Server`. The best thing to do would be for you to implement a `grpc.ServiceRpcHandler` (or `grpc.GenericRpcHandler`) that delegates to the `grpc.ServiceRpcHandler` constructed by the generated code (and that object delegates to your `Servicer` implementation for ultimate service of RPCs); the problem is that we didn't really leave open the right insertion point for that to easily be done (the function is called `add_<your service's name>_servicer_to_server` and it adds your servicer to the passed server as opposed to being called `construct_service_rpc_handler_from_<your service's name>_servicer` and returning to you a `grpc.ServiceRpcHandler` object that you then additionally have to add to your server). To work around that... if you were like me, you'd implement a delegating `grpc.Server` object that when passed a `grpc.GenericRpcHandler` wraps it before passing it to the delegate `grpc.Server`. But there are other ways to go.\r\n\r\nMaybe we should expose a `construct_service_rpc_handler_from_<your service's name>_servicer` function in generated code? It'd be cheap to do and would cover this case very well.\r\n\r\nIncidentally, why use `__getattribute__` rather than `__getattr__`?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/370581102",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-370581102",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 370581102,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDU4MTEwMg==",
    "user": {
      "login": "alertedsnake",
      "id": 753466,
      "node_id": "MDQ6VXNlcjc1MzQ2Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/753466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alertedsnake",
      "html_url": "https://github.com/alertedsnake",
      "followers_url": "https://api.github.com/users/alertedsnake/followers",
      "following_url": "https://api.github.com/users/alertedsnake/following{/other_user}",
      "gists_url": "https://api.github.com/users/alertedsnake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alertedsnake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alertedsnake/subscriptions",
      "organizations_url": "https://api.github.com/users/alertedsnake/orgs",
      "repos_url": "https://api.github.com/users/alertedsnake/repos",
      "events_url": "https://api.github.com/users/alertedsnake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alertedsnake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-05T21:56:28Z",
    "updated_at": "2018-03-05T21:56:28Z",
    "author_association": "NONE",
    "body": "re: `construct_service_rpc_handler_from_<your service's name>_servicer` - is this something that's planned?  The 'adder' function is a bit awkward because of how it restricts things like this, and working around it by using wrapping or delegating objects as you suggest is really awkward."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/371222559",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-371222559",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 371222559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTIyMjU1OQ==",
    "user": {
      "login": "nathanielmanistaatgoogle",
      "id": 10131044,
      "node_id": "MDQ6VXNlcjEwMTMxMDQ0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10131044?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nathanielmanistaatgoogle",
      "html_url": "https://github.com/nathanielmanistaatgoogle",
      "followers_url": "https://api.github.com/users/nathanielmanistaatgoogle/followers",
      "following_url": "https://api.github.com/users/nathanielmanistaatgoogle/following{/other_user}",
      "gists_url": "https://api.github.com/users/nathanielmanistaatgoogle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nathanielmanistaatgoogle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nathanielmanistaatgoogle/subscriptions",
      "organizations_url": "https://api.github.com/users/nathanielmanistaatgoogle/orgs",
      "repos_url": "https://api.github.com/users/nathanielmanistaatgoogle/repos",
      "events_url": "https://api.github.com/users/nathanielmanistaatgoogle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nathanielmanistaatgoogle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T17:47:31Z",
    "updated_at": "2018-03-07T17:47:31Z",
    "author_association": "MEMBER",
    "body": "@alertedsnake: it's not currently planned... and the whole thought of it may be obviated by the recent introduction of interceptors. I'd suggest checking them out."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/371222769",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-371222769",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 371222769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTIyMjc2OQ==",
    "user": {
      "login": "nathanielmanistaatgoogle",
      "id": 10131044,
      "node_id": "MDQ6VXNlcjEwMTMxMDQ0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10131044?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nathanielmanistaatgoogle",
      "html_url": "https://github.com/nathanielmanistaatgoogle",
      "followers_url": "https://api.github.com/users/nathanielmanistaatgoogle/followers",
      "following_url": "https://api.github.com/users/nathanielmanistaatgoogle/following{/other_user}",
      "gists_url": "https://api.github.com/users/nathanielmanistaatgoogle/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nathanielmanistaatgoogle/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nathanielmanistaatgoogle/subscriptions",
      "organizations_url": "https://api.github.com/users/nathanielmanistaatgoogle/orgs",
      "repos_url": "https://api.github.com/users/nathanielmanistaatgoogle/repos",
      "events_url": "https://api.github.com/users/nathanielmanistaatgoogle/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nathanielmanistaatgoogle/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T17:48:12Z",
    "updated_at": "2018-03-07T17:48:12Z",
    "author_association": "MEMBER",
    "body": "@mehrdada: is there anything about this issue worth keeping open now that interceptors exist?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/371223795",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-371223795",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 371223795,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTIyMzc5NQ==",
    "user": {
      "login": "alertedsnake",
      "id": 753466,
      "node_id": "MDQ6VXNlcjc1MzQ2Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/753466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alertedsnake",
      "html_url": "https://github.com/alertedsnake",
      "followers_url": "https://api.github.com/users/alertedsnake/followers",
      "following_url": "https://api.github.com/users/alertedsnake/following{/other_user}",
      "gists_url": "https://api.github.com/users/alertedsnake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alertedsnake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alertedsnake/subscriptions",
      "organizations_url": "https://api.github.com/users/alertedsnake/orgs",
      "repos_url": "https://api.github.com/users/alertedsnake/repos",
      "events_url": "https://api.github.com/users/alertedsnake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alertedsnake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T17:51:20Z",
    "updated_at": "2018-03-07T17:51:20Z",
    "author_association": "NONE",
    "body": "@nathanielmanistaatgoogle Ah, of course!  That's probably the right way to do it."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/371223996",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-371223996",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 371223996,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTIyMzk5Ng==",
    "user": {
      "login": "mehrdada",
      "id": 900411,
      "node_id": "MDQ6VXNlcjkwMDQxMQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/900411?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mehrdada",
      "html_url": "https://github.com/mehrdada",
      "followers_url": "https://api.github.com/users/mehrdada/followers",
      "following_url": "https://api.github.com/users/mehrdada/following{/other_user}",
      "gists_url": "https://api.github.com/users/mehrdada/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mehrdada/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mehrdada/subscriptions",
      "organizations_url": "https://api.github.com/users/mehrdada/orgs",
      "repos_url": "https://api.github.com/users/mehrdada/repos",
      "events_url": "https://api.github.com/users/mehrdada/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mehrdada/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T17:52:00Z",
    "updated_at": "2018-03-07T17:52:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "I don't have much to add to this except to agree with @nathanielmanistaatgoogle that interceptors introduced a mechanism to add before and after logic for RPCs. We are not currently planning an ability to intercept the add function though. I'm closing this issue. "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/371245509",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-371245509",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 371245509,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTI0NTUwOQ==",
    "user": {
      "login": "alertedsnake",
      "id": 753466,
      "node_id": "MDQ6VXNlcjc1MzQ2Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/753466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alertedsnake",
      "html_url": "https://github.com/alertedsnake",
      "followers_url": "https://api.github.com/users/alertedsnake/followers",
      "following_url": "https://api.github.com/users/alertedsnake/following{/other_user}",
      "gists_url": "https://api.github.com/users/alertedsnake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alertedsnake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alertedsnake/subscriptions",
      "organizations_url": "https://api.github.com/users/alertedsnake/orgs",
      "repos_url": "https://api.github.com/users/alertedsnake/repos",
      "events_url": "https://api.github.com/users/alertedsnake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alertedsnake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T18:57:15Z",
    "updated_at": "2018-03-07T18:57:15Z",
    "author_association": "NONE",
    "body": "Actually, I don't think Interceptors clearly solve this use-case.  Unless I'm missing something (the docs could be a lot better here), there's no way within the interceptor to know your position in the chain of interceptors (thus making the \"after\" case difficult to do reliably), and I don't see a way to inspect the context from within the interceptor, so you can't actually look at the response code or whether the RPC was aborted.\r\n\r\nCurrently, I took the path that @Hujun took with a decorator, but instead just added a logging function via `context.add_callback()`, but it's not really ideal at all, I was hoping for something I could tack onto a server when I create a subclass of `GrpcServer` with specifics to my needs.\r\n\r\nPerhaps you can point out an example?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/371277580",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-371277580",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 371277580,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MTI3NzU4MA==",
    "user": {
      "login": "mehrdada",
      "id": 900411,
      "node_id": "MDQ6VXNlcjkwMDQxMQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/900411?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mehrdada",
      "html_url": "https://github.com/mehrdada",
      "followers_url": "https://api.github.com/users/mehrdada/followers",
      "following_url": "https://api.github.com/users/mehrdada/following{/other_user}",
      "gists_url": "https://api.github.com/users/mehrdada/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mehrdada/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mehrdada/subscriptions",
      "organizations_url": "https://api.github.com/users/mehrdada/orgs",
      "repos_url": "https://api.github.com/users/mehrdada/repos",
      "events_url": "https://api.github.com/users/mehrdada/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mehrdada/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-07T20:42:19Z",
    "updated_at": "2018-03-07T20:42:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "@alertedsnake You cannot tell your position within an interceptor, almost entirely by design: it should be a black box to the interceptor where it is, who invokes it, and what the continuation actually invokes, and the interceptor registration process ensures its place in line of interceptors. If you want an interceptor to run first, you should register it as the first interceptor.\r\n\r\nI assume you are talking about server interceptors, in which case, the interception process happens when an `RpcMethodHandler` is being resolved. I have an example PR for a related thing (not done yet but might be helpful nevertheless): \r\nhttps://github.com/mehrdada/grpc/blob/aa477becd1a7c44f8150ad24539cf6d40af24b37/examples/python/interceptors/service-latency-interceptor/service_latency_interceptor.py\r\n\r\nThe proper way to run something as the last RPC message ends (applicable for response-streaming RPCs only) is to return an `RpcMethodHandler` that invokes the underlying response-streaming method, but wraps the returned response-iterator such that after the last message is encountered on the stream, performs some action."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/374383050",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-374383050",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 374383050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDM4MzA1MA==",
    "user": {
      "login": "alertedsnake",
      "id": 753466,
      "node_id": "MDQ6VXNlcjc1MzQ2Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/753466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alertedsnake",
      "html_url": "https://github.com/alertedsnake",
      "followers_url": "https://api.github.com/users/alertedsnake/followers",
      "following_url": "https://api.github.com/users/alertedsnake/following{/other_user}",
      "gists_url": "https://api.github.com/users/alertedsnake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alertedsnake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alertedsnake/subscriptions",
      "organizations_url": "https://api.github.com/users/alertedsnake/orgs",
      "repos_url": "https://api.github.com/users/alertedsnake/repos",
      "events_url": "https://api.github.com/users/alertedsnake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alertedsnake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-19T21:22:36Z",
    "updated_at": "2018-03-19T21:22:36Z",
    "author_association": "NONE",
    "body": "I found another issue that makes this impossible: you can't actually access the `context` variable within an interceptor, so there are a lot of things you can't see - HTTP headers, for example.  \r\n\r\nThis is possible with using the `context.add_callback()` method I described, but there's no way within the callback to obtain the `context` either, and so it's also not a useful method for logging information therein.\r\n\r\nSo again, I disagree that there is an adequate existing solution for the problem that was asked.  Are there plans to address this in some way?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/374396245",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-374396245",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 374396245,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDM5NjI0NQ==",
    "user": {
      "login": "mehrdada",
      "id": 900411,
      "node_id": "MDQ6VXNlcjkwMDQxMQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/900411?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mehrdada",
      "html_url": "https://github.com/mehrdada",
      "followers_url": "https://api.github.com/users/mehrdada/followers",
      "following_url": "https://api.github.com/users/mehrdada/following{/other_user}",
      "gists_url": "https://api.github.com/users/mehrdada/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mehrdada/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mehrdada/subscriptions",
      "organizations_url": "https://api.github.com/users/mehrdada/orgs",
      "repos_url": "https://api.github.com/users/mehrdada/repos",
      "events_url": "https://api.github.com/users/mehrdada/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mehrdada/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-19T21:59:49Z",
    "updated_at": "2018-03-19T21:59:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "@alertedsnake the idea is you return a substitute RpcMethodHandler from the intercept_service that has access to context. This way if you're not interested in further interception, you can get out of the invocation path of the RPC. If you are, the interceptor constructs it's own wrapper RpcMethodHandler that does arbitrary things when invoked, and that has access to the full context. "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/374397255",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-374397255",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 374397255,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDM5NzI1NQ==",
    "user": {
      "login": "alertedsnake",
      "id": 753466,
      "node_id": "MDQ6VXNlcjc1MzQ2Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/753466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alertedsnake",
      "html_url": "https://github.com/alertedsnake",
      "followers_url": "https://api.github.com/users/alertedsnake/followers",
      "following_url": "https://api.github.com/users/alertedsnake/following{/other_user}",
      "gists_url": "https://api.github.com/users/alertedsnake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alertedsnake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alertedsnake/subscriptions",
      "organizations_url": "https://api.github.com/users/alertedsnake/orgs",
      "repos_url": "https://api.github.com/users/alertedsnake/repos",
      "events_url": "https://api.github.com/users/alertedsnake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alertedsnake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-19T22:02:47Z",
    "updated_at": "2018-03-19T22:02:47Z",
    "author_association": "NONE",
    "body": "@mehrdada Do you have an example of this?  Also, according to what you said earlier, this only works for streaming responses, what about unary?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/374616330",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-374616330",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 374616330,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDYxNjMzMA==",
    "user": {
      "login": "alertedsnake",
      "id": 753466,
      "node_id": "MDQ6VXNlcjc1MzQ2Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/753466?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/alertedsnake",
      "html_url": "https://github.com/alertedsnake",
      "followers_url": "https://api.github.com/users/alertedsnake/followers",
      "following_url": "https://api.github.com/users/alertedsnake/following{/other_user}",
      "gists_url": "https://api.github.com/users/alertedsnake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/alertedsnake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/alertedsnake/subscriptions",
      "organizations_url": "https://api.github.com/users/alertedsnake/orgs",
      "repos_url": "https://api.github.com/users/alertedsnake/repos",
      "events_url": "https://api.github.com/users/alertedsnake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/alertedsnake/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-20T14:24:17Z",
    "updated_at": "2018-03-20T14:24:17Z",
    "author_association": "NONE",
    "body": "I'm trying your method of returning a substitute RpcMethodHandler, based on the code you linked, and there still isn't a way to get the `context._state` and log the error code, since interceptors happen *before* the business logic in the handler code.  The only way you can get that is *after* the call entirely, which means the callback method I described earlier.  Overall I do like this approach better than the callback, if it actually worked.\r\n\r\nPossibly I'm just not seeing what you mean, so if you have an example where this works, that would be great, otherwise again, the question in this issue has not yet been answered."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/374806965",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-374806965",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 374806965,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3NDgwNjk2NQ==",
    "user": {
      "login": "mehrdada",
      "id": 900411,
      "node_id": "MDQ6VXNlcjkwMDQxMQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/900411?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mehrdada",
      "html_url": "https://github.com/mehrdada",
      "followers_url": "https://api.github.com/users/mehrdada/followers",
      "following_url": "https://api.github.com/users/mehrdada/following{/other_user}",
      "gists_url": "https://api.github.com/users/mehrdada/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mehrdada/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mehrdada/subscriptions",
      "organizations_url": "https://api.github.com/users/mehrdada/orgs",
      "repos_url": "https://api.github.com/users/mehrdada/repos",
      "events_url": "https://api.github.com/users/mehrdada/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mehrdada/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-21T00:58:05Z",
    "updated_at": "2018-03-21T00:58:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "@alertedsnake I am OOO for a couple weeks. Will write an example after I come back, but the general pattern is the following:  To intercept the code/details, the idea is to wrap the context *before* passing it to the next `continuation`; that way you can implement your own `set_code`/`set_details`/`abort` calls that keep track of the metadata and then call into the underlying `context`."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/386031453",
    "html_url": "https://github.com/grpc/grpc/issues/9576#issuecomment-386031453",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9576",
    "id": 386031453,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NjAzMTQ1Mw==",
    "user": {
      "login": "wkiser",
      "id": 3188217,
      "node_id": "MDQ6VXNlcjMxODgyMTc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/3188217?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wkiser",
      "html_url": "https://github.com/wkiser",
      "followers_url": "https://api.github.com/users/wkiser/followers",
      "following_url": "https://api.github.com/users/wkiser/following{/other_user}",
      "gists_url": "https://api.github.com/users/wkiser/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wkiser/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wkiser/subscriptions",
      "organizations_url": "https://api.github.com/users/wkiser/orgs",
      "repos_url": "https://api.github.com/users/wkiser/repos",
      "events_url": "https://api.github.com/users/wkiser/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wkiser/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-02T16:06:51Z",
    "updated_at": "2018-05-02T16:06:51Z",
    "author_association": "NONE",
    "body": "@alertedsnake for unary response types you should be able to log the status code in the finally block of @mehrdada's example. `servicer_context._state.code` will be up to date with any changes that occurred in your handler function. One caveat is that code will be None for OK responses."
  }
]
