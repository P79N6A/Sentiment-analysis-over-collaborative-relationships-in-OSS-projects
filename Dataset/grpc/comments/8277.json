[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/253439166",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-253439166",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 253439166,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MzQzOTE2Ng==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-13T07:44:21Z",
    "updated_at": "2016-10-13T07:44:21Z",
    "author_association": "NONE",
    "body": "@jtattermusch any thoughts on this? \n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/253539378",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-253539378",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 253539378,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MzUzOTM3OA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-13T15:00:36Z",
    "updated_at": "2016-10-13T15:00:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "On Tue, Oct 4, 2016 at 3:55 PM, ndglover notifications@github.com wrote:\n\n> Hi,\n> \n> I'm trying to understand the best way to cancel a streaming call from the\n> client. I'm noticing some strange behaviour IMO.\n> 1. When passing a cancellation token into the streaming method call\n>    like below you get an RPCException when this token is cancelled. There is\n>    even a unit test for this _FibWithCancel_. My understanding was this\n>    is how you indicate to the server you'd like to cancel the request so why\n>    should it generate an exception? client.Fib(new FibArgs { Limit = 0 },\n>    cancellationToken: cts.Token)\n> \n> Well, yes, getting an RPCException with StatusCode \"Cancelled\" on the\n> client side when you cancel your call is the intended behavior (you\n> shouldn't get StatusCode.OK because that indicates that the call has\n> finished normally). If you want your calls to finish with an OK status,\n> just don't cancel them (client can indicate he is done by closing the\n> request stream, and a cooperating server can react on request stream being\n> closed by finishing the call with OK status - which actually might be the\n> \"Clean\" behavior you are talking about).\n> \n> Further more by passing in a CancellationToken.None you get no\n> RPCException and it behaves more like I'd expect so I'm not really sure\n> what benefit this token has.\n> \n> If you pass CancellationToken.None to a call on the client side, that means\n> you are not planning to ever cancel the call and you are effectively giving\n> up the opportunity to cancel it. This behavior is in agreement with how\n> cancellation token is used throughout the .NET framework and is to be\n> expected by the users.\n> 1. Regardless of what you do above the server will not complete until\n>    it tries to send the next message and checks the state of it's cancellation\n>    token usually something like: while (!ct.IsCancellationRequested &&\n>    await call.ResponseStream.MoveNext())\n> \n> I don't understand if this code is intended to be run on server or on\n> client. On client, you shouldn't really be checking the cancellation token\n> because you are the one emitting the cancellation. Just catch the\n> RPCException (you need to do that anyway, because you need to handle other\n> call errors somehow).\n> \n> If the stream ticks very slowly or not at all this could be sometime.\n> 1. When the server does tick it then falls into the _ServerCallHandler_\n>    and the method await asyncCall.SendStatusFromServerAsync(status,\n>    context.ResponseTrailers, null).ConfigureAwait(false); throws an\n>    Operation is not valid due to the current state of the object. Should it\n>    not check the context here to see if the call has been cancelled?\n> \n> My application is sending around 1500 streaming requests and then\n> cancelling them from the client before sending another batch with different\n> parameters. What I'm seeing as a result of above is a huge amount of\n> exceptions and a significant lag whilst these happen.\n> \n> Just close your streaming call cleanly (requestStream.CompleteAsync() on\n> client) and have your server return OK status when there aren't any more\n> requests from client. Cancellations are to be used for forcing termination\n> of outstanding calls due to unexpected circumstances, you shouldn't rely on\n> them for handling the basic workflow in your application.\n> \n> It's possible I'm doing something wrong but would like some clarification\n> from the experts please.\n> \n> Thanks\n> \n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/grpc/grpc/issues/8277, or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AJeq5PthfSdAXRMHLVkmCLaMGLUeFm9xks5qwlrOgaJpZM4KNtK_\n> .\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/253539912",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-253539912",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 253539912,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1MzUzOTkxMg==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-13T15:02:18Z",
    "updated_at": "2016-10-13T15:02:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think in your case, you are just misusing the cancellation API for something that can be handled in a better way. Hopefully my explanation is helpful. I'm going to close this now, feel free to reopen if you believe there are still some issues to discuss.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/253790475",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-253790475",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 253790475,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1Mzc5MDQ3NQ==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-14T12:49:55Z",
    "updated_at": "2016-10-14T12:55:57Z",
    "author_association": "NONE",
    "body": "@jtattermusch thanks for looking into this for me, much appreciated. Unfortunately I've had a look at your comments and suggestions and I'm still not clear how I can cancel cleanly. I hope you are right and I'm misusing the API but could you clarify the following a little more for me please?\n\nTo illustrate the issue I'm facing I've modified Math example server and client example code as per below. In this use case there is no request stream for me to call _CompleteAsync_ on. It looks like this is only exposed from the bidirectional streaming API and even then the server will still throw in _SendStatusFromServerAsync_\n\nAside from using the cancellation token I can't see how the client can cancel a streaming response from the server. In my scenario the server stream will live as long as the client keeps it open, it won't be enumerating some data collection and then completing. \n\nIf I accept the fact an RPCException will be thrown on the client then I have to check the cancellation token to know if I can ignore the exception since it's expected or it's something I need to deal with.\n\nSimilarly on the server it seems I can't avoid throwing an exception from the _SendStatusFromServerAsync_\n\nHopefully I'm missing something but would much appreciate your opinion and expertise.\n\nServer\n\n```\npublic override async Task Fib(FibArgs request, IServerStreamWriter<Num> responseStream, ServerCallContext context)\n        {\n            var limit = request.Limit > 0 ? request.Limit : long.MaxValue;\n            var fibEnumerator = FibInternal(limit).GetEnumerator();\n\n            // Keep streaming the sequence until the call is cancelled.\n            // Use CancellationToken from ServerCallContext to detect the cancellation.\n            while (!context.CancellationToken.IsCancellationRequested && fibEnumerator.MoveNext())\n            {\n                await responseStream.WriteAsync(fibEnumerator.Current);\n                await Task.Delay(1000);\n            }\n        }\n```\n\nClient\n\n```\npublic static async Task FibExample2(Math.MathClient client)\n        {\n            var cts = new CancellationTokenSource();\n            using (var call = client.Fib(new FibArgs { Limit = 5 }, Metadata.Empty, null, cts.Token))\n            {\n                while (!cts.Token.IsCancellationRequested && await call.ResponseStream.MoveNext())\n                {\n                    Console.WriteLine(call.ResponseStream.Current);\n                    cts.Cancel(); //Cancel after first response\n                }\n            }\n        }\n```\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254153132",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254153132",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254153132,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDE1MzEzMg==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-17T09:07:09Z",
    "updated_at": "2016-10-17T09:07:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "Ok, I see. So in your case, you are using a server streaming call (unary request, streaming response). Semantically, that means you are sending a single request for the server to do something (send you a list of responses based on the params you've sent). If you later change your mind, you need to cancel the call (which results in throwing and RpcException, and that makes sense, because an OK status code would indicate that the request was fulfilled fully and that is not true).\n\nIf you need the client to indicate that he wants to stop a subscription cleanly, just use a duplex streaming call  (at which point you'll have access to requestStream.CompleteAsync()) instead of a server-streaming call. As far as I can tell, everything on gRPC side is working as intended, but perhaps you want to consider switching you service definition to a bi-di streaming call. \n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254262274",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254262274",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254262274,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDI2MjI3NA==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-17T16:40:41Z",
    "updated_at": "2016-10-17T16:46:45Z",
    "author_association": "NONE",
    "body": "@jtattermusch I could switch to use duplex streaming and this would give me a better way to cancel from the client since I wouldn't get this RPCException. However from what I can see it would still generate an warning on the server, is this expected? Or more specifically is there a better way I can handle this?\n\nTo give you an example\nClient\n\n```\npublic static async Task DivManyExample2(Math.MathClient client)\n        {\n            var cts = new CancellationTokenSource();\n            using (var call = client.DivMany(Metadata.Empty, null, cts.Token))\n            {\n                var completed = false;\n                await call.RequestStream.WriteAsync(new DivArgs {Dividend = 10, Divisor = 3});\n                while (!completed && await call.ResponseStream.MoveNext())\n                {\n                    Console.WriteLine(call.ResponseStream.Current);\n                    await call.RequestStream.CompleteAsync(); //effectively cancel after first response\n                    completed = true;\n                }\n            }\n        }\n```\n\nServer\n\n```\npublic override async Task DivMany(IAsyncStreamReader<DivArgs> requestStream, IServerStreamWriter<DivReply> responseStream, ServerCallContext context)\n        {\n            await requestStream.ForEachAsync(async divArgs =>\n            {\n                //Send Response\n                await responseStream.WriteAsync(DivInternal(divArgs));\n\n                //Simulate pause during which time client cancels\n                await Task.Delay(TimeSpan.FromSeconds(1));\n\n                var cancelRequested = context.CancellationToken.IsCancellationRequested;\n                if (!cancelRequested)\n                {\n                    //We don't go here because the client has cancelled\n                    await responseStream.WriteAsync(DivInternal(divArgs));\n                }\n            });\n        }\n```\n\nWe then end up in the Server.cs around line 326 in my source which throws an exception _\"Operation is not valid due to the current state of the object_\"\n\n![image](https://cloud.githubusercontent.com/assets/2682997/19446435/9c1e7c20-9490-11e6-9142-dccb5fa01ada.png)\n\nWithout a better way to handle it I foresee my server log being filled with warnings and it will be hard to spot real issues from normal runtime conditions.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254433015",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254433015",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254433015,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDQzMzAxNQ==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T07:50:49Z",
    "updated_at": "2016-10-18T07:50:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "As explained before, if you want the call to finish without an RPC exception just _don't cancel it_ and _don't use any cancellation api on the serverside_ (the examples you are posting still contain that). \n\nOn server side, just await requestStream.MoveNext() until it is false (that means client has closed the stream), perhaps do that on a Task and set a flag \"clientHasClosed\".  After that happens, \njust return from the serverside handler and that will result in returning Ok status to the client.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254442002",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254442002",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254442002,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDQ0MjAwMg==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T08:31:56Z",
    "updated_at": "2016-10-18T08:33:44Z",
    "author_association": "NONE",
    "body": "I am not using any cancellation api on the serverside in my latest example above. At least I don't believe I am. Where do you see this?\n\nJust to be clear below has no baring on the outcome, it was there to emphasise the point that the cancel flag is set\n\n```\nvar cancelRequested = context.CancellationToken.IsCancellationRequested;\n                if (!cancelRequested)\n                {\n                    //We don't go here because the client has cancelled\n                    await responseStream.WriteAsync(DivInternal(divArgs));\n                }\n```\n\nI need to complete these streams somehow to avoid a memory leak/overhead. The streams are long lived (i.e. have no natural end, think market data or polling a DB for changes etc), and will never complete unless the client _cancels /completes_ them. If the client calls _RequestStream.CompleteAsync()_ as per my example above then sure there is no exception on the client. However there is still an exception on the server regardless of what I do. The server tries to send back the status OK but the client call has completed so it logs this as a warning. \n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254450170",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254450170",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254450170,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDQ1MDE3MA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T09:07:29Z",
    "updated_at": "2016-10-18T09:07:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "On Tue, Oct 18, 2016 at 10:32 AM, ndglover notifications@github.com wrote:\n\n> I am not using any cancellation api on the serverside in my latest example\n> above. At least I don't believe I am. Where do you see this?\n\nYou are checking value of\ncontext.CancellationToken.IsCancellationRequested (that's\nclearly part of cancellation API IMHO). Not saying that you rely on this in\nyour example, but it's misleading.\n\n> ```\n>             I need to complete these streams somehow to avoid a\n> ```\n> \n> memory leak/overhead. The streams are long lived (i.e. have no natural end,\n> think market data or polling a DB for changes etc), and will never complete\n> unless the client _cancels /completes_ them. If the client calls\n> _RequestStream.CompleteAsync()_ as per my example above then sure there\n> is no exception on the client. However there is still an exception on the\n> server regardless of what I do.\n> \n> If the client completes with completeAsync, it doesn't mean that the call\n> has finished, the server still needs to finish the call by sending the\n> status (happens when you return from the serverside handler). So basically\n> - I think you are wrong in saying that exception is thrown on the\n>   serverside if the client closes the stream cleanly (and in case you are\n>   right, that's a bug, but we do have tests for this so I have a very hard\n>   time believing this).\n> \n> The server tries to send back the status OK but the client call has\n> completed so it logs this as a warning.\n> \n> That's only if the call has actually been cancelled, if client closes\n> cleanly, the call is alive until server decides to finish it.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/grpc/grpc/issues/8277#issuecomment-254442002, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AJeq5CrbovY-tPUT2N2KQa88H7a7xMSdks5q1IQRgaJpZM4KNtK_\n> .\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254453407",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254453407",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254453407,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDQ1MzQwNw==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T09:21:18Z",
    "updated_at": "2016-10-18T09:21:50Z",
    "author_association": "NONE",
    "body": "Eats large piece of humble pie.... Yes please accept my apologies, the additional check for the cancellation token was the issue. Well part of it anyway, the second `await responseStream.WriteAsync(DivInternal(divArgs));` was throwing. So having two writes inside a single request loop is clearly an issue if the request has been cancelled. \n\nReally appreciate your help on this, thanks for clearing it up.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254456528",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254456528",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254456528,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDQ1NjUyOA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T09:34:13Z",
    "updated_at": "2016-10-18T09:34:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "Np, glad that you were able to successfully sort this out.\n\nOn Tue, Oct 18, 2016 at 11:21 AM, ndglover notifications@github.com wrote:\n\n> Eats large piece of humble pie.... Yes please accept my apologies, the\n> additional check for the cancellation token was the issue. Well part of it\n> anyway, the second await responseStream.WriteAsync(DivInternal(divArgs));\n> was throwing. So having two writes inside a single response is clearly an\n> issue if the request has been cancelled.\n> \n> Really appreciate your help on this, thanks for clearing it up.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> https://github.com/grpc/grpc/issues/8277#issuecomment-254453407, or mute\n> the thread\n> https://github.com/notifications/unsubscribe-auth/AJeq5CuQtauhczvNBAwDBoDjlQipJ4h4ks5q1I-kgaJpZM4KNtK_\n> .\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254580204",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254580204",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254580204,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDU4MDIwNA==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-18T17:30:02Z",
    "updated_at": "2016-10-18T17:30:02Z",
    "author_association": "NONE",
    "body": "@jtattermusch Yikes, After much deliberation I think I'm back in the same place. As you said the call won't finish until I return from the serverside handler and I'll never return from this handler for these long lived queries. So in order for me to return and clean up any resources the only way I know the client has cancelled is to look at the _ServerCallContext_. I feel like I need a hook into the fact the client called CompleteAsync but I don't have one.\n\n```\npublic override async Task DivMany(IAsyncStreamReader<DivArgs> requestStream, IServerStreamWriter<DivReply> responseStream, ServerCallContext context)\n        {\n            while (await requestStream.MoveNext())\n            {\n                try\n                {\n                    //Fake query that might never return\n                    await CreateLongRunningQueryThatNeedsToDisposeOfExpensiveResource(requestStream.Current, responseStream);\n                }\n                catch (Exception ex)\n                {\n                    //Swallow task cancelled\n                    //Console.WriteLine($\"Server Error {ex}\");\n                }\n            }\n        }\n\n        public async Task CreateLongRunningQueryThatNeedsToDisposeOfExpensiveResource(DivArgs divArgs, IServerStreamWriter<DivReply> responseStream)\n        {\n            //1. Create resource that must be disposed\n            var results = Task.Delay(TimeSpan.FromDays(1));            \n\n            //2. Query it\n            await results;\n\n            //3.Write results to response stream\n            await responseStream.WriteAsync(new DivReply());\n        }\n```\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/254767804",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-254767804",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 254767804,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NDc2NzgwNA==",
    "user": {
      "login": "ndglover",
      "id": 2682997,
      "node_id": "MDQ6VXNlcjI2ODI5OTc=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/2682997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ndglover",
      "html_url": "https://github.com/ndglover",
      "followers_url": "https://api.github.com/users/ndglover/followers",
      "following_url": "https://api.github.com/users/ndglover/following{/other_user}",
      "gists_url": "https://api.github.com/users/ndglover/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ndglover/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ndglover/subscriptions",
      "organizations_url": "https://api.github.com/users/ndglover/orgs",
      "repos_url": "https://api.github.com/users/ndglover/repos",
      "events_url": "https://api.github.com/users/ndglover/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ndglover/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-19T09:56:13Z",
    "updated_at": "2016-10-19T09:59:10Z",
    "author_association": "NONE",
    "body": "Hi, I've created a few unit tests to display the problem I'm facing.\n\nI need to ensure that the _ExpensiveResource_ is disposed and everything tears down without exceptions. Right now if _ExpensiveResource_ doesn't return as in the Task.Delay for 1 day then I can't shutdown or clean up using only CompleteAsync.\n\n```\npublic class MathServiceImplNu : Math.MathBase\n    {\n        public const long DividendThatReturns = 5;\n        public const long DividendThatWaits = 10;\n\n        public class ExpensiveResource : IDisposable\n        {\n            public async Task DoWork(IServerStreamWriter<DivReply> responseStream, long argument, CancellationToken token)\n            {\n                if (argument == DividendThatReturns)\n                    await responseStream.WriteAsync(new DivReply() {Quotient = 1, Remainder = 1});\n                else\n                    await Task.Delay(TimeSpan.FromDays(1), token);\n\n                Console.WriteLine(\"I have some results\");\n            }\n\n            public void Dispose()\n            {\n                Console.WriteLine(\"Disposed ExpensiveResource\");\n            }\n        }\n\n        public override async Task DivMany(IAsyncStreamReader<DivArgs> requestStream, IServerStreamWriter<DivReply> responseStream, ServerCallContext context)\n        {\n            while (await requestStream.MoveNext())\n            {\n                var request = requestStream.Current;\n                using (var resource = new ExpensiveResource())\n                {\n                    await resource.DoWork(responseStream, request.Dividend, context.CancellationToken);\n                }\n            }\n        }\n    }\n\n    public class CompleteCleanlyTests\n    {\n        const string Host = \"localhost\";\n        Server _server;\n        Channel _channel;\n        Math.MathClient _client;\n\n        [SetUp]\n        public void Init()\n        {\n            _server = new Server\n            {\n                Services = { Math.BindService(new MathServiceImplNu()) },\n                Ports = { { Host, ServerPort.PickUnused, ServerCredentials.Insecure } }\n            };\n            _server.Start();\n            _channel = new Channel(Host, _server.Ports.Single().BoundPort, ChannelCredentials.Insecure);\n            _client = new Math.MathClient(_channel);\n        }\n\n        [TearDown]\n        public void Shutdown()\n        {\n            _server.ShutdownAsync().Wait();\n            Console.WriteLine(\"Shutdown Server\");\n        }\n\n        [Test]\n        public async Task Will_Never_Complete()\n        {\n            var call = _client.DivMany(Metadata.Empty, null, CancellationToken.None);\n            await call.RequestStream.WriteAsync(new DivArgs { Dividend = MathServiceImplNu.DividendThatWaits, Divisor = 3 });\n            var completed = Task.Run(async () =>\n            {\n                await Task.Delay(100); \n                Console.WriteLine(\"Completing Stream\");\n                await call.RequestStream.CompleteAsync();\n            });\n\n            while (await call.ResponseStream.MoveNext())\n            {\n\n            }\n\n            await completed;\n            _channel.ShutdownAsync().Wait();\n        }\n\n        [Test]\n        public async Task Completes_But_With_Exceptions()\n        {\n            var cts = new CancellationTokenSource();\n            var call = _client.DivMany(Metadata.Empty, null, cts.Token);\n            await call.RequestStream.WriteAsync(new DivArgs { Dividend = MathServiceImplNu.DividendThatWaits, Divisor = 3 });\n            var completed = Task.Run(async () =>\n            {\n                await Task.Delay(100); //assume we have results by now\n                Console.WriteLine(\"Completing Stream\");\n                await call.RequestStream.CompleteAsync();\n                cts.Cancel();\n            });\n\n            while (await call.ResponseStream.MoveNext())\n            {\n\n            }\n\n            await completed;\n            _channel.ShutdownAsync().Wait();\n        }\n\n        [Test]\n        public async Task Working_Test()\n        {\n            var call = _client.DivMany(Metadata.Empty, null, CancellationToken.None);\n            await call.RequestStream.WriteAsync(new DivArgs { Dividend = MathServiceImplNu.DividendThatReturns, Divisor = 3 });\n            DivReply response = null;\n\n            var completed = Task.Run(async () =>\n            {\n                await Task.Delay(100); //assume we have results by now\n                Console.WriteLine(\"Completing Stream\");\n                await call.RequestStream.CompleteAsync();\n            });\n\n            while (await call.ResponseStream.MoveNext())\n            {\n                response = call.ResponseStream.Current;\n            }\n\n            await completed;\n            await _channel.ShutdownAsync();\n\n            Assert.IsNotNull(response);\n            Assert.AreEqual(1, response.Quotient);\n            Assert.AreEqual(1, response.Remainder);\n        }\n    }\n\n```\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/276501032",
    "html_url": "https://github.com/grpc/grpc/issues/8277#issuecomment-276501032",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8277",
    "id": 276501032,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3NjUwMTAzMg==",
    "user": {
      "login": "gazialankus",
      "id": 412997,
      "node_id": "MDQ6VXNlcjQxMjk5Nw==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/412997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gazialankus",
      "html_url": "https://github.com/gazialankus",
      "followers_url": "https://api.github.com/users/gazialankus/followers",
      "following_url": "https://api.github.com/users/gazialankus/following{/other_user}",
      "gists_url": "https://api.github.com/users/gazialankus/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gazialankus/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gazialankus/subscriptions",
      "organizations_url": "https://api.github.com/users/gazialankus/orgs",
      "repos_url": "https://api.github.com/users/gazialankus/repos",
      "events_url": "https://api.github.com/users/gazialankus/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gazialankus/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-31T21:39:04Z",
    "updated_at": "2017-01-31T21:41:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "I have been getting the \"Operation is not valid due to the current state of the object\" exception or experiencing hangs and I figured out the correct client ritual for ending a rpc call with a bidirectional stream. \r\n\r\nThis is how your client code needs to be: \r\n\r\n1. Use `call.RequestStream` and `call.ResponseStream` to your heart's content. After your last write to `call.RequestStream`, go to the step below.\r\n2. Use `call.RequestStream.CompleteAsync();` to close `call.RequestStream`. **_If you don't do this step, the next step results in a hang._**\r\n3. Consume what's left in `call.ResponseStream` by something like `while(await call.ResponseStream.MoveNext());`. **_If you don't do this step, you get an exception in the server side and a warning in the client side._** \r\n\r\nYou have to do 2 and 3 in this order, or it won't work.\r\n\r\nHere are the outputs you get in step 3 if you don't consume what's left in `call.ResponseStream`: \r\n\r\nOn the client side: \r\n```\r\nW0201 00:34:15.441516 Grpc.Core.Channel Channel shutdown was called but there are still 1 active calls for that channel.\r\n```\r\n\r\nOn the server side: \r\n```\r\nW0201 00:34:15.739214 Grpc.Core.Server Exception while handling RPC. System.InvalidOperationException: Operation is not valid due to the current state of the object.\r\n   at Grpc.Core.Internal.AsyncCallServer`2.SendStatusFromServerAsync(Status status, Metadata trailers, Tuple`2 optionalWrite)\r\n   at Grpc.Core.Internal.DuplexStreamingServerCallHandler`2.<HandleCall>d__4.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\n   at Grpc.Core.Server.<HandleCallAsync>d__34.MoveNext()\r\n```\r\n\r\nHope this helps someone. "
  }
]
