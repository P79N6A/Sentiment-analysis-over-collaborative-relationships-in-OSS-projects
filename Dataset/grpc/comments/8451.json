[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255348365",
    "html_url": "https://github.com/grpc/grpc/issues/8451#issuecomment-255348365",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8451",
    "id": 255348365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTM0ODM2NQ==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-21T10:30:44Z",
    "updated_at": "2016-10-21T10:30:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "Do you have a code snippet that replicates this?\n\nWhat platform are you on? Also, from your description it seems it's about a call on the client side, is that right?\n\nBtw, for testing various orderings in which operation completions can arrive to a call, we have this test:\nhttps://github.com/grpc/grpc/blob/9f4e828343a78a24988e638cf7ac865cf3947cbe/src/csharp/Grpc.Core.Tests/Internal/AsyncCallTest.cs  (it runs the call handling logic against a mocked-out C core API and verifies that the behavior is as expected).\nWould you be able to express your scenario as a test case there?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255350507",
    "html_url": "https://github.com/grpc/grpc/issues/8451#issuecomment-255350507",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8451",
    "id": 255350507,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTM1MDUwNw==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-21T10:43:24Z",
    "updated_at": "2016-10-21T10:43:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "To understand this correctly, you basically read X (a known number) of responses on the client side and then you stop reading because you know that's all the messages that will be sent from the server?\n\nI think if you are expecting X responses, it is a good practice to make sure that's the end of the stream and that there hasn't been an error:\n\n```\n// read X msgs here\n\nGrpcPreconditions.CheckState(! await responseStream.MoveNext());  // check this is end of the stream.\n```\n\nAlternatively, you could use an extension method from Grpc.Core.Utils and do\n\n```\nvar responses = await responseStream.ToList();   // read all the responses\nGrpcPreconditions(responses.Count == X); // make sure we got the expected num of responses\n```\n\nin which case you don't need to invoke any extra MoveNext() yourself.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255464647",
    "html_url": "https://github.com/grpc/grpc/issues/8451#issuecomment-255464647",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8451",
    "id": 255464647,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTQ2NDY0Nw==",
    "user": {
      "login": "kkm000",
      "id": 8228229,
      "node_id": "MDQ6VXNlcjgyMjgyMjk=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8228229?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kkm000",
      "html_url": "https://github.com/kkm000",
      "followers_url": "https://api.github.com/users/kkm000/followers",
      "following_url": "https://api.github.com/users/kkm000/following{/other_user}",
      "gists_url": "https://api.github.com/users/kkm000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kkm000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kkm000/subscriptions",
      "organizations_url": "https://api.github.com/users/kkm000/orgs",
      "repos_url": "https://api.github.com/users/kkm000/repos",
      "events_url": "https://api.github.com/users/kkm000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kkm000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-21T21:03:29Z",
    "updated_at": "2016-10-21T21:06:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Do you have a code snippet that replicates this?\n\nI'll make one tonight, based on one of the examples. Should be easy.\n\n> What platform are you on? Also, from your description it seems it's about a call on the client side, is that right?\n\nClient is a 32-bit process on Windows. Yes, the bug I see happens on the client side.\n\n> Btw, for testing various orderings in which operation completions can arrive to a call, we have this test\n\nI do not see it verifying that a channel indeed has the call counter of 0 in this test. If possible, that should be tested in the `Assert*` methods.\n\nLet me see if I can repro in the test.\n\n> To understand this correctly, you basically read X (a known number) of responses on the client side and then you stop reading because you know that's all the messages that will be sent from the server?\n\nOh believe me, this is complex. Both endpoints have the message flow that depends on previous server responses. \n\n```\nClient: I have this data for you, here's a header.\nServer: (1st message) Thanks, but I do not need it.\nClient (disposes the call without reading to EOF).\n```\n\n```\nClient: I have this data for you, here's a header.\nServer: (1st message) Please send!\nClient: message, message, ..., EOF\nServer churns for a while then (2nd message): Here are your results:...\nClient (disposes the call without reading to EOF).\n```\n\nThe second service has an even more complex protocol, where the server emits messages both in response to a flag in the client's message (at most once per client message, 0 to many per call), and a final response upon the end of client's send stream. This happens in real world time, client messages encapsulate a real time stream. Upon receiving the next reply from the server, the client can decide it has a good enough response and dispose of the call. The server (C++) sees the call as canceled just fine; but the C# channel has its call count permanently increased after the cancellation.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255567774",
    "html_url": "https://github.com/grpc/grpc/issues/8451#issuecomment-255567774",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8451",
    "id": 255567774,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTU2Nzc3NA==",
    "user": {
      "login": "kkm000",
      "id": 8228229,
      "node_id": "MDQ6VXNlcjgyMjgyMjk=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8228229?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kkm000",
      "html_url": "https://github.com/kkm000",
      "followers_url": "https://api.github.com/users/kkm000/followers",
      "following_url": "https://api.github.com/users/kkm000/following{/other_user}",
      "gists_url": "https://api.github.com/users/kkm000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kkm000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kkm000/subscriptions",
      "organizations_url": "https://api.github.com/users/kkm000/orgs",
      "repos_url": "https://api.github.com/users/kkm000/repos",
      "events_url": "https://api.github.com/users/kkm000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kkm000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-23T03:39:28Z",
    "updated_at": "2016-10-23T05:07:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "I reproduced the bug in the MR mentioned above. Simply break out of the `while(ReadNext())` loop to have a channel socket never be released even after channel shutdown. Exactly what I see in our production. I'll try to build a test for it.\n\nSince my setup trims EOL whitespace, it's easier to look at the changes with `?w=1`: https://github.com/grpc/grpc/pull/8471/files?w=1\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/255651512",
    "html_url": "https://github.com/grpc/grpc/issues/8451#issuecomment-255651512",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8451",
    "id": 255651512,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1NTY1MTUxMg==",
    "user": {
      "login": "kkm000",
      "id": 8228229,
      "node_id": "MDQ6VXNlcjgyMjgyMjk=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8228229?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kkm000",
      "html_url": "https://github.com/kkm000",
      "followers_url": "https://api.github.com/users/kkm000/followers",
      "following_url": "https://api.github.com/users/kkm000/following{/other_user}",
      "gists_url": "https://api.github.com/users/kkm000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kkm000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kkm000/subscriptions",
      "organizations_url": "https://api.github.com/users/kkm000/orgs",
      "repos_url": "https://api.github.com/users/kkm000/repos",
      "events_url": "https://api.github.com/users/kkm000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kkm000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-10-24T05:34:41Z",
    "updated_at": "2016-10-24T17:48:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "I wrote 2 unit tests that reproduced the problem; the single-line change in AsyncCallBase.cs fixed it and did not break anything else. Please check if the fix makes sense to you, and let's wait for the integration tests to return. Please do not commit yet even if LG, I am going to give the change a run in our QA milieu.\n\n_EDIT:_ The routeguide sample reproduction #8471 is also fixed by this change, and the sample runs to the end successfully both with and without the early break out of the stream reading loop.\n"
  }
]
