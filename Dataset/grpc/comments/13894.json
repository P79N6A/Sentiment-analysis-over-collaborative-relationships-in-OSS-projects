[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/354674155",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-354674155",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 354674155,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NDY3NDE1NQ==",
    "user": {
      "login": "vjpai",
      "id": 8864912,
      "node_id": "MDQ6VXNlcjg4NjQ5MTI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8864912?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vjpai",
      "html_url": "https://github.com/vjpai",
      "followers_url": "https://api.github.com/users/vjpai/followers",
      "following_url": "https://api.github.com/users/vjpai/following{/other_user}",
      "gists_url": "https://api.github.com/users/vjpai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vjpai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vjpai/subscriptions",
      "organizations_url": "https://api.github.com/users/vjpai/orgs",
      "repos_url": "https://api.github.com/users/vjpai/repos",
      "events_url": "https://api.github.com/users/vjpai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vjpai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-01T20:20:34Z",
    "updated_at": "2018-01-01T20:20:34Z",
    "author_association": "MEMBER",
    "body": "It won't be a callback. The client needs to invoke an RPC and then the server will just write on it when it wants to send a notification. This could be a unary RPC if the client just wants to wait for the next push notification, server-side streaming if the client wants to collect a sequence of server messages, or bidirectional streaming if the client will collect a sequence of messages and also send feedback or further information to the server.\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/354693575",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-354693575",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 354693575,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NDY5MzU3NQ==",
    "user": {
      "login": "thincal",
      "id": 1206509,
      "node_id": "MDQ6VXNlcjEyMDY1MDk=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1206509?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thincal",
      "html_url": "https://github.com/thincal",
      "followers_url": "https://api.github.com/users/thincal/followers",
      "following_url": "https://api.github.com/users/thincal/following{/other_user}",
      "gists_url": "https://api.github.com/users/thincal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thincal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thincal/subscriptions",
      "organizations_url": "https://api.github.com/users/thincal/orgs",
      "repos_url": "https://api.github.com/users/thincal/repos",
      "events_url": "https://api.github.com/users/thincal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thincal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-02T02:09:56Z",
    "updated_at": "2018-01-02T02:09:56Z",
    "author_association": "NONE",
    "body": "Thanks vjpai, but how to start a long-lived streaming RPC from the client to server and keep reading on it ? does that mean client should maintain a thread to keep reading ?\r\n\r\nAny example in c++ ?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/355091691",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-355091691",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 355091691,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTA5MTY5MQ==",
    "user": {
      "login": "vjpai",
      "id": 8864912,
      "node_id": "MDQ6VXNlcjg4NjQ5MTI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8864912?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vjpai",
      "html_url": "https://github.com/vjpai",
      "followers_url": "https://api.github.com/users/vjpai/followers",
      "following_url": "https://api.github.com/users/vjpai/following{/other_user}",
      "gists_url": "https://api.github.com/users/vjpai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vjpai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vjpai/subscriptions",
      "organizations_url": "https://api.github.com/users/vjpai/orgs",
      "repos_url": "https://api.github.com/users/vjpai/repos",
      "events_url": "https://api.github.com/users/vjpai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vjpai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-03T18:41:45Z",
    "updated_at": "2018-01-03T18:41:45Z",
    "author_association": "MEMBER",
    "body": "It's your choice of whether to use the synchronous API in C++ or the async API. If you use the sync API, you should probably have a separate thread in the client API to Read for push notifications. If you use the async API, you can just start the `Read` and then do a `CompletionQueue::Next` operation until you get the tag of the `Read`; that works if you don't want to reserve a thread.\r\n\r\nWe don't have an existing example for this; that could be a feature request for the future.\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/403225697",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-403225697",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 403225697,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzIyNTY5Nw==",
    "user": {
      "login": "sivabudh",
      "id": 618729,
      "node_id": "MDQ6VXNlcjYxODcyOQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/618729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sivabudh",
      "html_url": "https://github.com/sivabudh",
      "followers_url": "https://api.github.com/users/sivabudh/followers",
      "following_url": "https://api.github.com/users/sivabudh/following{/other_user}",
      "gists_url": "https://api.github.com/users/sivabudh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sivabudh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sivabudh/subscriptions",
      "organizations_url": "https://api.github.com/users/sivabudh/orgs",
      "repos_url": "https://api.github.com/users/sivabudh/repos",
      "events_url": "https://api.github.com/users/sivabudh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sivabudh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T16:06:41Z",
    "updated_at": "2018-07-07T16:07:22Z",
    "author_association": "NONE",
    "body": "@vjpai \r\nIn your opinion, was gRPC built for publish / subscribe or observer pattern (where clients get updates only after every server's write)?\r\n\r\nIt seems to be gRPC only supports remote procedure call (where the client must first initiate the communication by sending a message, then the server will respond)."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/403234744",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-403234744",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 403234744,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzIzNDc0NA==",
    "user": {
      "login": "vjpai",
      "id": 8864912,
      "node_id": "MDQ6VXNlcjg4NjQ5MTI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8864912?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vjpai",
      "html_url": "https://github.com/vjpai",
      "followers_url": "https://api.github.com/users/vjpai/followers",
      "following_url": "https://api.github.com/users/vjpai/following{/other_user}",
      "gists_url": "https://api.github.com/users/vjpai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vjpai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vjpai/subscriptions",
      "organizations_url": "https://api.github.com/users/vjpai/orgs",
      "repos_url": "https://api.github.com/users/vjpai/repos",
      "events_url": "https://api.github.com/users/vjpai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vjpai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T18:29:09Z",
    "updated_at": "2018-07-07T18:29:09Z",
    "author_association": "MEMBER",
    "body": "A textbook \"remote procedure call\" is what gRPC calls a unary call: the client sends a request to the server and gets a single response. However, gRPC also supports streaming RPCs. The initial communication must come from the client (though it can just be a method name, not a payload message), but the data after that can flow from client-to-server, from server-to-client, or both directions. The patterns you've described are suited for bidirectional or server-side streaming RPCs. For example, in the observer pattern, the clients register themselves as observers to the server (which plays the role of the observer pattern subject) by invoking a server-streaming RPC on the subject, and the subject will then send its updates back to the clients as message responses on that RPC. You can set up similar communications for pub-sub, though it depends a lot on if you use brokerless or brokered. "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/403240983",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-403240983",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 403240983,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzI0MDk4Mw==",
    "user": {
      "login": "sivabudh",
      "id": 618729,
      "node_id": "MDQ6VXNlcjYxODcyOQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/618729?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sivabudh",
      "html_url": "https://github.com/sivabudh",
      "followers_url": "https://api.github.com/users/sivabudh/followers",
      "following_url": "https://api.github.com/users/sivabudh/following{/other_user}",
      "gists_url": "https://api.github.com/users/sivabudh/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sivabudh/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sivabudh/subscriptions",
      "organizations_url": "https://api.github.com/users/sivabudh/orgs",
      "repos_url": "https://api.github.com/users/sivabudh/repos",
      "events_url": "https://api.github.com/users/sivabudh/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sivabudh/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T20:26:43Z",
    "updated_at": "2018-07-07T20:27:45Z",
    "author_association": "NONE",
    "body": "@vjpai Thanks. What I don't like about gRPC RE: server-side streaming, is 1 point:\r\n\r\n1. I need to use a `while(true)` to maintain the connection with the client and cannot `return`\r\n\r\nCase in point, I built a server-side streaming service called `RouteChat` with Qt as follows:\r\n```\r\nStatus RouteGuideServer::RouteChat(ServerContext *context_, Stream *stream_)\r\n{\r\n  this->stream = stream_;    // Notice: storing the stream for other method access!\r\n\r\n  qDebug() << \"A client is connected\";\r\n\r\n  RouteNote newNote;\r\n  while(this->stream->Read(&newNote))    // Read newNote from client\r\n  {\r\n    emit authorizationReceived(QString::fromStdString(newNote.DebugString()));\r\n  }\r\n\r\n  qDebug() << \"Stopped reading\";\r\n  return Status::OK;\r\n}\r\n```\r\nWith this `while(true)` pattern (because I cannot return from the function), how does one clean up gracefully suppose I wanted to shut down the process?\r\n\r\nOn a side point, notice above I had to save the `stream_` variable. It's because I re-use it in another method when the process needs to send back some message to the client.\r\n\r\n```\r\nvoid RouteGuideServer::transmitMessage()\r\n{\r\n  auto newNote = MakeRouteNote(\"newest pump status\", 4, 3000);\r\n\r\n  this->stream->Write(newNote);   // This is set from RouteChat() method!\r\n\r\n  qDebug() << QString::fromStdString(newNote.DebugString());\r\n}\r\n```\r\n\r\nThe whole thing just doesn't look that elegant to me. It's hard to:\r\n1. To keep the process truly event-driven\r\n2. Hard to clean up and shutdown gracefully\r\n\r\nOr am I going about this the wrong way?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/405014735",
    "html_url": "https://github.com/grpc/grpc/issues/13894#issuecomment-405014735",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/13894",
    "id": 405014735,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTAxNDczNQ==",
    "user": {
      "login": "noamyogev84",
      "id": 7726629,
      "node_id": "MDQ6VXNlcjc3MjY2Mjk=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7726629?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/noamyogev84",
      "html_url": "https://github.com/noamyogev84",
      "followers_url": "https://api.github.com/users/noamyogev84/followers",
      "following_url": "https://api.github.com/users/noamyogev84/following{/other_user}",
      "gists_url": "https://api.github.com/users/noamyogev84/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/noamyogev84/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/noamyogev84/subscriptions",
      "organizations_url": "https://api.github.com/users/noamyogev84/orgs",
      "repos_url": "https://api.github.com/users/noamyogev84/repos",
      "events_url": "https://api.github.com/users/noamyogev84/events{/privacy}",
      "received_events_url": "https://api.github.com/users/noamyogev84/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-14T10:36:09Z",
    "updated_at": "2018-07-14T10:36:09Z",
    "author_association": "NONE",
    "body": "As @sivabudh describes, it appears to be not trivial to maintain a persistent client connection, and be able to actively push messages to a specific client without looping in a server stream method and keeping a collection of streams to manage the clients.\r\n"
  }
]
