[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/258076777",
    "html_url": "https://github.com/grpc/grpc/issues/8580#issuecomment-258076777",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8580",
    "id": 258076777,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1ODA3Njc3Nw==",
    "user": {
      "login": "apolcyn",
      "id": 9566254,
      "node_id": "MDQ6VXNlcjk1NjYyNTQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9566254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolcyn",
      "html_url": "https://github.com/apolcyn",
      "followers_url": "https://api.github.com/users/apolcyn/followers",
      "following_url": "https://api.github.com/users/apolcyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolcyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolcyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolcyn/subscriptions",
      "organizations_url": "https://api.github.com/users/apolcyn/orgs",
      "repos_url": "https://api.github.com/users/apolcyn/repos",
      "events_url": "https://api.github.com/users/apolcyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolcyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-03T07:18:06Z",
    "updated_at": "2016-11-03T07:18:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "Based on the repro, I think what's happening is a mixture of sync and async code that's causing this.\n\nIn general, deadlock could happen easily if doing sync/blocking work in server handler methods.\n\nFor details on the internals around this, GRPC C# servers have a thread pool, as described in https://github.com/grpc/grpc/issues/6948. If you block or do a long running task in a server handler method, then that server thread wont be able to make progress on events that are ready to run their continuations for. For example, when repro-ing this with`Thread.Sleep(10000)` and two concurrent client requests, both requests end up showing up in the \"event source\" of the same worker thread, but the first one occupies it with the sleep and so that thread can't make progress on the second one. E.g., if the sleep is changed to `await Task.Delay(10000)`, then the problem goes away since the GRPC server thread is able to continue polling for work, and the rest the continuation of the handler method is able to run on a .NET runtime task scheduler thread. As for the completion queue setting, \"events\" that GRPC server threads poll for are tied to \"completion queues\" as their \"source\". Setting the completion queue count lower doesn't actually lower the server thread pool size, but instead just makes them all share this same event source, so when the one thread is blocked on `Sleep`, other server thread pool threads are able to pick up the other call (it just happens that the other call ends up on the same completion queue \"source\" as the first).\n\nBut to avoid all of it, it's should be best to run async rather than blocking tasks, and to possibly offload long-running CPU work if its necessary.\n\ncc @jtattermusch if there's more on this\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/258328689",
    "html_url": "https://github.com/grpc/grpc/issues/8580#issuecomment-258328689",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8580",
    "id": 258328689,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1ODMyODY4OQ==",
    "user": {
      "login": "apolcyn",
      "id": 9566254,
      "node_id": "MDQ6VXNlcjk1NjYyNTQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9566254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolcyn",
      "html_url": "https://github.com/apolcyn",
      "followers_url": "https://api.github.com/users/apolcyn/followers",
      "following_url": "https://api.github.com/users/apolcyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolcyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolcyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolcyn/subscriptions",
      "organizations_url": "https://api.github.com/users/apolcyn/orgs",
      "repos_url": "https://api.github.com/users/apolcyn/repos",
      "events_url": "https://api.github.com/users/apolcyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolcyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-04T02:19:37Z",
    "updated_at": "2016-11-04T02:19:37Z",
    "author_association": "CONTRIBUTOR",
    "body": "To add a bit more to this, it is not only the servers that complete their async tasks with a dedicated GRPC thread pool, but also client GRPC calls as well. So basically the same problems with long-running CPU work and blocking calls in server handlers also exist after making a client call. The client call is also completed on one of the GRPC threads, and so when returning from an async client call, blocking or doing long-running CPU work would prevent progress from things that the thread is able to do. \n\nBut for this too, the best thing to do is probably to avoid mixing sync and async calls as it can be prone to deadlock.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/258517841",
    "html_url": "https://github.com/grpc/grpc/issues/8580#issuecomment-258517841",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8580",
    "id": 258517841,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI1ODUxNzg0MQ==",
    "user": {
      "login": "apolcyn",
      "id": 9566254,
      "node_id": "MDQ6VXNlcjk1NjYyNTQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9566254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/apolcyn",
      "html_url": "https://github.com/apolcyn",
      "followers_url": "https://api.github.com/users/apolcyn/followers",
      "following_url": "https://api.github.com/users/apolcyn/following{/other_user}",
      "gists_url": "https://api.github.com/users/apolcyn/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/apolcyn/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/apolcyn/subscriptions",
      "organizations_url": "https://api.github.com/users/apolcyn/orgs",
      "repos_url": "https://api.github.com/users/apolcyn/repos",
      "events_url": "https://api.github.com/users/apolcyn/events{/privacy}",
      "received_events_url": "https://api.github.com/users/apolcyn/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-04T18:52:22Z",
    "updated_at": "2016-11-04T18:52:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "closing as there doesn't look to be a bug\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/261289085",
    "html_url": "https://github.com/grpc/grpc/issues/8580#issuecomment-261289085",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8580",
    "id": 261289085,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MTI4OTA4NQ==",
    "user": {
      "login": "jumar",
      "id": 70004,
      "node_id": "MDQ6VXNlcjcwMDA0",
      "avatar_url": "https://avatars3.githubusercontent.com/u/70004?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jumar",
      "html_url": "https://github.com/jumar",
      "followers_url": "https://api.github.com/users/jumar/followers",
      "following_url": "https://api.github.com/users/jumar/following{/other_user}",
      "gists_url": "https://api.github.com/users/jumar/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jumar/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jumar/subscriptions",
      "organizations_url": "https://api.github.com/users/jumar/orgs",
      "repos_url": "https://api.github.com/users/jumar/repos",
      "events_url": "https://api.github.com/users/jumar/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jumar/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-17T16:08:04Z",
    "updated_at": "2016-11-17T16:08:43Z",
    "author_association": "NONE",
    "body": "Then how can I tell the c# code generator to generate  non async API methods in the server ?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/261876365",
    "html_url": "https://github.com/grpc/grpc/issues/8580#issuecomment-261876365",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/8580",
    "id": 261876365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MTg3NjM2NQ==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-21T08:40:46Z",
    "updated_at": "2016-11-21T08:40:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "You cannot. Only async methods are supported on the server side. When implementing them, you either need to implement the async code according to the .NET best practices (e.g. don't block on the threads and use async primitives instead - e.g. use Task.Delay instead of Thread.Sleep), or you can offload the sync operations to a different thread (e.g. using Task.Run and awaiting the result)."
  }
]
