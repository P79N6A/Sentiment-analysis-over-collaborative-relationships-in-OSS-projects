[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/152534580",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-152534580",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 152534580,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjUzNDU4MA==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-10-30T14:03:26Z",
    "updated_at": "2015-10-30T14:03:26Z",
    "author_association": "NONE",
    "body": "the crash stack:\n\nGasRunner.exe!abort() 行 88    C\nGasRunner.exe!allocate_completion(grpc_call \\* call) 行 439 C\nGasRunner.exe!finish_batch(grpc_exec_ctx \\* exec_ctx, grpc_call \\* call, int success, void \\* tag) 行 1635    C\nGasRunner.exe!unlock(grpc_exec_ctx \\* exec_ctx, grpc_call \\* call) 行 714    C\nGasRunner.exe!call_on_done_send(grpc_exec_ctx \\* exec_ctx, void \\* pc, int success) 行 894   C\nGasRunner.exe!grpc_exec_ctx_flush(grpc_exec_ctx \\* exec_ctx) 行 50  C\nGasRunner.exe!grpc_exec_ctx_finish(grpc_exec_ctx \\* exec_ctx) 行 60 C\nGasRunner.exe!grpc_call_start_batch(grpc_call \\* call, const grpc_op \\* ops, unsigned int nops, void \\* tag, void \\* reserved) 行 1901 C\nGasRunner.exe!grpc::Server::PerformOpsOnCall(grpc::CallOpSetInterface \\* ops, grpc::Call \\* call) 行 426 C++\nGasRunner.exe!grpc::Call::PerformOps(grpc::CallOpSetInterface \\* ops) 行 89 C++\nGasRunner.exe!grpc::ServerAsyncWriterAsyncFlow::FCRunningStatus::Write(const AsyncFlow::FCRunningStatus & msg, void \\* tag) 行 377    C++\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/152562050",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-152562050",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 152562050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjU2MjA1MA==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-10-30T15:48:18Z",
    "updated_at": "2015-10-30T15:48:18Z",
    "author_association": "NONE",
    "body": "I think the ' grpc_cq_completion completions[MAX_CONCURRENT_COMPLETIONS];'\nwas designed to store some thing like the 'tag'.\nEach call to 'SendInitialMetadata' , 'Write' , 'Finish' ,etc will give the user a chance to set a 'tag'.\nand the storage info will be used later as to do some callback.\nIn sync mode, each 'Write' will deal with the storage info immediately, so can reset them between each 'Write'.\nbut in async mode, if the 'Write' operation was used more than once and with different 'tag'.\nIt can not just store them all with a 'MAX_CONCURRENT_COMPLETIONS' size of space.\nFor most case, the 'tag' passed to 'Write' will be the same?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/152568219",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-152568219",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 152568219,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjU2ODIxOQ==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-10-30T16:10:47Z",
    "updated_at": "2015-10-30T16:10:47Z",
    "author_association": "MEMBER",
    "body": "So for async writes we have a (poorly documented admittedly) contract that\nsays you're only allowed to have one outstanding at a time.\nThis means that you need to wait for the completion to the first write\nbefore starting the next one - grpc doesn't do any internal buffering.\n\nOn Fri, Oct 30, 2015 at 8:48 AM fxrrrr notifications@github.com wrote:\n\n> I think the ' grpc_cq_completion completions[MAX_CONCURRENT_COMPLETIONS];'\n> was designed to store some thing like the 'tag'.\n> Each call to 'SendInitialMetadata' , 'Write' , 'Finish' ,etc will give the\n> user a chance to set a 'tag'.\n> and the storage info will be used later as to do some callback.\n> In sync mode, each 'Write' will deal with the storage info immediately, so\n> can reset them between each 'Write'.\n> but in async mode, if the 'Write' operation was used more than once and\n> with different 'tag'.\n> It can not just store them all with a 'MAX_CONCURRENT_COMPLETIONS' size of\n> space.\n> For most case, the 'tag' passed to 'Write' will be the same?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/grpc/grpc/issues/4007#issuecomment-152562050.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/152682130",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-152682130",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 152682130,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MjY4MjEzMA==",
    "user": {
      "login": "fxrrrr",
      "id": 11402429,
      "node_id": "MDQ6VXNlcjExNDAyNDI5",
      "avatar_url": "https://avatars1.githubusercontent.com/u/11402429?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fxrrrr",
      "html_url": "https://github.com/fxrrrr",
      "followers_url": "https://api.github.com/users/fxrrrr/followers",
      "following_url": "https://api.github.com/users/fxrrrr/following{/other_user}",
      "gists_url": "https://api.github.com/users/fxrrrr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fxrrrr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fxrrrr/subscriptions",
      "organizations_url": "https://api.github.com/users/fxrrrr/orgs",
      "repos_url": "https://api.github.com/users/fxrrrr/repos",
      "events_url": "https://api.github.com/users/fxrrrr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fxrrrr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-10-31T01:04:20Z",
    "updated_at": "2015-10-31T11:57:12Z",
    "author_association": "NONE",
    "body": "So what should i do exactly after each write? Call 'cq_.AsyncNext'?  \nbtw, I find that before the crash, the message was indeed sended(in tcp_window.c), the client recv all the writed messages.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/153529204",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-153529204",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 153529204,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1MzUyOTIwNA==",
    "user": {
      "login": "hsaliak",
      "id": 150108,
      "node_id": "MDQ6VXNlcjE1MDEwOA==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/150108?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/hsaliak",
      "html_url": "https://github.com/hsaliak",
      "followers_url": "https://api.github.com/users/hsaliak/followers",
      "following_url": "https://api.github.com/users/hsaliak/following{/other_user}",
      "gists_url": "https://api.github.com/users/hsaliak/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/hsaliak/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/hsaliak/subscriptions",
      "organizations_url": "https://api.github.com/users/hsaliak/orgs",
      "repos_url": "https://api.github.com/users/hsaliak/repos",
      "events_url": "https://api.github.com/users/hsaliak/events{/privacy}",
      "received_events_url": "https://api.github.com/users/hsaliak/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-11-04T00:03:14Z",
    "updated_at": "2015-11-04T00:03:14Z",
    "author_association": "MEMBER",
    "body": "@ctiller is there any documentation updates need to make?\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/193232989",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-193232989",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 193232989,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE5MzIzMjk4OQ==",
    "user": {
      "login": "joostmeijles",
      "id": 4342282,
      "node_id": "MDQ6VXNlcjQzNDIyODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/4342282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/joostmeijles",
      "html_url": "https://github.com/joostmeijles",
      "followers_url": "https://api.github.com/users/joostmeijles/followers",
      "following_url": "https://api.github.com/users/joostmeijles/following{/other_user}",
      "gists_url": "https://api.github.com/users/joostmeijles/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/joostmeijles/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/joostmeijles/subscriptions",
      "organizations_url": "https://api.github.com/users/joostmeijles/orgs",
      "repos_url": "https://api.github.com/users/joostmeijles/repos",
      "events_url": "https://api.github.com/users/joostmeijles/events{/privacy}",
      "received_events_url": "https://api.github.com/users/joostmeijles/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-03-07T12:37:06Z",
    "updated_at": "2016-03-25T13:14:44Z",
    "author_association": "NONE",
    "body": "I have a gRPC Server instance that serves multiple streaming clients using a shared completion queue.\nWhen messages get written to the clients (using `grpc::ServerAsyncWriter<T>::Writer` call) shortly after each other I get an assertion error:\n`E0307 11:54:41.724590260    5917 server.cc:442]              assertion failed: GRPC_CALL_OK == result`\n\nThe result variable contains the following value:\n`/** there is already an outstanding read/write operation on the call */\n  GRPC_CALL_ERROR_TOO_MANY_OPERATIONS,`\n\nIs this the same problem as described in this issue?\nIf so, this seems to be a show-stopper to me, as I imagine that synchronously writing messages to an asynchronous stream seems to be basic required functionality?\n\nWhat would be the workaround? For example, how do I determine that there is an outstanding message to send?\n\n# \n\nI overlooked the description in the API for the AsyncWriterInterface where it states:\n\n> Only one write may be outstanding at any given time. This means that after calling Write, one must wait to receive tag from the completion queue BEFORE calling Write again.\n\nCorrectly using the Write(), only writing the next message when the current outstanding message write completed, solves my issue.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/218630675",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-218630675",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 218630675,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODYzMDY3NQ==",
    "user": {
      "login": "a-teammate",
      "id": 7704407,
      "node_id": "MDQ6VXNlcjc3MDQ0MDc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/7704407?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/a-teammate",
      "html_url": "https://github.com/a-teammate",
      "followers_url": "https://api.github.com/users/a-teammate/followers",
      "following_url": "https://api.github.com/users/a-teammate/following{/other_user}",
      "gists_url": "https://api.github.com/users/a-teammate/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/a-teammate/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/a-teammate/subscriptions",
      "organizations_url": "https://api.github.com/users/a-teammate/orgs",
      "repos_url": "https://api.github.com/users/a-teammate/repos",
      "events_url": "https://api.github.com/users/a-teammate/events{/privacy}",
      "received_events_url": "https://api.github.com/users/a-teammate/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-12T00:44:33Z",
    "updated_at": "2016-05-12T12:21:32Z",
    "author_association": "NONE",
    "body": "@ctiller why has this been closed?\n\nIm asking bc i dont understand whats the use case for an async call which always needs a blocking procedure directly afterwards..\n\nOnly usage i can imagine is when a lot of other blocking work needs to be done on your current thread and networking is really low priority ( `for(;;) { Write(); /*do blocking work*/ cq->Next();}`).\n\nOtherwise I'd assume one usually wants to do the blocking work (completionqueue->Next()) in a background thread, and call the async->Write() in the current one (which needs to be nonblocking).\n\nHowever with only one Write() allowed this would mean we would need some kind of manual syncing again between those threads.\nSo what will people do?  \nI'd guess usually youd grab some kind of (lockless or threadsafe) queue (maybe even FIFO if thats important for the use case) and just put writedata into it in your important thread and in a background thread you deque it and feed the rpc connection.  And it would look like `async->Write(Data); completionqueue->Next();` in the background thread, but then theres no point in using the async call, or is it?\n\n(And since theres already a queue inside grpc, why dont hide it and allow multiple Write() calls?)\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/218814326",
    "html_url": "https://github.com/grpc/grpc/issues/4007#issuecomment-218814326",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/4007",
    "id": 218814326,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODgxNDMyNg==",
    "user": {
      "login": "ctiller",
      "id": 10120821,
      "node_id": "MDQ6VXNlcjEwMTIwODIx",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10120821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctiller",
      "html_url": "https://github.com/ctiller",
      "followers_url": "https://api.github.com/users/ctiller/followers",
      "following_url": "https://api.github.com/users/ctiller/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctiller/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctiller/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctiller/subscriptions",
      "organizations_url": "https://api.github.com/users/ctiller/orgs",
      "repos_url": "https://api.github.com/users/ctiller/repos",
      "events_url": "https://api.github.com/users/ctiller/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctiller/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-12T16:39:03Z",
    "updated_at": "2016-05-12T16:39:03Z",
    "author_association": "MEMBER",
    "body": "So it was closed because there's no bug here, and I'd prefer not to have\nissues open for things that aren't.\n\nIt probably warrants some design notes though, so here goes:\n\nWe allow only one write at a time to ensure there's an avenue for providing\npushback against applications. Not doing so (by introducing a queue)\ndefeats flow control and we have good data that says that that will lead to\napplications OOMing themselves - and having no way available to fix it.\n\nThere are two patterns for using the async API that seem to be relatively\ncommon.\n\nThe first is having a set of threads running against one or more completion\nqueues in a server. All server work is performed in these threads: when a\nrequest comes in, any work it needs to do is performed asynchronously, with\na state machine driving which calls to make. Here, the tags passed to the\ncompletion queue are frequently some closure object (std::function<void()>*\nfor instance) that records how to progress the state machine when the\noperation completes.\n\nThe second is when fanning out a request to multiple back-ends in a\nsynchronous API server. In this case an incoming request might trigger many\nsub-requests before it can be completed. Each sub-request is made\nasynchronously, and the overall request thread blocks until all completions\nhave been drained from the completion queue created to service _only that_\nrequest.\n\nOn Wed, May 11, 2016 at 5:44 PM Malte H notifications@github.com wrote:\n\n> @ctiller https://github.com/ctiller why was this closed?\n> \n> Im asking bc i dont understand whats the use case for an async call which\n> always needs a blocking procedure directly afterwards..\n> \n> Only usage i can imagine is when a lot of other blocking work needs to be\n> done on your current thread and networking is really low priority ( for(;;)\n> { Write(); /_do blocking work_/ cq->Next();}).\n> \n> Otherwise I'd assume one usually wants to do the blocking work\n> (completionqueue->Next()) in a background thread, and call the\n> async->Write() in the current one (which needs to be nonblocking).\n> \n> However with only one Write() allowed this would mean we would need some\n> kind of manual syncing again between those threads.\n> So what will people do?\n> \n> I'd guess usually youd grab some kind of (lockless or threadsafe) queue\n> (maybe even FIFO if thats important for the use case) and just put\n> writedata into it in your important thread and in a background thread you\n> enque it and feed the rpc connection. And it would look like async->Write(Data);\n> completionque->Next(); in the background thread, but then theres no point\n> in using the async call, or is it?\n> \n> (And since theres already a queue inside grpc, why dont hide it and allow\n> multiple Write() calls?)\n> \n> —\n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly or view it on GitHub\n> https://github.com/grpc/grpc/issues/4007#issuecomment-218630675\n"
  }
]
