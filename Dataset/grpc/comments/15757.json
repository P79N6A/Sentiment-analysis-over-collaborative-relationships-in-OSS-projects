[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/397517880",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-397517880",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 397517880,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NzUxNzg4MA==",
    "user": {
      "login": "eschgi",
      "id": 30392867,
      "node_id": "MDQ6VXNlcjMwMzkyODY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/30392867?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eschgi",
      "html_url": "https://github.com/eschgi",
      "followers_url": "https://api.github.com/users/eschgi/followers",
      "following_url": "https://api.github.com/users/eschgi/following{/other_user}",
      "gists_url": "https://api.github.com/users/eschgi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eschgi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eschgi/subscriptions",
      "organizations_url": "https://api.github.com/users/eschgi/orgs",
      "repos_url": "https://api.github.com/users/eschgi/repos",
      "events_url": "https://api.github.com/users/eschgi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eschgi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-15T05:30:41Z",
    "updated_at": "2018-06-15T05:30:41Z",
    "author_association": "NONE",
    "body": "+1"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/423878828",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-423878828",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 423878828,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzg3ODgyOA==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-24T05:18:25Z",
    "updated_at": "2018-09-24T05:18:54Z",
    "author_association": "NONE",
    "body": "Yeah, either a copy constructor on the ServerCallContext or some sort of \"view bag\"-like functionality on it would help a lot not just with schlepping the service provider around, but possibly other things like user identity, etc.\r\n\r\nWould you accept a PR for this (and by this I'm referring to the copy constructor as it's super-trivial and the least intrusive of the two options, plus it's not going to change the public API much at all)?\r\n\r\nBy the way, @dpsenner I think it's better to use a trailer + lowercase metadata key (gRPC lowercases everything anyway) as request headers are not guaranteed to be there. You do have to clean the trailers up afterwards, though, so that's not so nice."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/423889659",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-423889659",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 423889659,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzg4OTY1OQ==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-24T06:58:08Z",
    "updated_at": "2018-09-24T07:19:16Z",
    "author_association": "NONE",
    "body": "We chose to inject the service provider in the metadata headers because:\r\n\r\n1. we prefix the service provider header key with a prefix that should never fly in from a request\r\n1. we would have to clean up the trailers if we did inject the service provider there, creating yet another point of failure\r\n1. if request headers are not present, we create them on the fly\r\n1. if the meta-data is already present the application code ignores that element and picks the one that matches the type\r\n1. the application does not look at that metadata header in any other way (i.e. it does not copy-return it in the trailers)\r\n\r\nThis work around gets the job done for our functional requirements. Despite that, it is a hack that only exists because it works and is the only solution we could come up with.\r\n\r\n@cearny I do not grasp how a copy constructor would help if a middleware creates the service provider by calling `ServiceProvider.CreateScope()`. There's no way to override the `ServerCallContext` instance of a request, is there? Would you please explain your thoughts?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/423911206",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-423911206",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 423911206,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzkxMTIwNg==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-24T08:52:15Z",
    "updated_at": "2018-09-24T09:02:09Z",
    "author_association": "NONE",
    "body": "@dpsenner as I see it, looking at the `ServerCallContext` sources, there is no way to be sure that `RequestHeaders` is null or not -- and I see no way of setting it if it is, as it's getter-only. Am I missing something?\r\n\r\nThe \"trailers\" thing is precisely the same hack that works that you made, only since the trailers are instantiated by default, they're never null and what we're using is something like:\r\n\r\n```\r\ntry\r\n{\r\n    return await base.UnaryServerHandler(request, context, continuation);\r\n}\r\nfinally\r\n{\r\n    // Clean up after ourselves, we don't want to send that (empty) trailer to the client\r\n    context.ResponseTrailers.Remove(metadata);\r\n}\r\n```\r\n\r\nSo they should get cleaned up properly (given that the `finally` block works as I expect it to). But, again as you've mentioned, this is just a working hack.\r\n\r\n**As for the benefits of having a copy constructor on `ServiceCallContext`**, it would allow us to write something like:\r\n\r\n```\r\npublic class ScopeAwareServiceCallContext \r\n{\r\n    public IServiceScope ServiceScope { get; }\r\n\r\n    public ScopeAwareServiceCallContext(IServiceScope serviceScope, ServiceCallContext originalContext)\r\n        : base(originalContext) \r\n    {\r\n        ServiceScope = _serviceScope ?? throw new ArgumentNullException(nameof(serviceScope));\r\n    }\r\n}\r\n```\r\n\r\nAnd in the interceptor we could write something like:\r\n\r\n```\r\nvar scopeAwareContext = new ScopeAwareServiceCallContext(serviceScope, context);\r\nreturn await base.UnaryServerHandler(request, scopeAwareContext, continuation);\r\n```\r\n\r\nSo, a riff on the decorator pattern, really.\r\n\r\nAdd to this an extension method on `ServiceCallContext` to try and extract the service scope, similarly to what you've written but in this case just trying to cast to `ScopeAwareServiceCallContext` instead of iterating on the headers, and you could have most of what you need:\r\n\r\n```\r\npublic static class ServerCallContextDependencyInjectionExtensions\r\n{\r\n    public static IServiceProvider GetScopedServiceProvider(this ServerCallContext context)\r\n    {\r\n        if (context == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(context));\r\n        }\r\n\r\n        if (context is ScopeAwareServiceCallContext scopeAwareContext)\r\n        {\r\n            return scopeAwareContext.ServiceScope.ServiceProvider;\r\n        }\r\n\r\n        throw new ArgumentException(nameof(context));\r\n    }\r\n}\r\n```\r\n\r\nIdeally I'd like to have some sort of \"context metadata\" that one could add whatever one needs to (sort of like a view bag, as I've mentioned), but -- having a copy constructor on the (non-sealed!) `ServerCallContext` class -- all this could be solved just with extension methods. No new fields on the original `ServerCallContext` would need to be introduced. Neat & tidy -- I think.\r\n\r\nThis will quickly blow up if multiple interceptors each \"swap\" the server call context, but that's something that I can live with."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/423918703",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-423918703",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 423918703,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMzkxODcwMw==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-24T09:25:50Z",
    "updated_at": "2018-09-24T09:26:12Z",
    "author_association": "NONE",
    "body": "By the way, I've looked at just copying everything from the initial `ServerCallContext`, but the field `callHandle` is not available and marked as private ; I assume this gets into the low-level C interop plumbing code and there's a good reason it's not simply available, but it's also a blocker for writing a derived class."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/424474313",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-424474313",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 424474313,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDQ3NDMxMw==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-25T19:39:12Z",
    "updated_at": "2018-09-25T19:39:12Z",
    "author_association": "NONE",
    "body": "Now I get your idea of the copy ctor. That could work. I rather thought of replacing `ServerCallContext` with `IServiceProvider` and let the grpc internals look up the original `ServerCallContext` by invocation of `serviceProvider.GetRequiredService<ServerCallContext>()` . A developer could wrap the service provider without even having to know about the `ServerCallContext` existence.\r\n\r\nA wrapping interceptor that does nothing would then look like:\r\n\r\n```csharp\r\npublic override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(TRequest request, IServiceProvider serviceProvider, UnaryServerMethod<TRequest, TResponse> continuation)\r\n{\r\n    return await base.UnaryServerHandler(request, serviceProvider, continuation);\r\n}\r\n```\r\n\r\nAnd another one that adds a scope could look like:\r\n\r\n```csharp\r\npublic override async Task<TResponse> UnaryServerHandler<TRequest, TResponse>(TRequest request, IServiceProvider serviceProvider, UnaryServerMethod<TRequest, TResponse> continuation)\r\n{\r\n    using (var serviceScope = ServiceProvider.CreateScope())\r\n    {\r\n        return await base.UnaryServerHandler(request, serviceProvider, continuation);\r\n    }\r\n}\r\n```\r\n\r\nThis means that dependency injection becomes a integrated component of the grpc csharp implementation."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/424953347",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-424953347",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 424953347,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNDk1MzM0Nw==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T04:13:37Z",
    "updated_at": "2018-09-27T04:13:37Z",
    "author_association": "NONE",
    "body": "That would work neatly, yes.\r\n\r\nThough I've had a discussion on this topic with a colleague and the end result of that was that we both agreed this would tie \"out-of-the-box\" gRPC to Microsoft's own DI container way too much, making it an intrusive change. The point being that some people use Autofac, Ninject, etc.\r\n\r\nUntil we'll have something like per-scope metadata separated from headers and trailers, which could enable most any sort of customization, I can live with the most minimal change to the gRPC codebase, which would be a copy constructor."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/425914818",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-425914818",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 425914818,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTkxNDgxOA==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-01T13:50:09Z",
    "updated_at": "2018-10-01T13:50:09Z",
    "author_association": "NONE",
    "body": "It's great news that you are considering this addition as a team!\r\n\r\nIf portability and interopability is a concern, then grpc could come with it's own dependency \r\n injection interface. All that interface has to define is a method signature `object GetService(Type t)`. It is straight forward to implement adapters from [microsoft DI, ninject, autofac] to grpc di. I however have to insist that it is a tedious task to reinvent an existing wheel. That's just yet another api to the same requirements.\r\n\r\n[This link](https://docs.microsoft.com/en-us/dotnet/api/system.iserviceprovider?view=netframework-4.7.2) points the documentation of the IServiceProvider interface, note the \"Applies to\" section.\r\n\r\nFurther [this link](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.requestservices?view=aspnetcore-2.1#Microsoft_AspNetCore_Http_HttpContext_RequestServices) points to a property how the asp net core devs implemented a way to access a request-scoped serviceprovider. Adding this (or something like this) to the ServerCallContext could be an option that's backwards compatible."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/425954927",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-425954927",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 425954927,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTk1NDkyNw==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-01T15:39:52Z",
    "updated_at": "2018-10-01T15:47:30Z",
    "author_association": "NONE",
    "body": "Hm, the thing is that I don't really want to see gRPC as \"just a sort of ASP.NET Core\", convenient as that might be. I feel like it should focus on what it does specifically and provide extension endpoints where more is required of it. This may be because I'm coming to it from with more of an Express.js mindset, to give my opinions some context.\r\n\r\nI've taken a look at maybe adding a service provider to the `ServerCallContext` class and it would be quite awkward to do it directly right now, as it is only created via `HandlerUtils.NewContext`, which is called directly in the `HandleCall`s of `ClientStreamingServerCallHandler`, `DuplexStreamingServerCallHandler`, `ServerStreamingServerCallHandler` and `UnaryServerCallHandler`. Shipping a service provider to those would mean either having some sort of static master-class (like the `Logger`, something that I don't really like already) or quite a lot of rework. Not sure _I, at least_ would be able to tackle _that_ task.\r\n\r\nI still feel like just being able to swap the server call context with a sub-class that is able to provide a service provider using an interceptor (sort of like the interceptor already does with `InterceptingCallInvoker` on the client side) would be the path of least resistance. Also, maybe adding a \"view-bag\" of sorts on the server call context :-)"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/426210769",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-426210769",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 426210769,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNjIxMDc2OQ==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-10-02T09:34:51Z",
    "updated_at": "2018-10-02T09:34:51Z",
    "author_association": "NONE",
    "body": "I like the idea that grpc allows injecting arbitrary data into the methods that process requests and allowing the interceptors to manipulate that arbitrary data. After all that is what dependency injection is about.\r\n\r\nThis solution is similar to what we hacked with the custom meta data header. It is just bad to abuse request headers for details that matter only to the server side implementation and, as pointed out earlier, there's no functional requirement to make use of any existing dependency injection framework. From this point of view it is better that grpc is standalone, not depending on any other framework but netstandard."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/445053226",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-445053226",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 445053226,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NTA1MzIyNg==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-06T22:28:49Z",
    "updated_at": "2018-12-06T22:44:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've run into the need to pass state between interceptors and call handlers myself. The state that I have is more than just an `IServiceProvider`, however.\r\n\r\nI'd be happy to contribute either\r\n\r\n1. \"view-bag\" on `ServerCallContext` or\r\n1. unsealing `ServerCallContext` or adding an `IServerCallContext` interface\r\n\r\nWould such a PR be accepted?\r\n\r\nFor the view-bag, my initial proposal is to add mutable property to server call context:\r\n\r\n```csharp\r\n/// <summary>Arbitrary state object associated with the call.</summary>\r\n/// <remarks>\r\n/// The gRPC library doesn't inspect or set this value. Your interceptors\r\n/// and call handlers can use it how they see fit.\r\n/// </remarks>\r\npublic object UserState { get; set; }\r\n```\r\n\r\nThe view-bag is very simple to implement and is a pattern seen across various APIs in various languages and platforms (`void*` parameters on gRPC completion queues anyone? :smile:).\r\n\r\nThis could be extended to a `Dictionary<string, object>`. I believe this was considered during the initial C# interceptor development and rejected. Don't quite remember the details... Synchronization issues, maybe?\r\n\r\nIn any case, both a view-bag, subclass, or `IServerCallContext` approach would require collaboration between interceptors & call handlers and a cast from object/base. So, all these approaches basically have the same shape, so I'll defer to the library maintainers on which particular shape they want."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/445055122",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-445055122",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 445055122,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NTA1NTEyMg==",
    "user": {
      "login": "chwarr",
      "id": 10605667,
      "node_id": "MDQ6VXNlcjEwNjA1NjY3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10605667?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chwarr",
      "html_url": "https://github.com/chwarr",
      "followers_url": "https://api.github.com/users/chwarr/followers",
      "following_url": "https://api.github.com/users/chwarr/following{/other_user}",
      "gists_url": "https://api.github.com/users/chwarr/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chwarr/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chwarr/subscriptions",
      "organizations_url": "https://api.github.com/users/chwarr/orgs",
      "repos_url": "https://api.github.com/users/chwarr/repos",
      "events_url": "https://api.github.com/users/chwarr/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chwarr/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-06T22:35:45Z",
    "updated_at": "2018-12-06T22:35:45Z",
    "author_association": "CONTRIBUTOR",
    "body": "@dpsenner I am currently tunneling the `IServiceProvider` into the call handler with a similar interceptor. Instead of using a header, I use an [`AsyncLocal<IServiceProvider>`](https://docs.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=netcore-1.0):\r\n\r\n```csharp\r\npublic static class ServerCallContextExtensions\r\n{\r\n    internal static AsyncLocal<IServiceProvider> ServiceProviderInstance { get; set; } = new AsyncLocal<IServiceProvider>();\r\n\r\n    public static IServiceProvider ServiceProvider(this ServerCallContext _)\r\n    {\r\n        return ServiceProviderInstance.Value;\r\n    }\r\n}\r\n\r\n// In the same assembly as ServerCallContextExtensions so it can access the internal field\r\npublic StartScopeInterceptor : Interceptor\r\n{\r\n    private readonly IServiceProvider _services;\r\n\r\n    public StartScopeInterceptor(IServiceProvider services)\r\n    {\r\n        _services = services ?? throw ArgumentNullException(nameof(services));\r\n    }\r\n\r\n    public override async Task<TResponse> ClientStreamingServerHandler<TRequest, TResponse>(\r\n        IAsyncStreamReader<TRequest> requestStream,\r\n        ServerCallContext context,\r\n        ClientStreamingServerMethod<TRequest, TResponse> continuation)\r\n    {\r\n        using (var scope = _services.CreateScope())\r\n        {\r\n            ServerCallContextExtensions.ServiceProviderInstance.Value = scope.ServiceProvider;\r\n            try\r\n            {\r\n                return await continuation(requestStream, context);\r\n            }\r\n            finally\r\n            {\r\n                ServerCallContextExtensions.ServiceProviderInstance.Value = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ...\r\n}\r\n\r\npublic ServiceImpl : TheService.TheServiceBase\r\n{\r\n    public override async Task<TheResponse> TheMethod(TheRequest request, ServerCallContext context)\r\n    {\r\n        IServiceProvider sp = context.ServiceProvider();\r\n        // ...\r\n    }\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/445133266",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-445133266",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 445133266,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ0NTEzMzI2Ng==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-12-07T06:09:17Z",
    "updated_at": "2018-12-07T06:09:17Z",
    "author_association": "NONE",
    "body": "@chwarr yeah, `AsyncLocal` and extension methods look like the least-intrusive and \"nicest\" option ATM and `AsyncLocal` is used for this in a few other places -- the zipkin4net library uses a similar concept, for example, and that's how we added instrumentation for StackExchange.Redis.\r\n\r\nInteresting info regarding the team possibly having considered a `Dictionary` at one point, by the way 👍 I guess a `ConcurrentDictionary` could be used instead in case synchronization issues were a thing. But if an object is provided, then any library consumer could decide what they actually need.\r\n\r\nI've actually had this lying around for a while now but never got around to actually running the test suite locally (to formally check that it doesn't break anything -- it really shouldn't though): https://github.com/cearny/grpc/commit/91bc5d6272e408372c5465552e452e4316af2cb9"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/469308736",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-469308736",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 469308736,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTMwODczNg==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-04T16:05:29Z",
    "updated_at": "2019-03-04T16:05:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "Looks like the use case has been sufficiently covered by https://github.com/grpc/grpc/pull/18086?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/469632153",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-469632153",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 469632153,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTYzMjE1Mw==",
    "user": {
      "login": "cearny",
      "id": 1176043,
      "node_id": "MDQ6VXNlcjExNzYwNDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1176043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cearny",
      "html_url": "https://github.com/cearny",
      "followers_url": "https://api.github.com/users/cearny/followers",
      "following_url": "https://api.github.com/users/cearny/following{/other_user}",
      "gists_url": "https://api.github.com/users/cearny/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cearny/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cearny/subscriptions",
      "organizations_url": "https://api.github.com/users/cearny/orgs",
      "repos_url": "https://api.github.com/users/cearny/repos",
      "events_url": "https://api.github.com/users/cearny/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cearny/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-05T10:42:15Z",
    "updated_at": "2019-03-05T10:42:15Z",
    "author_association": "NONE",
    "body": "That woks handsomely for me!"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/469990641",
    "html_url": "https://github.com/grpc/grpc/issues/15757#issuecomment-469990641",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/15757",
    "id": 469990641,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2OTk5MDY0MQ==",
    "user": {
      "login": "dpsenner",
      "id": 8520682,
      "node_id": "MDQ6VXNlcjg1MjA2ODI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8520682?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dpsenner",
      "html_url": "https://github.com/dpsenner",
      "followers_url": "https://api.github.com/users/dpsenner/followers",
      "following_url": "https://api.github.com/users/dpsenner/following{/other_user}",
      "gists_url": "https://api.github.com/users/dpsenner/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dpsenner/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dpsenner/subscriptions",
      "organizations_url": "https://api.github.com/users/dpsenner/orgs",
      "repos_url": "https://api.github.com/users/dpsenner/repos",
      "events_url": "https://api.github.com/users/dpsenner/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dpsenner/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-06T06:50:45Z",
    "updated_at": "2019-03-06T06:50:45Z",
    "author_association": "NONE",
    "body": "Great news that this issue was fixed, thanks!"
  }
]
