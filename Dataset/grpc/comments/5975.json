[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/216427158",
    "html_url": "https://github.com/grpc/grpc/issues/5975#issuecomment-216427158",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5975",
    "id": 216427158,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjQyNzE1OA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-03T03:28:28Z",
    "updated_at": "2016-05-03T03:28:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for filing this, your explanation makes sense. Here's a few followup questions:\n1. What should WriteAsync(msg) throw if the call has already finished with StatusCode.OK?   One option is to throw new RpcException(new Status(StatusCode.OK, \"\")), that's a bit counterintuitive, because we are throwing for StatusCode.OK. On the other hand, this approach is consistent with throwing RpcException whenever we try to write to a call that has already finished. Another options is to throw just InvalidOperationException  (and throw RpcException of all non-ok status codes) - which actually sounds even more odd.\n2. Another thing that can happen is that the call has been canceled (that's either initiated by user calling call.Cancel() or internally when we e.g. fail to parse the incoming protobuf message).  Currently, we are throwing OperationCanceledException after Cancel() has been invoked (both explicitly or implicitly). We can't really throw RpcException immediately after cancel has been requested, because it can take a bit before the call completion with StatusCode.Cancelled is delivered (and in the meantime we would be making up the resulting StatusCode without actually knowing it).  I'm not sure if switching from WriteAsync() throwing OperationCanceledException into throwing RpcException later on makes sense.\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/216427237",
    "html_url": "https://github.com/grpc/grpc/issues/5975#issuecomment-216427237",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5975",
    "id": 216427237,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjQyNzIzNw==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-03T03:29:18Z",
    "updated_at": "2016-05-03T03:29:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jskeet  @chrisdunelm   your opinions are more than welcome!\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/216777223",
    "html_url": "https://github.com/grpc/grpc/issues/5975#issuecomment-216777223",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5975",
    "id": 216777223,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjc3NzIyMw==",
    "user": {
      "login": "jskeet",
      "id": 17011,
      "node_id": "MDQ6VXNlcjE3MDEx",
      "avatar_url": "https://avatars1.githubusercontent.com/u/17011?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jskeet",
      "html_url": "https://github.com/jskeet",
      "followers_url": "https://api.github.com/users/jskeet/followers",
      "following_url": "https://api.github.com/users/jskeet/following{/other_user}",
      "gists_url": "https://api.github.com/users/jskeet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jskeet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jskeet/subscriptions",
      "organizations_url": "https://api.github.com/users/jskeet/orgs",
      "repos_url": "https://api.github.com/users/jskeet/repos",
      "events_url": "https://api.github.com/users/jskeet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jskeet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-04T08:11:25Z",
    "updated_at": "2016-05-04T08:11:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hmm. I'm afraid I don't have any easy answers here. \n\nOne question though - in the case of:\n\n> The server indeed validates every data message sent by the client, and, should the data be hopelessly invalid, closes the call and reports a Status that the client must be able to receive. \n\nThat wouldn't be a status of OK anyway, would it?\n\nWhen are we expecting to:\n- Have a status of OK\n- Have the client continue writing to the stream realistically expecting to still be able to write more data\n\n? Might a client not know how much data it needs to send, and just keep sending things, and eventually the server decide it's got enough? I could see how that could just about make sense in some cases...\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/216985503",
    "html_url": "https://github.com/grpc/grpc/issues/5975#issuecomment-216985503",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/5975",
    "id": 216985503,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxNjk4NTUwMw==",
    "user": {
      "login": "kkm000",
      "id": 8228229,
      "node_id": "MDQ6VXNlcjgyMjgyMjk=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/8228229?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kkm000",
      "html_url": "https://github.com/kkm000",
      "followers_url": "https://api.github.com/users/kkm000/followers",
      "following_url": "https://api.github.com/users/kkm000/following{/other_user}",
      "gists_url": "https://api.github.com/users/kkm000/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kkm000/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kkm000/subscriptions",
      "organizations_url": "https://api.github.com/users/kkm000/orgs",
      "repos_url": "https://api.github.com/users/kkm000/repos",
      "events_url": "https://api.github.com/users/kkm000/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kkm000/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-04T20:05:40Z",
    "updated_at": "2016-05-04T20:06:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jtattermusch: Regarding item 2, the current behavior makes total sense. Call cancellation is client's business, and client's writing to the stream after the very same client has requested cancellation looks like an incorrect behavior to me. `OperationCanceledException` is quite warranted here.\n\nAs for #1, this is rather tough. I think that the scenario (the server interrupts the client's stream and reports `Status.OK`) should be rare; I'm with @jskeet here wondering what would that mean. Maybe the client does not understand the data, but server does? And then the stream is produced on the client that consists of multiple contiguous data items, but the server is interested only in the first one, while the client does not know where the first one ends? That looks like an odd corner case. I would say that throwing an `RpcException` with `Status.OK` is _no more odd_ than the case itself, and would not count as violation of the Principle of Least Surprise.\n"
  }
]
