[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/272427799",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-272427799",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 272427799,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3MjQyNzc5OQ==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-13T12:01:04Z",
    "updated_at": "2017-01-13T12:01:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "https://github.com/grpc/proposal/pull/2/files got me thinking: Maybe we can achieve our goals here, plus the goals of that proposal too, by holding all C ops and only sending them at `autorelease` time? That way, if your client code just sends headers, a message, and closes the requests stream all synchronously (without any pause in between), we'll batch all that together. Same if he just sends headers and the first of many request messages, or when he sends the last message of a stream and closes the stream."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278497527",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-278497527",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 278497527,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODQ5NzUyNw==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-08T23:30:44Z",
    "updated_at": "2017-02-08T23:30:44Z",
    "author_association": "MEMBER",
    "body": "I rewrote the test, hoping to limit the test inside ObjC layer, but it seems a bit intrusive. Not sure if it is okay to do it this way though."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278500588",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-278500588",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 278500588,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODUwMDU4OA==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-08T23:46:49Z",
    "updated_at": "2017-02-08T23:46:49Z",
    "author_association": "MEMBER",
    "body": "Autorelease of different ops are orthogonal. To do what you said I think we will still need to create an op batch somewhere, which inevitably comes back to the question of how to decide the boundary of a batch that can be coalesed (bounded either by a unary call or by user's indication through an interface).\r\n> https://github.com/grpc/proposal/pull/2/files got me thinking: Maybe we can achieve our goals here, plus the goals of that proposal too, by holding all C ops and only sending them at autorelease time? That way, if your client code just sends headers, a message, and closes the requests stream all synchronously (without any pause in between), we'll batch all that together. Same if he just sends headers and the first of many request messages, or when he sends the last message of a stream and closes the stream."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278510192",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-278510192",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 278510192,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODUxMDE5Mg==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-09T00:40:27Z",
    "updated_at": "2017-02-09T00:40:27Z",
    "author_association": "CONTRIBUTOR",
    "body": "The autorelease idea is:\r\n\r\nKeep a batch of \"pending ops\" with a `__weak` reference. Push every op to it, as long as it's compatible with the ones already there. Send all of them and create a new batch object when:\r\n1. An op comes that's incompatible with one already on the batch (e.g. a write when there's already a write pending).\r\n2. The batch object is released by the system (which should happen every iteration of the run loop, if the idea works - see http://stackoverflow.com/questions/5192308/objective-c-autorelease-memory-management ).\r\n\r\nThe trick would be that our batch object survives our returning execution to the user, even if we only have a weak reference to it, because the autorelease pool hasn't still drained. But the pool will drain as soon as the user code returns all the way back to the system (for another iteration of the run loop).\r\n\r\nWe'd need to have an `OpBatch` class, in order to override `dealloc` (point 2 above) and to encapsulate the logic of what ops are compatible (point 1)."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278510273",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-278510273",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 278510273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODUxMDI3Mw==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-09T00:40:53Z",
    "updated_at": "2017-02-09T01:26:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "The risk is ARC wanting to fight us. E.g. if it tries to be extra smart and autorelease our batch object as soon as we return from:\r\n```objective-c\r\nsomeMethod {\r\n  ourWeakPointer = [OpBatch batchWithOp:op];\r\n}\r\n```\r\n\r\nI reckon it shouldn't, though?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278797084",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-278797084",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 278797084,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODc5NzA4NA==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-09T22:35:38Z",
    "updated_at": "2017-02-09T22:35:38Z",
    "author_association": "MEMBER",
    "body": "Ha I have no idea on that. Let me try it at least :)"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/278838208",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-278838208",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 278838208,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODgzODIwOA==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-10T02:11:46Z",
    "updated_at": "2017-02-10T02:11:46Z",
    "author_association": "MEMBER",
    "body": "I found I just fully realized a minute ago what you proposed :scream:  Is that something that people actually do and find it works?\r\n\r\nI find a bit uncomfortable about this strategy as we do not have control of when the batch gets released (thus sent). The best guess and most ideal case is that the release happens when it get returned to the run loop, right?. In that case we have no control of what the app layer does and what the delay would be. E.g. suppose the user actually have a self-written event loop there invoking gRPC, in an isolated thread, for some unknown reason. Would that make gRPC not sending out the messages? Or is it possible that there is a `Sleep(4)` after the send? :sweat_smile:"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/279514989",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-279514989",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 279514989,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTUxNDk4OQ==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-13T20:39:25Z",
    "updated_at": "2017-02-13T20:39:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Is that something that people actually do and find it works?\r\n\r\nIt's done at least by the [Core Animation Framework](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/CreatingBasicAnimations/CreatingBasicAnimations.html) (Ctrl-F run loop). And by Google's wrapper over `NSURLSession`. E.g. (from [this documentation](https://github.com/google/gtm-session-fetcher/blob/ade245d57a0d39fb3e4396e350455203b8983293/Source/GTMSessionFetcher.m#L958)):\r\n\r\n> In real fetches, nothing happens until the run loop spins, so apps have leeway to set callbacks after they call `beginFetch`.\r\n\r\nIt's an almost analogous use case: A networking library, that wants to give users the ability to call its methods in a natural way, and only start doing work after the user is done.\r\n\r\nGranted, both of those libraries *almost surely* use a more explicit approach than relying on an object being autoreleased. Core Animation [apparently registers a run loop callback](http://stackoverflow.com/a/15168471/3642676). And `GTMSessionFetcher` probably just sends a block to the run loop. We certainly can do it in a less-magic way too :)\r\n\r\n@ThomasVL, who coauthored `GTMSessionFetcher`: What do you think?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/279518612",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-279518612",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 279518612,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTUxODYxMg==",
    "user": {
      "login": "thomasvl",
      "id": 5279928,
      "node_id": "MDQ6VXNlcjUyNzk5Mjg=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5279928?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/thomasvl",
      "html_url": "https://github.com/thomasvl",
      "followers_url": "https://api.github.com/users/thomasvl/followers",
      "following_url": "https://api.github.com/users/thomasvl/following{/other_user}",
      "gists_url": "https://api.github.com/users/thomasvl/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/thomasvl/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/thomasvl/subscriptions",
      "organizations_url": "https://api.github.com/users/thomasvl/orgs",
      "repos_url": "https://api.github.com/users/thomasvl/repos",
      "events_url": "https://api.github.com/users/thomasvl/events{/privacy}",
      "received_events_url": "https://api.github.com/users/thomasvl/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-13T20:53:08Z",
    "updated_at": "2017-02-13T20:53:08Z",
    "author_association": "NONE",
    "body": "Assuming I'm following the question…\r\n\r\nI wouldn't rely on doing things when the object is released.  All it takes is someone layering something on top (tracking pend operations, writing them out for logging as they send them, etc), and suddenly they do go out at all when expected.  In the logging example, you can even imagine that sort of a sub system queueing things up on a low priority i/o thread, and suddenly the networking is somewhat hosed because they did something else personally reasonable.\r\n\r\nAs far as generally delaying to a runloop, again, I wouldn't do this without opt in from the calling code.  You don't really know what the calling code needs, say they are firing off requests to do some sort of auto complete input field.  That extra delay for the runloop counts and leads to a poor experience.\r\n\r\nSo any sort of delay/batching is fine, but it needs controls exposed to the developer so they can opt in/out as needed.  It doesn't have to require both types of knobs, but if the default is delay/batch, you likely need a way to explicitly say _send now/immediately_, or you need the default to be not delay, but have some operation to _open/close_ the batch so the developer has a deterministic time around that.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/279621037",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-279621037",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 279621037,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTYyMTAzNw==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-14T06:37:27Z",
    "updated_at": "2017-02-14T06:41:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "This object would be private and not returned to the user in any way, so no one else would add references to it. But it would be an unnecessary invariant to have to maintain inside a class that already does a lot of things. And too indirect and implicit, when it can be accomplished more easily.\r\n\r\n> say they are firing off requests to do some sort of auto complete input field. That extra delay for the runloop counts and leads to a poor experience.\r\n\r\nIsn't the OS, when using `NSURLSession`, holding onto the requests anyway, to batch them so the radio is bursty rather than spiky? AFAIK it won't do it for us, because we use posix sockets, but I always thought of it as a disadvantage rather than a win in latency. Can I make the OS not delay a `NSURLSession` request for any reason?\r\n\r\n> it needs controls exposed to the developer so they can opt in/out as needed.\r\n\r\nHow did you guys expose this in `GTMSessionFetcher` and what are the pros/cons of that way?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/279621460",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-279621460",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 279621460,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTYyMTQ2MA==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-14T06:40:40Z",
    "updated_at": "2017-02-14T06:40:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "@muxi, @makdharma: IIRC, the want to coalesce these ops into a single TCP packet is for latency, right?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/279770456",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-279770456",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 279770456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTc3MDQ1Ng==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-14T17:09:00Z",
    "updated_at": "2017-02-14T17:09:00Z",
    "author_association": "MEMBER",
    "body": "Affirmative. It seems writing things on the network interface is expensive and they prefer to write a big chunk of data together instead of writing small parts separately."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/281542073",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-281542073",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 281542073,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTU0MjA3Mw==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-22T01:47:07Z",
    "updated_at": "2017-02-22T01:47:07Z",
    "author_association": "MEMBER",
    "body": "Let's leave this discussion as a future enhancement and get the current solution rolling. Ping for approval @jcanizales."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/283800172",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-283800172",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 283800172,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MzgwMDE3Mg==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-02T22:16:17Z",
    "updated_at": "2017-03-02T22:16:17Z",
    "author_association": "MEMBER",
    "body": "test this please"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/289601395",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-289601395",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 289601395,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4OTYwMTM5NQ==",
    "user": {
      "login": "jcanizales",
      "id": 5120183,
      "node_id": "MDQ6VXNlcjUxMjAxODM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5120183?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jcanizales",
      "html_url": "https://github.com/jcanizales",
      "followers_url": "https://api.github.com/users/jcanizales/followers",
      "following_url": "https://api.github.com/users/jcanizales/following{/other_user}",
      "gists_url": "https://api.github.com/users/jcanizales/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jcanizales/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jcanizales/subscriptions",
      "organizations_url": "https://api.github.com/users/jcanizales/orgs",
      "repos_url": "https://api.github.com/users/jcanizales/repos",
      "events_url": "https://api.github.com/users/jcanizales/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jcanizales/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-27T22:10:01Z",
    "updated_at": "2017-03-27T22:10:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "Just remember to add a comment explaining this https://github.com/grpc/grpc/pull/9247#discussion_r106548213"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/289843549",
    "html_url": "https://github.com/grpc/grpc/pull/9247#issuecomment-289843549",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/9247",
    "id": 289843549,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4OTg0MzU0OQ==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-28T17:26:25Z",
    "updated_at": "2017-03-28T17:26:25Z",
    "author_association": "MEMBER",
    "body": "Test failure:\r\ngRPC_interop_pull_requests - #9011"
  }
]
