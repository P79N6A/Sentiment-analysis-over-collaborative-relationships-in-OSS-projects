[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/227639870",
    "html_url": "https://github.com/grpc/grpc/issues/6948#issuecomment-227639870",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/6948",
    "id": 227639870,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzYzOTg3MA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-22T04:26:33Z",
    "updated_at": "2016-06-22T04:26:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "Actually, mixing blocking and async operations is generally a bad practice and can lead to deadlocks (and it looks like you are experiencing one).   From async methods, you should use async versions of RPCs.\n\nMore background about how gRPC works:\nThere is a thread pool that is used for handling event continuations. All the continuations for your awaits are scheduled onto that threadpool. Once you are in a method after you've awaited an RPC (GetNameAsync in your example), your code is running on that threadpool. If you then invoke the sync version of an RPC (GetName in your example), you prevent gRPC from scheduling continuations on that thread. If the server happens to need schedule continuations on the same thread to handle that call, you'll see a deadlock, because that thread is blocked by your GetName() invocation.\n\nYou might started seeing this problem after (https://github.com/grpc/grpc/pull/6712) was merged. The PR effectively limits number of threads on which given call can schedule continuations (which decreases latency, but also requires the user to use async/await correctly without mixing).\n\nAs as workaround, you can try setting `GrpcEnvironment.SetCompletionQueueCount(1)` that way, continuations will be allowed to run on any thread in gRPC's thread pool.\nhttps://github.com/grpc/grpc/blob/master/src/csharp/Grpc.Core/GrpcEnvironment.cs#L227\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/227660936",
    "html_url": "https://github.com/grpc/grpc/issues/6948#issuecomment-227660936",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/6948",
    "id": 227660936,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzY2MDkzNg==",
    "user": {
      "login": "Falco20019",
      "id": 940619,
      "node_id": "MDQ6VXNlcjk0MDYxOQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/940619?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Falco20019",
      "html_url": "https://github.com/Falco20019",
      "followers_url": "https://api.github.com/users/Falco20019/followers",
      "following_url": "https://api.github.com/users/Falco20019/following{/other_user}",
      "gists_url": "https://api.github.com/users/Falco20019/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Falco20019/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Falco20019/subscriptions",
      "organizations_url": "https://api.github.com/users/Falco20019/orgs",
      "repos_url": "https://api.github.com/users/Falco20019/repos",
      "events_url": "https://api.github.com/users/Falco20019/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Falco20019/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-22T07:06:57Z",
    "updated_at": "2016-06-22T13:53:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Ah, thanks for the clarification! I won't workaround it since it is not relevant for production in this case. But still good to know for when partially migrating a synchronous code base step by step! I was only doing some tests of the different calls and made the whole method async for this purpose.\n\nSo if I understood correctly, you can mix sync and async inside a project without problems, as long as you don't mix it inside a (async) method, right?\n\nPS: Sorry for bothering you with this, should have asked in the Google Group. At least I learned some things about async coding :)\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/227664314",
    "html_url": "https://github.com/grpc/grpc/issues/6948#issuecomment-227664314",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/6948",
    "id": 227664314,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyNzY2NDMxNA==",
    "user": {
      "login": "jtattermusch",
      "id": 9939684,
      "node_id": "MDQ6VXNlcjk5Mzk2ODQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/9939684?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jtattermusch",
      "html_url": "https://github.com/jtattermusch",
      "followers_url": "https://api.github.com/users/jtattermusch/followers",
      "following_url": "https://api.github.com/users/jtattermusch/following{/other_user}",
      "gists_url": "https://api.github.com/users/jtattermusch/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jtattermusch/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jtattermusch/subscriptions",
      "organizations_url": "https://api.github.com/users/jtattermusch/orgs",
      "repos_url": "https://api.github.com/users/jtattermusch/repos",
      "events_url": "https://api.github.com/users/jtattermusch/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jtattermusch/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-06-22T07:26:23Z",
    "updated_at": "2016-06-22T07:26:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "It is hard to formulate general guideline around mixing sync/async methods, but basically:\n1. try not to do that unless you know what you are doing\n2. when using sync methods make sure you either have a dedicated thread (e.g. application main thread or some other thread that is not shared by any other activity at given point in time). Be sure you are not running blocking operations on threads that are used for processing async events.\n3. when in async context, only use async methods\n\nthere should be plenty of blogposts available on this topic. e.g.\nhttp://blog.stephencleary.com/2012/07/dont-block-on-async-code.html\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/271428211",
    "html_url": "https://github.com/grpc/grpc/issues/6948#issuecomment-271428211",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/6948",
    "id": 271428211,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3MTQyODIxMQ==",
    "user": {
      "login": "NGNeer",
      "id": 10360342,
      "node_id": "MDQ6VXNlcjEwMzYwMzQy",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10360342?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/NGNeer",
      "html_url": "https://github.com/NGNeer",
      "followers_url": "https://api.github.com/users/NGNeer/followers",
      "following_url": "https://api.github.com/users/NGNeer/following{/other_user}",
      "gists_url": "https://api.github.com/users/NGNeer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/NGNeer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/NGNeer/subscriptions",
      "organizations_url": "https://api.github.com/users/NGNeer/orgs",
      "repos_url": "https://api.github.com/users/NGNeer/repos",
      "events_url": "https://api.github.com/users/NGNeer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/NGNeer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-09T22:28:50Z",
    "updated_at": "2017-01-09T22:28:50Z",
    "author_association": "NONE",
    "body": "In a related matter, the C# example of RouteGuideClient can be downright misleading. It does a Wait() on the tasks returned by the asynchronous methods, thereby blocking on them. This can be catastrophic if the code is brought into a multi-threaded Windows application and executed on the UI thread."
  }
]
