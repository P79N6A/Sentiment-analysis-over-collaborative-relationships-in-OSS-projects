[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/362006113",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-362006113",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 362006113,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjAwNjExMw==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-31T17:23:42Z",
    "updated_at": "2018-01-31T17:23:42Z",
    "author_association": "MEMBER",
    "body": "So when WiFi network disconnects on iOS, we call `grpc_channel_destroy()`, which calls `start_transport_op()` with a `disconnect_with_error`. \r\n\r\nThe expectation is that we reach https://github.com/grpc/grpc/blob/master/src/core/ext/transport/chttp2/transport/chttp2_transport.cc#L1761 and eventually `end_all_the_calls()`.\r\n\r\nBut we never go through that path. Instead, `start_transport_op()` in the client channel will unref `disconnect_with_error` at https://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/client_channel.cc#L667\r\n\r\n@markdroth I'm wondering whether /how `disconnect_with_error` is passed down and trigger `end_all_the_calls()`.\r\n\r\nCC @y-zeng "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/362086001",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-362086001",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 362086001,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjA4NjAwMQ==",
    "user": {
      "login": "markdroth",
      "id": 18664614,
      "node_id": "MDQ6VXNlcjE4NjY0NjE0",
      "avatar_url": "https://avatars2.githubusercontent.com/u/18664614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/markdroth",
      "html_url": "https://github.com/markdroth",
      "followers_url": "https://api.github.com/users/markdroth/followers",
      "following_url": "https://api.github.com/users/markdroth/following{/other_user}",
      "gists_url": "https://api.github.com/users/markdroth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/markdroth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/markdroth/subscriptions",
      "organizations_url": "https://api.github.com/users/markdroth/orgs",
      "repos_url": "https://api.github.com/users/markdroth/repos",
      "events_url": "https://api.github.com/users/markdroth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/markdroth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-31T22:02:55Z",
    "updated_at": "2018-01-31T22:02:55Z",
    "author_association": "MEMBER",
    "body": "@AspirinSJL, you're right, it does seem a bit weird that we don't wind up propagating the `disconnect_with_error` transport op down to each subchannel.  However, I don't think it would be safe to change the client_channel code to propagate that transport op down to all subchannels.  And even without us doing that, I think this bug should not be occurring anyway.\r\n\r\nKeep in mind that we share subchannels between parent channels.  If you have two channels sharing a given subchannel, and one of those channels gets shut down, we don't actually want to shut down the subchannel, because it's still in use by the other channel.  So this means that it's not actually safe for the client_channel code to send the `disconnect_with_error` transport op down to every subchannel, because it does not know which subchannels may also be in use by another channel.\r\n\r\nWhat the client_channel code *does* do is to shut down the LB policy, which causes the LB policy to unref all of the subchannels.  That unref actually gets translated to unreffing the channel stack of the subchannel:\r\n\r\nhttps://github.com/grpc/grpc/blob/master/src/core/ext/filters/client_channel/subchannel.cc#L748\r\n\r\nFor any subchannel for which there is no other channel holding a ref, this should cause us to unref the transport.  And when the transport gets unreffed, it should cancel any active streams.  If the transport is not actually returning recv_trailing_metadata for active streams when it gets unreffed, then the bug probably lies in the transport.\r\n\r\nOne or more of the following folks may be able to help understand this: @vjpai @ncteisen @yang-g \r\n\r\nAlso, one word of advice: Please start by making sure we have a test that reproduces this problem.  Without that, we cannot reliably identify the source of the bug or prove that any potential fix actually works."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/362480506",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-362480506",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 362480506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjQ4MDUwNg==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-02T04:06:56Z",
    "updated_at": "2018-02-02T04:06:56Z",
    "author_association": "MEMBER",
    "body": "I see. I can understand the expected behavior now.\r\n\r\n@muxi Which version is the bug reporter using? The subchannel file they are using looks quite different from the one on our master. "
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/362607441",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-362607441",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 362607441,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2MjYwNzQ0MQ==",
    "user": {
      "login": "markdroth",
      "id": 18664614,
      "node_id": "MDQ6VXNlcjE4NjY0NjE0",
      "avatar_url": "https://avatars2.githubusercontent.com/u/18664614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/markdroth",
      "html_url": "https://github.com/markdroth",
      "followers_url": "https://api.github.com/users/markdroth/followers",
      "following_url": "https://api.github.com/users/markdroth/following{/other_user}",
      "gists_url": "https://api.github.com/users/markdroth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/markdroth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/markdroth/subscriptions",
      "organizations_url": "https://api.github.com/users/markdroth/orgs",
      "repos_url": "https://api.github.com/users/markdroth/repos",
      "events_url": "https://api.github.com/users/markdroth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/markdroth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-02T14:52:42Z",
    "updated_at": "2018-02-02T14:52:42Z",
    "author_association": "MEMBER",
    "body": "I think there may be a problem in the case where there are two channels open to the same server and only one of them shuts down.  I've described that situation (and a possible but not ideal fix) in #14292.\r\n\r\nI'm not sure this is actually what's happening in this case, because even if there was a second channel open to the same server, I would expect both of them to be destroyed at the same time by the same iOS hook, thus causing the subchannel to shut down and the transport to cancel all calls.  So the problem I just described may be unrelated to this bug, but I thought I'd mention it here for completeness.\r\n\r\nAs I said earlier, I think we need to start by finding a way to reproduce this, so that we can see what's actually happening."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/364607579",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-364607579",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 364607579,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NDYwNzU3OQ==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-10T00:27:29Z",
    "updated_at": "2018-02-10T00:29:02Z",
    "author_association": "MEMBER",
    "body": "This bug is very easy to reproduce by hand. By checking the refcount log, I see that the last pending ref of the subchannel is for `state_watcher`. And I've verified that the unref doesn't happen because the callback (`subchannel_on_child_state_changed()` in user's version, now it should be `on_connected_subchannel_connectivity_changed()`) watching the connectivity state is never invoked. This seems to make sense, because the user is expecting to destroy the whole channel top-down. The user watches the network connectivity and calls  `grpc_channel_destroy()` when the network dies. Everything else has gone, but the \"state_watcher\" of the subchannel insists that it hasn't seen any connectivity change so it can't unref the subchannel.\r\n\r\n@markdroth  By reproducing this, do you mean reproducing by test?\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367187700",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367187700",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367187700,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzE4NzcwMA==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T01:55:40Z",
    "updated_at": "2018-02-21T01:55:40Z",
    "author_association": "MEMBER",
    "body": "After closer investigating, I think there is something like circular dependency between connected_subchannel and subchannel_call, if we want to shut down the channel and the calls in a top-down style.\r\n\r\nSince the user is using 1.8.4 version (although this bug also happens in 1.9.x), let's look[ the file in that version](https://github.com/grpc/grpc/blob/v1.8.4/src/core/ext/filters/client_channel/subchannel.cc).\r\n\r\nHere are two paths to unref a connected_subchannel:\r\n1. `grpc_subchannel_unref()` -> `disconnect()` -> `GRPC_CONNECTED_SUBCHANNEL_UNREF()`.\r\n2. `subchannel_call_destroy()` always calls `GRPC_CONNECTED_SUBCHANNEL_UNREF()`.\r\n\r\nFrom path 2 we can see that each subchannel_call holds a ref to the connected_subchannel, then it seems impossible to cancel the subchannel_call by destroying the connected_subchannel first (i.e., the first path). \r\n\r\nA workaround is to cancel the call directly when the user detects network disconnection instead of propagating the unrefs down. The following log shows that the subchannel_call unrefs the connected_subchannel after it is cancelled directly. Before this workaround is added, the refs to the connected_subchannel can only be decreased to 4.\r\n\r\n```\r\n\r\n2018-02-20 16:03:41.262 firebase-network-bug-reproduce[2250:761125] error:Error Domain=io.grpc Code=1 \"Cancelled\" UserInfo={NSLocalizedDescription=Cancelled}\r\ntrailers:{\r\n}\r\n\r\nxxxxxxxxxxxxxxxxxxxxxxxxx Directly cancelled the first call.\r\n\r\nD0220 16:03:41.263512000 7000006656 transport.cc:41]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568   REF 3->4 termination\r\nD0220 16:03:41.263592000 7000006656 transport.cc:41]                   CALL_STACK 0x12f09b948:0x12f09b938   REF 2->3 perform_stream_op\r\nD0220 16:03:41.263718000 7000006656 transport.cc:56]                   CALL_STACK 0x12f09b948:0x12f09b938 UNREF 3->2 chttp2\r\nD0220 16:03:41.263755000 7000006656 transport.cc:56]                   CALL_STACK 0x12f09b948:0x12f09b938 UNREF 2->1 perform_stream_op\r\nD0220 16:03:41.263862000 7000006656 transport.cc:56]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568 UNREF 4->3 termination\r\n2018-02-20 16:03:41.264 firebase-network-bug-reproduce[2250:761068] cancelled call\r\nD0220 16:03:41.266058000 7000006656 transport.cc:41]                   CALL_STACK 0x12f0ab3c8:0x12f0aab68   REF 1->2 termination\r\nD0220 16:03:41.268005000 6143422464 transport.cc:56]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568 UNREF 3->2 completion\r\nD0220 16:03:41.270660000 7000006656 transport.cc:56]                   CALL_STACK 0x12f0ab3c8:0x12f0aab68 UNREF 2->1 termination\r\n2018-02-20 16:03:41.270 firebase-network-bug-reproduce[2250:761068] cancelled call\r\nD0220 16:03:41.274642000 7000006656 transport.cc:41]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568   REF 3->4 termination\r\nD0220 16:03:41.274709000 7000006656 transport.cc:56]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568 UNREF 4->3 termination\r\n2018-02-20 16:03:41.274 firebase-network-bug-reproduce[2250:761068] cancelled call\r\nD0220 16:03:41.275143000 6143422464 transport.cc:56]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568 UNREF 2->1 completion\r\n2018-02-20 16:03:43.522 firebase-network-bug-reproduce[2250:761125] error:Error Domain=io.grpc Code=1 \"Cancelled\" UserInfo={NSLocalizedDescription=Cancelled}\r\ntrailers:{\r\n}\r\n\r\nxxxxxxxxxxxxxxxxxxxxxxxxx Directly cancelled the second call.\r\n\r\nD0220 16:03:43.523257000 6144569344 transport.cc:56]                   CALL_STACK 0x12f0ab3c8:0x12f0aab68 UNREF 1->0 destroy\r\nD0220 16:03:43.523355000 6144569344 transport.cc:56]                   CALL_STACK 0x12f071548:0x12f071538 UNREF 1->0 client_channel_destroy_call\r\nD0220 16:03:45.092736000 6144569344 transport.cc:56]                   CLIENT_SUBCHANNEL 0x1304a8cf0:0x1304a8cf0 UNREF 4->3 picked\r\nD0220 16:03:48.166225000 6144569344 transport.cc:56]                   CLIENT_SUBCHANNEL 0x1304a8cf0:0x1304a8cf0 UNREF 3->2 subchannel_call\r\n\r\nxxxxxxxxxxxxxxxxxxxxxxxxx The first call unreffed the connected_subchannel.\r\n\r\nD0220 16:03:48.166369000 6144569344 transport.cc:56]                   CLIENT_CHANNEL 0x12eda4810:0x12eda4780 UNREF 2->1 call\r\nD0220 16:03:48.168065000 6144569344 transport.cc:56]                   CALL_STACK 0x12f0a8dc8:0x12f0a8568 UNREF 1->0 destroy\r\nD0220 16:03:48.168146000 6144569344 transport.cc:56]                   CALL_STACK 0x12f09b948:0x12f09b938 UNREF 1->0 client_channel_destroy_call\r\nD0220 16:03:49.055567000 6144569344 transport.cc:56]                   CLIENT_SUBCHANNEL 0x1304a8cf0:0x1304a8cf0 UNREF 2->1 picked\r\nD0220 16:03:50.034636000 6144569344 transport.cc:56]                   CLIENT_SUBCHANNEL 0x1304a8cf0:0x1304a8cf0 UNREF 1->0 subchannel_call\r\n\r\nxxxxxxxxxxxxxxxxxxxxxxxxx The second call unreffed the connected_subchannel.\r\n\r\nD0220 16:03:50.034821000 6144569344 transport.cc:56]                   CLIENT_CHANNEL 0x12eda4810:0x12eda4780 UNREF 1->0 call\r\nD0220 16:03:55.332504000 6144569344 subchannel.cc:572]                 SUBCHANNEL: 0x12ee90930   WEAK_UNREF 0x1 -> 0x0 [state_watcher]\r\n```\r\n\r\nI think we do want to let subchannel_call hold a ref to the connected_subchannel.\r\n\r\nIf this rationale sounds reasonable, I think we'd better tell the iOS users to use the workaround and document this somewhere.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367192767",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367192767",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367192767,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzE5Mjc2Nw==",
    "user": {
      "login": "srini100",
      "id": 35056280,
      "node_id": "MDQ6VXNlcjM1MDU2Mjgw",
      "avatar_url": "https://avatars2.githubusercontent.com/u/35056280?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/srini100",
      "html_url": "https://github.com/srini100",
      "followers_url": "https://api.github.com/users/srini100/followers",
      "following_url": "https://api.github.com/users/srini100/following{/other_user}",
      "gists_url": "https://api.github.com/users/srini100/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/srini100/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/srini100/subscriptions",
      "organizations_url": "https://api.github.com/users/srini100/orgs",
      "repos_url": "https://api.github.com/users/srini100/repos",
      "events_url": "https://api.github.com/users/srini100/events{/privacy}",
      "received_events_url": "https://api.github.com/users/srini100/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T02:24:59Z",
    "updated_at": "2018-02-21T02:24:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hypothetically, if there is a separate channel refcnt to a subchannel, would it tell us that subchannel is not in use any more when that count hits zero and hence all calls on that subchannel can be destroyed?\r\n\r\nI am not clear on the workaround here. Users need to also cancel the calls?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367195267",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367195267",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367195267,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzE5NTI2Nw==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T02:41:08Z",
    "updated_at": "2018-02-21T02:41:08Z",
    "author_association": "MEMBER",
    "body": "We currently have separate counts for external (strong) refs and internal (weak) refs. But we planned to remove this kind of refcounting, because it's complicated and the only use case is for subchannel.\r\n\r\nWhen the users detect some network failure, they will destroy the channel hoping that the calls will also be cancelled. But actually the calls are not being cancelled, probably because of the refcounting pattern we use. A workaround can be explicitly cancelling the calls when the network failure is detected."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367367035",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367367035",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367367035,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzM2NzAzNQ==",
    "user": {
      "login": "markdroth",
      "id": 18664614,
      "node_id": "MDQ6VXNlcjE4NjY0NjE0",
      "avatar_url": "https://avatars2.githubusercontent.com/u/18664614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/markdroth",
      "html_url": "https://github.com/markdroth",
      "followers_url": "https://api.github.com/users/markdroth/followers",
      "following_url": "https://api.github.com/users/markdroth/following{/other_user}",
      "gists_url": "https://api.github.com/users/markdroth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/markdroth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/markdroth/subscriptions",
      "organizations_url": "https://api.github.com/users/markdroth/orgs",
      "repos_url": "https://api.github.com/users/markdroth/repos",
      "events_url": "https://api.github.com/users/markdroth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/markdroth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T15:39:01Z",
    "updated_at": "2018-02-21T15:39:21Z",
    "author_association": "MEMBER",
    "body": "@AspirinSJL, yes, I am suggesting that we have a test for this case.  Otherwise, we have no way to prove that any potential fix actually works or that we don't break that fix with subsequent changes in the future.\r\n\r\nI don't think it's feasible to have the iOS code cancel all of the calls, because it does not have a list of all of the calls.  We don't currently keep a list of all calls on a channel anywhere.  If we actually need to cancel all of the calls (and I'm still not convinced that we do; see below), then it probably makes more sense to do this inside of core than to push this work onto the application or the iOS interface.\r\n\r\nKeep in mind that there is not actually any requirement that the destruction happen on a top-down basis.  Or, to say this another way, we do not need to ensure that the calls get cancelled as a result of `grpc_channel_destroy()` being called from the surface.  As long as the calls will eventually finish, and as long as the channel gets destroyed when the last call does finish, I think that's fine.\r\n\r\nI think the bug here is not that we are not destroying the calls when `grpc_channel_destroy()` is called; it's that a call started before `grpc_channel_destroy()` was called is not finishing afterwards.  So the question is, why is that not happening?"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367419255",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367419255",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367419255,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzQxOTI1NQ==",
    "user": {
      "login": "srini100",
      "id": 35056280,
      "node_id": "MDQ6VXNlcjM1MDU2Mjgw",
      "avatar_url": "https://avatars2.githubusercontent.com/u/35056280?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/srini100",
      "html_url": "https://github.com/srini100",
      "followers_url": "https://api.github.com/users/srini100/followers",
      "following_url": "https://api.github.com/users/srini100/following{/other_user}",
      "gists_url": "https://api.github.com/users/srini100/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/srini100/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/srini100/subscriptions",
      "organizations_url": "https://api.github.com/users/srini100/orgs",
      "repos_url": "https://api.github.com/users/srini100/repos",
      "events_url": "https://api.github.com/users/srini100/events{/privacy}",
      "received_events_url": "https://api.github.com/users/srini100/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T18:14:48Z",
    "updated_at": "2018-02-21T18:14:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "The bug here is that when grpc_channel_destroy() is called, the user is expecting all pending calls on that channel to return immediately. I think @AspirinSJL is suggesting the user to explicitly cancel calls along with destroying the channel. This mean the user has to keep track of calls on that channel. Just to be clear, the calls do return eventually after a long delay. The user is expecting the calls to return immediately when the channel is destroyed."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367425208",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367425208",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367425208,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzQyNTIwOA==",
    "user": {
      "login": "markdroth",
      "id": 18664614,
      "node_id": "MDQ6VXNlcjE4NjY0NjE0",
      "avatar_url": "https://avatars2.githubusercontent.com/u/18664614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/markdroth",
      "html_url": "https://github.com/markdroth",
      "followers_url": "https://api.github.com/users/markdroth/followers",
      "following_url": "https://api.github.com/users/markdroth/following{/other_user}",
      "gists_url": "https://api.github.com/users/markdroth/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/markdroth/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/markdroth/subscriptions",
      "organizations_url": "https://api.github.com/users/markdroth/orgs",
      "repos_url": "https://api.github.com/users/markdroth/repos",
      "events_url": "https://api.github.com/users/markdroth/events{/privacy}",
      "received_events_url": "https://api.github.com/users/markdroth/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T18:33:46Z",
    "updated_at": "2018-02-21T18:33:46Z",
    "author_association": "MEMBER",
    "body": "Ah, okay, so the original description of this bug is wrong?  @muxi said that the RECV_STATUS_ON_CLIENT op was never returned, but it sounds like you're now saying that it is actually returned; the issue is actually that it's not being returned *immediately*, which is what's being asked for here.  Is that right?\r\n\r\nIf so, then I think this will require fixing #14292."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367461278",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367461278",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367461278,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzQ2MTI3OA==",
    "user": {
      "login": "muxi",
      "id": 1054404,
      "node_id": "MDQ6VXNlcjEwNTQ0MDQ=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1054404?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/muxi",
      "html_url": "https://github.com/muxi",
      "followers_url": "https://api.github.com/users/muxi/followers",
      "following_url": "https://api.github.com/users/muxi/following{/other_user}",
      "gists_url": "https://api.github.com/users/muxi/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/muxi/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/muxi/subscriptions",
      "organizations_url": "https://api.github.com/users/muxi/orgs",
      "repos_url": "https://api.github.com/users/muxi/repos",
      "events_url": "https://api.github.com/users/muxi/events{/privacy}",
      "received_events_url": "https://api.github.com/users/muxi/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T20:29:43Z",
    "updated_at": "2018-02-21T20:29:43Z",
    "author_association": "MEMBER",
    "body": "Sorry I was wrong on this. It seems the op returns after a long (a few minutes) delay.\r\n\r\nFrom its description I think #14292 is the right direction."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367483602",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367483602",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367483602,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzQ4MzYwMg==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-21T21:43:16Z",
    "updated_at": "2018-02-21T21:43:16Z",
    "author_association": "MEMBER",
    "body": "Actually the workaround is not too bad to me. In iOS layer, we have two kinds of network monitor: a single channel-level monitor; some per-call monitors. The channel-level monitor will destroy all the channels upon network error. The workaround I mentioned above is a one-line change in the call-level monitor, which cancels the call upon network error. \r\n\r\nBut I definitely agree that this workaround is not good enough for long-term use. Since the customer is already using some other workaround, I think fixing #14292 is the right choice. That will be much cleaner."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367558775",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367558775",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367558775,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzU1ODc3NQ==",
    "user": {
      "login": "mikelehen",
      "id": 206364,
      "node_id": "MDQ6VXNlcjIwNjM2NA==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/206364?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mikelehen",
      "html_url": "https://github.com/mikelehen",
      "followers_url": "https://api.github.com/users/mikelehen/followers",
      "following_url": "https://api.github.com/users/mikelehen/following{/other_user}",
      "gists_url": "https://api.github.com/users/mikelehen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mikelehen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mikelehen/subscriptions",
      "organizations_url": "https://api.github.com/users/mikelehen/orgs",
      "repos_url": "https://api.github.com/users/mikelehen/repos",
      "events_url": "https://api.github.com/users/mikelehen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mikelehen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-22T03:47:32Z",
    "updated_at": "2018-02-22T03:47:32Z",
    "author_association": "NONE",
    "body": "FYI- In case there's any confusion, the customer is not calling grpc_channel_destroy() or \"using some other workaround\" as far as I know.\r\n\r\nThe repro project linked in the issue description is an iOS app using the Firebase iOS SDK for Cloud Firestore (which uses grpc internally).  I work on the SDK, and all we we do is initiate a streaming RPC request to the backend. The user-facing issue is that upon a network change (e.g. switching from wifi to cellular), it takes ~90 seconds for the streaming RPC to fail (at which point we can retry it and resume connectivity with the backend). This timeout is too long.\r\n\r\nI haven't followed all of the discussion above but I just wanted to clear up the use case / symptom in case there was any confusion leading to false assumptions."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/367800758",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-367800758",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 367800758,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2NzgwMDc1OA==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-22T19:53:01Z",
    "updated_at": "2018-02-22T19:53:01Z",
    "author_association": "MEMBER",
    "body": "@mikelehen Thanks for clarifying!\r\n\r\n`grpc_channel_destroy()` is not called by the customer explicitly; it's called in gRPC Objective-C when some network error happens.\r\n\r\nSorry for misunderstanding the workaround status! The customer workaround that we thought is for this issue is actually for another issue. Then I think the workaround I proposed can be used if we want a quick fix. Fixing #14292 is a better solution to this issue, but it will be a much larger change and will take longer to finish."
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/368165182",
    "html_url": "https://github.com/grpc/grpc/issues/14220#issuecomment-368165182",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/14220",
    "id": 368165182,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM2ODE2NTE4Mg==",
    "user": {
      "login": "AspirinSJL",
      "id": 3314176,
      "node_id": "MDQ6VXNlcjMzMTQxNzY=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3314176?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/AspirinSJL",
      "html_url": "https://github.com/AspirinSJL",
      "followers_url": "https://api.github.com/users/AspirinSJL/followers",
      "following_url": "https://api.github.com/users/AspirinSJL/following{/other_user}",
      "gists_url": "https://api.github.com/users/AspirinSJL/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/AspirinSJL/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AspirinSJL/subscriptions",
      "organizations_url": "https://api.github.com/users/AspirinSJL/orgs",
      "repos_url": "https://api.github.com/users/AspirinSJL/repos",
      "events_url": "https://api.github.com/users/AspirinSJL/events{/privacy}",
      "received_events_url": "https://api.github.com/users/AspirinSJL/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-02-23T23:10:12Z",
    "updated_at": "2018-02-23T23:10:12Z",
    "author_association": "MEMBER",
    "body": "After discussion, we decided to cancel the call in Objective-C layer when the per-call monitor detects network error. Re-assigned to @muxi ."
  }
]
