[
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/314007910",
    "html_url": "https://github.com/grpc/grpc/issues/11725#issuecomment-314007910",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/11725",
    "id": 314007910,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDAwNzkxMA==",
    "user": {
      "login": "vjpai",
      "id": 8864912,
      "node_id": "MDQ6VXNlcjg4NjQ5MTI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8864912?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vjpai",
      "html_url": "https://github.com/vjpai",
      "followers_url": "https://api.github.com/users/vjpai/followers",
      "following_url": "https://api.github.com/users/vjpai/following{/other_user}",
      "gists_url": "https://api.github.com/users/vjpai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vjpai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vjpai/subscriptions",
      "organizations_url": "https://api.github.com/users/vjpai/orgs",
      "repos_url": "https://api.github.com/users/vjpai/repos",
      "events_url": "https://api.github.com/users/vjpai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vjpai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T05:16:14Z",
    "updated_at": "2017-07-10T05:16:14Z",
    "author_association": "MEMBER",
    "body": "Can you provide the code snippet?\n\nOn Sun, Jul 9, 2017, 6:07 PM zuanyg <notifications@github.com> wrote:\n\n> Please answer these questions before submitting your issue.\n> What version of gRPC and what language are you using?\n>\n> GRPC-1.0.0\n> C++\n> What operating system (Linux, Windows, …) and version?\n>\n> (Ubuntu 4.8.4-2ubuntu1~14.04.3)\n> What runtime / compiler are you using (e.g. python version or version of\n> gcc)\n>\n> gcc version 4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3)\n> What did you do?\n>\n> I wrote a test case using a single channel which serves for a one\n> bidirectional async stream and other unary RPCs at the same time. The\n> client and server are in the same process. I encountered an unary RPC\n> timeout once. And I found the server side got the unary RPC after 10\n> seconds, which after the client side got the deadline exceed. I didn't do\n> any failover operations and the resource condition is good.\n> What did you expect to see?\n>\n> All RPCs will success.\n> What did you see instead?\n>\n> I found the server side got a unary RPC after 10 seconds once, which after\n> the client side got the deadline exceed.\n> Anything else we should know about your project / environment?\n>\n> One thing is that the unary RPC's timeout was also set 10 seconds in the\n> test case. Pretty like the RPC was sent out after 10 seconds.\n>\n> —\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/grpc/grpc/issues/11725>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AIdEkMxz6FqCSTox-ylbDIiRgMIY1fJKks5sMXk-gaJpZM4OSQFs>\n> .\n>\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/314186277",
    "html_url": "https://github.com/grpc/grpc/issues/11725#issuecomment-314186277",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/11725",
    "id": 314186277,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDE4NjI3Nw==",
    "user": {
      "login": "yyh-graphsql",
      "id": 18043285,
      "node_id": "MDQ6VXNlcjE4MDQzMjg1",
      "avatar_url": "https://avatars1.githubusercontent.com/u/18043285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yyh-graphsql",
      "html_url": "https://github.com/yyh-graphsql",
      "followers_url": "https://api.github.com/users/yyh-graphsql/followers",
      "following_url": "https://api.github.com/users/yyh-graphsql/following{/other_user}",
      "gists_url": "https://api.github.com/users/yyh-graphsql/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yyh-graphsql/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yyh-graphsql/subscriptions",
      "organizations_url": "https://api.github.com/users/yyh-graphsql/orgs",
      "repos_url": "https://api.github.com/users/yyh-graphsql/repos",
      "events_url": "https://api.github.com/users/yyh-graphsql/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yyh-graphsql/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T18:02:30Z",
    "updated_at": "2017-07-10T18:03:15Z",
    "author_association": "NONE",
    "body": "Hi @vjpai \r\nThe following is the MICRO when issuing the unary RPC. The unary RPC's RPCTIMEOUT is 10secs.                                                                                                                                       \r\n\r\n```\r\nwhile (retryMgr.ShouldRetry()) {                                                     \\                                                                                                                                                                                            \r\n      gutil::Status connectionRc = validateChannel(RPCTIMEOUT * 1000);                   \\\r\n      if (!connectionRc.Ok()) {                                                          \\\r\n        rc = connectionRc;                                                               \\\r\n        break;                                                                           \\\r\n      }                                                                                  \\\r\n      grpc::ClientContext context;                                                       \\\r\n      {                                                                                  \\\r\n        std::chrono::system_clock::time_point deadline =                                 \\\r\n          std::chrono::system_clock::now() + std::chrono::milliseconds(RPCTIMEOUT);      \\\r\n        context.set_deadline(deadline);                                                  \\\r\n        boost::shared_lock<boost::shared_mutex> lock(mutex_);                            \\\r\n        status = stub_->RPCWORD(&context, request, &reply);                                     \\\r\n      }                                                                                  \\\r\n      if (status.ok()) {                                                                 \\\r\n        if (reply.rc(reply.rc_size()-1) != gutil::Status::kTimeout) {                    \\\r\n          break;                                                                         \\\r\n        }                                                                                \\\r\n      }                                                                                  \\\r\n      else if (status.error_code() == grpc::StatusCode::DEADLINE_EXCEEDED) {             \\\r\n        **LOG(ERROR) << \"RPC timeout reached, no retry, timeout: \" << RPCTIMEOUT;          \\**\r\n        rc = gutil::Status::kTimeout;                                                    \\\r\n        break;                                                                         \\\r\n      }                                                                                  \\\r\n      else {                                                                             \\\r\n        LOG(ERROR) << \"Error found in RPC, code: \" << status.error_code()                \\\r\n            << \", error msg: \" << status.error_message();                                \\\r\n        rc = gutil::Status::kIOError;                                                    \\\r\n      }                                                                                  \\\r\n      LOG(ERROR) << \"Retry on error, retry times: \" << retryMgr.GetRetryTimes()          \\\r\n                  << \", channel state: \" << this->GetConnnectionState();                 \\\r\n      retryMgr.SleepBeforeRetry();                                                       \\\r\n    }\r\n```\r\n\r\nIn the test I have two kinds of RPC, say 'A' and 'B'. I will issue two 'A's followed with two 'B's each in a batch for 100 times. At the same time in the process's background, there is a bidirectional async stream shared the same channel with the unary RPCs, which client side will issue heartbeat packages to the server side periodically (each per 500ms). In the failed situation, an RPC 'B' was DEADLINE_EXCEEDED and after that, I got three RPC 'B's on the server side. BTW, during the 'B' 's timeout period, the background async stream worked well.\r\nI still cannot give a minimum reproducible code snippet. Since I also encountered another GRPC problem https://github.com/grpc/grpc/issues/11681, I wonder if I can skip this problem by update our GRPC version.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/314251936",
    "html_url": "https://github.com/grpc/grpc/issues/11725#issuecomment-314251936",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/11725",
    "id": 314251936,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDI1MTkzNg==",
    "user": {
      "login": "vjpai",
      "id": 8864912,
      "node_id": "MDQ6VXNlcjg4NjQ5MTI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8864912?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vjpai",
      "html_url": "https://github.com/vjpai",
      "followers_url": "https://api.github.com/users/vjpai/followers",
      "following_url": "https://api.github.com/users/vjpai/following{/other_user}",
      "gists_url": "https://api.github.com/users/vjpai/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vjpai/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vjpai/subscriptions",
      "organizations_url": "https://api.github.com/users/vjpai/orgs",
      "repos_url": "https://api.github.com/users/vjpai/repos",
      "events_url": "https://api.github.com/users/vjpai/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vjpai/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T21:25:52Z",
    "updated_at": "2017-07-10T21:25:52Z",
    "author_association": "MEMBER",
    "body": "I can't be 100% sure if this is the issue, but you are holding a lock while doing a synchronous RPC. This, in general, is a bad idea because the lock will be held as long until the sync RPC gets its response. If the async RPCs in your background thread also have to use the same lock before issuing, then they will be locked out. Likewise with any other sync RPCs in other threads. In general, it is not a good idea to hold a lock while waiting for a response form a sync RPC. This is not really an issue with the RPC system; it is an issue with its usage.\r\n\r\nWe can't help any further without more details about the usage, so I hope this helped. I'll close the issue, but feel free to reopen if you can provide info that shows that my suggestion wasn't helpful.\r\n"
  },
  {
    "url": "https://api.github.com/repos/grpc/grpc/issues/comments/314269795",
    "html_url": "https://github.com/grpc/grpc/issues/11725#issuecomment-314269795",
    "issue_url": "https://api.github.com/repos/grpc/grpc/issues/11725",
    "id": 314269795,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDI2OTc5NQ==",
    "user": {
      "login": "yyh-graphsql",
      "id": 18043285,
      "node_id": "MDQ6VXNlcjE4MDQzMjg1",
      "avatar_url": "https://avatars1.githubusercontent.com/u/18043285?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yyh-graphsql",
      "html_url": "https://github.com/yyh-graphsql",
      "followers_url": "https://api.github.com/users/yyh-graphsql/followers",
      "following_url": "https://api.github.com/users/yyh-graphsql/following{/other_user}",
      "gists_url": "https://api.github.com/users/yyh-graphsql/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yyh-graphsql/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yyh-graphsql/subscriptions",
      "organizations_url": "https://api.github.com/users/yyh-graphsql/orgs",
      "repos_url": "https://api.github.com/users/yyh-graphsql/repos",
      "events_url": "https://api.github.com/users/yyh-graphsql/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yyh-graphsql/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-10T22:37:40Z",
    "updated_at": "2017-07-10T22:37:40Z",
    "author_association": "NONE",
    "body": "@vjpai Thank you for the reminder. The read lock is used here because we will hold a write lock to change the stub_ when switching to the primary. That may block the RPC, but I got `LOG(ERROR) << \"RPC timeout reached, no retry, timeout: \" << RPCTIMEOUT` in the log which means the RPC really timed out. And in the log, I saw that the RPC showed up on the server side 10s later.\r\n\r\nHere are my other concerns:\r\n- Can I fix it by upgrading GRPC if the problem may relate to a known issue?\r\n- Are there any critical c++/c-core bugs in GRPC that make me really need to change the GRPC version? Since when I encountered a problem, it seems I lacked the judgment to figure out if it is a known issue or a GRPC bug. In the release note, the GRPC seems pretty stable for the c core and c++ lang."
  }
]
