[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/345789829",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-345789829",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 345789829,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NTc4OTgyOQ==",
    "user": {
      "login": "gfyoung",
      "id": 9273653,
      "node_id": "MDQ6VXNlcjkyNzM2NTM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/9273653?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gfyoung",
      "html_url": "https://github.com/gfyoung",
      "followers_url": "https://api.github.com/users/gfyoung/followers",
      "following_url": "https://api.github.com/users/gfyoung/following{/other_user}",
      "gists_url": "https://api.github.com/users/gfyoung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gfyoung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gfyoung/subscriptions",
      "organizations_url": "https://api.github.com/users/gfyoung/orgs",
      "repos_url": "https://api.github.com/users/gfyoung/repos",
      "events_url": "https://api.github.com/users/gfyoung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gfyoung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-20T18:46:00Z",
    "updated_at": "2017-11-20T18:46:00Z",
    "author_association": "MEMBER",
    "body": "@zertrin : Thanks for putting this together.  I saw that there was a lot of discussion back in #15931 about this.  As I haven't been able to read this in full, I cannot comment at the moment.  Nevertheless, let me ping:\r\n\r\n@jreback @jorisvandenbossche @TomAugspurger @chris-b1 "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/346683449",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-346683449",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 346683449,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0NjY4MzQ0OQ==",
    "user": {
      "login": "tdpetrou",
      "id": 7226751,
      "node_id": "MDQ6VXNlcjcyMjY3NTE=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7226751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tdpetrou",
      "html_url": "https://github.com/tdpetrou",
      "followers_url": "https://api.github.com/users/tdpetrou/followers",
      "following_url": "https://api.github.com/users/tdpetrou/following{/other_user}",
      "gists_url": "https://api.github.com/users/tdpetrou/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tdpetrou/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tdpetrou/subscriptions",
      "organizations_url": "https://api.github.com/users/tdpetrou/orgs",
      "repos_url": "https://api.github.com/users/tdpetrou/repos",
      "events_url": "https://api.github.com/users/tdpetrou/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tdpetrou/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-23T19:00:04Z",
    "updated_at": "2017-11-23T19:07:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "I agree that renaming with the current `agg` implementation is very clunky and broken in this example. The nested dicts are somewhat complex but writing them as you did makes it very clear what is happening.\r\n\r\nI suppose there could be a `names` parameter added to `agg` which would take dictionary mapping the aggregating columns to their new names. You could even add another parameter `drop_index` as a boolean to determine whether to keep the upper index level.\r\n\r\nSo the syntax would turn into:\r\n\r\n```\r\nagg_dict = {'energy': ['sum',\r\n                       lambda x: np.percentile(x, 98), # lambda\r\n                       lambda x: np.percentile(x, 17), # lambda\r\n                      ],\r\n            'distance': ['sum',\r\n                         'mean',\r\n                         smrb.mad, # original function\r\n                         mad_c1,   # partial function wrapping the original function\r\n                        ]\r\n           }\r\n\r\nname_dict = {'energy':['energy_sum', 'energy_p98', 'energy_p17'],\r\n             'distance':['distance_sum', 'distance_mean', 'distance_mad', 'distance_mad_c1']}\r\n\r\n\r\nmydf.groupby('cat').agg(agg_dict, names=name_dict, drop_index=True)\r\n```\r\n\r\nOr maybe, an entire new method `agg_assign` could be created, which would work similarly to `DataFrame.assign`:\r\n\r\n```\r\nmydf.groupby('cat').agg_assign(energy_sum=lambda x: x.energy.sum(),\r\n                               energy_p98=lambda x: np.percentile(x.energy, 98),\r\n                               energy_p17=lambda x: np.percentile(x.energy, 17),\r\n                               distance_sum=lambda x: x.distance.sum(),\r\n                               distance_mean=lambda x: x.distance.mean(),\r\n                               distance_mad=lambda x: smrb.mad(x.distance),\r\n                               distance_mad_c1=lambda x: mad_c1(x.distance))\r\n```\r\n\r\nI actually like this option much better."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/346750613",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-346750613",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 346750613,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0Njc1MDYxMw==",
    "user": {
      "login": "smcateer",
      "id": 8705373,
      "node_id": "MDQ6VXNlcjg3MDUzNzM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8705373?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/smcateer",
      "html_url": "https://github.com/smcateer",
      "followers_url": "https://api.github.com/users/smcateer/followers",
      "following_url": "https://api.github.com/users/smcateer/following{/other_user}",
      "gists_url": "https://api.github.com/users/smcateer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/smcateer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/smcateer/subscriptions",
      "organizations_url": "https://api.github.com/users/smcateer/orgs",
      "repos_url": "https://api.github.com/users/smcateer/repos",
      "events_url": "https://api.github.com/users/smcateer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/smcateer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-24T06:14:12Z",
    "updated_at": "2017-11-24T06:15:18Z",
    "author_association": "NONE",
    "body": "For what it's worth, I am also strongly in favour of not depreciating the functionality.\r\n\r\nA big reason for me is that there is something deeply queer about mixing the Python's function name-space (something to do with the particular implementation) with the data the column names (something that should surely not know about the implementation). The fact that we are seeing columns (potentially multiple columns) named `'<lambda>'` is causes me severe cognitive dissonance.\r\n\r\nThe renaming approach grates, because there is this intermediary step where unnecessary (and exposed) column names are carried around. Furthermore, they are difficult to reliably, systematically rename because there are potentially dependencies on the implementation.\r\n\r\nAside from that, the nested dict functionality is admittedly complex, but it is a complex operation that is being performed.\r\n\r\nTL;DR Please don't depreciate. :)"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348260597",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348260597",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348260597,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODI2MDU5Nw==",
    "user": {
      "login": "pirsquared",
      "id": 1900410,
      "node_id": "MDQ6VXNlcjE5MDA0MTA=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1900410?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/pirsquared",
      "html_url": "https://github.com/pirsquared",
      "followers_url": "https://api.github.com/users/pirsquared/followers",
      "following_url": "https://api.github.com/users/pirsquared/following{/other_user}",
      "gists_url": "https://api.github.com/users/pirsquared/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/pirsquared/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/pirsquared/subscriptions",
      "organizations_url": "https://api.github.com/users/pirsquared/orgs",
      "repos_url": "https://api.github.com/users/pirsquared/repos",
      "events_url": "https://api.github.com/users/pirsquared/events{/privacy}",
      "received_events_url": "https://api.github.com/users/pirsquared/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T17:28:17Z",
    "updated_at": "2017-11-30T18:04:47Z",
    "author_association": "NONE",
    "body": "My contribution is motivated by two things.\r\n\r\n1. I'm aware of and agree with the motivation to reduce the bloated API of Pandas.  Even if I'm misguided in regards to the perceived motivation to reduce \"bloated\" API elements, It is still my opinion that Pandas' API could be streamlined.\r\n2. I think it is better to have a good cookbook with good recipes than provide API to satisfy everyone's wants and desires.  I'm **not** claiming that the renaming via nested dictionaries qualifies as satisfying whims as it already existed and we are discussing it's deprecation.  But it does lie on the spectrum between streamlined API and something... else.\r\n\r\nAlso, the Pandas Series and DataFrame objects have had [`pipe`](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.pipe.html) methods to facilitate pipelining.  In [this doc segment](https://pandas.pydata.org/pandas-docs/stable/internals.html#subclassing-pandas-data-structures) it is discussed that we could use `pipe` to proxy for methods in lieu of subclassing.  In the same spirit, we could use the **new** [`GroupBy.pipe`](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.groupby.GroupBy.pipe.html) to perform a similar role and allow us to build proxy methods for groupby objects.\r\n\r\nI'll use @zertrin 's example\r\n\r\n```\r\nimport numpy as np\r\nimport statsmodels.robust as smrb\r\nfrom functools import partial\r\n\r\n# The DataFrame offered up above\r\nmydf = pd.DataFrame(\r\n    {\r\n        'cat': ['A', 'A', 'A', 'B', 'B', 'C'],\r\n        'energy': [1.8, 1.95, 2.04, 1.25, 1.6, 1.01],\r\n        'distance': [1.2, 1.5, 1.74, 0.82, 1.01, 0.6]\r\n    },\r\n    index=range(6)\r\n)\r\n\r\n# Identical dictionary passed to `agg`\r\nfuncs = {\r\n    'energy': {\r\n        'total_energy': 'sum',\r\n        'energy_p98': lambda x: np.percentile(x, 98),  # lambda\r\n        'energy_p17': lambda x: np.percentile(x, 17),  # lambda\r\n    },\r\n    'distance': {\r\n        'total_distance': 'sum',\r\n        'average_distance': 'mean',\r\n        'distance_mad': smrb.mad,   # original function\r\n        'distance_mad_c1': mad_c1,  # partial function wrapping the original function\r\n    },\r\n}\r\n\r\n# Write a proxy method to be passed to `pipe`\r\ndef agg_assign(gb, fdict):\r\n    data = {\r\n        (cl, nm): gb[cl].agg(fn)\r\n        for cl, d in fdict.items()\r\n        for nm, fn in d.items()\r\n    }\r\n    return pd.DataFrame(data)\r\n\r\n# All the API we need already exists with `pipe`\r\nmydf.groupby('cat').pipe(agg_assign, fdict=funcs)\r\n```\r\n\r\nWhich results in\r\n\r\n```\r\n            distance                                                 energy                        \r\n    average_distance distance_mad distance_mad_c1 total_distance energy_p17 energy_p98 total_energy\r\ncat                                                                                                \r\nA              1.480     0.355825           0.240           4.44     1.8510     2.0364         5.79\r\nB              0.915     0.140847           0.095           1.83     1.3095     1.5930         2.85\r\nC              0.600     0.000000           0.000           0.60     1.0100     1.0100         1.01\r\n```\r\n\r\nThe `pipe` method makes adding new API unnecessary in many cases.  It also, provides the means for a replacement for the deprecated functionality we are discussing.  Therefore, I'd be inclined to go forward with the deprecation."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348327660",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348327660",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348327660,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODMyNzY2MA==",
    "user": {
      "login": "maxu777",
      "id": 11424941,
      "node_id": "MDQ6VXNlcjExNDI0OTQx",
      "avatar_url": "https://avatars0.githubusercontent.com/u/11424941?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maxu777",
      "html_url": "https://github.com/maxu777",
      "followers_url": "https://api.github.com/users/maxu777/followers",
      "following_url": "https://api.github.com/users/maxu777/following{/other_user}",
      "gists_url": "https://api.github.com/users/maxu777/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maxu777/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maxu777/subscriptions",
      "organizations_url": "https://api.github.com/users/maxu777/orgs",
      "repos_url": "https://api.github.com/users/maxu777/repos",
      "events_url": "https://api.github.com/users/maxu777/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maxu777/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T21:33:05Z",
    "updated_at": "2017-11-30T21:33:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "I really like tdpetrou's idea - to use: `names=name_dict`.\r\n\r\nThis can make everyone happy. It gives us a possibility to rename columns **easily** as we wish."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348355731",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348355731",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348355731,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODM1NTczMQ==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-11-30T23:35:15Z",
    "updated_at": "2017-12-01T00:01:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "Not really, as mentioned in my initial post, this would not solve the issue of decoupling the place where the aggregate operation is defined from the name of the resulting column, requiring an extra effort to make sure both are \"synchronized\".\n\nI don't say that's a bad solution (after all it solves the other issues), but it wouldn't be as easy and clear as the dict of dict approach. I mean here that at writing time you need to keep both dicts of lists synchronized, and when reading the source, the reader must make an effort to match the names in the second dict of lists with the aggregate definition in the first dict of lists. That's twice the effort in each case.\n\n> The nested dicts are somewhat complex but writing them as you did makes it very clear what is happening.\n\nI still don't understand why everyone seems to say that dict of dict is complex. To me that's the clearest way of doing it.\n\nThat said, if the `names` keyword is the only solution the pandas team is comfortable with, that would still be an improvement over current situation. "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348362132",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348362132",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348362132,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODM2MjEzMg==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-01T00:10:39Z",
    "updated_at": "2017-12-01T00:10:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "@pirsquared interesting solution with current API. Albeit in my opinion not quite easy to grasp (i don't really understand how it works :confused: )"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348733970",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348733970",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348733970,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODczMzk3MA==",
    "user": {
      "login": "tdpetrou",
      "id": 7226751,
      "node_id": "MDQ6VXNlcjcyMjY3NTE=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7226751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tdpetrou",
      "html_url": "https://github.com/tdpetrou",
      "followers_url": "https://api.github.com/users/tdpetrou/followers",
      "following_url": "https://api.github.com/users/tdpetrou/following{/other_user}",
      "gists_url": "https://api.github.com/users/tdpetrou/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tdpetrou/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tdpetrou/subscriptions",
      "organizations_url": "https://api.github.com/users/tdpetrou/orgs",
      "repos_url": "https://api.github.com/users/tdpetrou/repos",
      "events_url": "https://api.github.com/users/tdpetrou/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tdpetrou/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T01:47:21Z",
    "updated_at": "2017-12-03T01:47:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "I started a thread on the datascience subreddit - [What do you hate about pandas?](https://www.reddit.com/r/datascience/comments/7ggdlz/what_do_you_hate_about_pandas/dqo7hfr/). Someone brought up their contempt for the returned MultiIndex after a `groupby` and pointed to the dplyr `do` verb which is implemented in [plydata](https://plydata.readthedocs.io/en/stable/generated/plydata.one_table_verbs.do.html#plydata.one_table_verbs.do). It happens to work exactly as `agg_assign` so that was quite interesting.\r\n\r\n@zertrin  `agg_assign` would be superior to your dict of dict approach and be identical to sql aggregations as well as allow for multiple columns to interact with one another within the aggregation. It would also work identically to `DataFrame.assign`. \r\n\r\nAny thoughts @jreback @TomAugspurger ?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348742117",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348742117",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348742117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODc0MjExNw==",
    "user": {
      "login": "has2k1",
      "id": 780341,
      "node_id": "MDQ6VXNlcjc4MDM0MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/780341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/has2k1",
      "html_url": "https://github.com/has2k1",
      "followers_url": "https://api.github.com/users/has2k1/followers",
      "following_url": "https://api.github.com/users/has2k1/following{/other_user}",
      "gists_url": "https://api.github.com/users/has2k1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/has2k1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/has2k1/subscriptions",
      "organizations_url": "https://api.github.com/users/has2k1/orgs",
      "repos_url": "https://api.github.com/users/has2k1/repos",
      "events_url": "https://api.github.com/users/has2k1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/has2k1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T05:43:35Z",
    "updated_at": "2018-09-19T15:06:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "> ...\r\n> mydf.groupby('cat').agg(agg_dict, names=name_dict, drop_index=True)\r\n\r\nAlthough this solves the problem, one needs to align keys and values in two places. I think an API (as suggested for `.agg_assign`) that does not require such book-keeping code is less error prone.\r\n\r\nThere is also the issue of the clean up code after using the API. When `groupby` operations return a `MultiIndex` dataframe, in most cases the user undoes the `MultiIndex`. The straight forward declarative way of using `.agg_assign`, suggests no hierarchy, no  `MultiIndex` output, no clean up afterwards.\r\n\r\nBased on usage patterns, I think multi-index outputs should be strictly opt-in and not opt-out."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348745316",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348745316",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348745316,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODc0NTMxNg==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T07:10:50Z",
    "updated_at": "2017-12-03T07:10:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "I was initially skeptical about the `agg_assign` proposition, but the last two comments have convinced me that this could be a good solution.\r\n\r\nEspecially thinking about the possibility to use it in the form `agg_assign(**relabeling_dict)` and thus be able to define my `relabeling_dict` like this:\r\n\r\n```\r\nrelabeling_dict = {\r\n    'energy_sum': lambda x: x.energy.sum(),\r\n    'energy_p98': lambda x: np.percentile(x.energy, 98),\r\n    'energy_p17': lambda x: np.percentile(x.energy, 17),\r\n    'distance_sum': lambda x: x.distance.sum(),\r\n    'distance_mean': lambda x: x.distance.mean(),\r\n    'distance_mad': lambda x: smrb.mad(x.distance),\r\n    'distance_mad_c1': lambda x: mad_c1(x.distance)\r\n}\r\n```\r\n\r\nThat would be quite flexible and solve all the issues mentioned in my OP."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348800691",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348800691",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348800691,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODgwMDY5MQ==",
    "user": {
      "login": "tdpetrou",
      "id": 7226751,
      "node_id": "MDQ6VXNlcjcyMjY3NTE=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7226751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tdpetrou",
      "html_url": "https://github.com/tdpetrou",
      "followers_url": "https://api.github.com/users/tdpetrou/followers",
      "following_url": "https://api.github.com/users/tdpetrou/following{/other_user}",
      "gists_url": "https://api.github.com/users/tdpetrou/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tdpetrou/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tdpetrou/subscriptions",
      "organizations_url": "https://api.github.com/users/tdpetrou/orgs",
      "repos_url": "https://api.github.com/users/tdpetrou/repos",
      "events_url": "https://api.github.com/users/tdpetrou/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tdpetrou/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-03T17:49:33Z",
    "updated_at": "2017-12-03T17:54:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "@zertrin @has2k1 \r\n\r\nI was thinking about this a bit more and this functionality exists already with `apply`. You simply return a Series with index as the new column names and values as the aggregation. This allows for spaces in the name and gives you the ability to order columns exactly how you wish:\r\n\r\n\r\n```\r\ndef my_agg(x):\r\n    data = {'energy_sum': x.energy.sum(),\r\n            'energy_p98': np.percentile(x.energy, 98),\r\n            'energy_p17': np.percentile(x.energy, 17),\r\n            'distance sum' : x.distance.sum(),\r\n            'distance mean': x.distance.mean(),\r\n            'distance MAD': smrb.mad(x.distance),\r\n            'distance MAD C1': mad_c1(x.distance)}\r\n    return pd.Series(data, index=list_of_column_order)\r\n    \r\nmydf.groupby('cat').apply(my_agg)\r\n```\r\n\r\nSo, there might not be a need for a new method and instead just a better example in the docs."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348942177",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348942177",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348942177,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODk0MjE3Nw==",
    "user": {
      "login": "has2k1",
      "id": 780341,
      "node_id": "MDQ6VXNlcjc4MDM0MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/780341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/has2k1",
      "html_url": "https://github.com/has2k1",
      "followers_url": "https://api.github.com/users/has2k1/followers",
      "following_url": "https://api.github.com/users/has2k1/following{/other_user}",
      "gists_url": "https://api.github.com/users/has2k1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/has2k1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/has2k1/subscriptions",
      "organizations_url": "https://api.github.com/users/has2k1/orgs",
      "repos_url": "https://api.github.com/users/has2k1/repos",
      "events_url": "https://api.github.com/users/has2k1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/has2k1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T11:59:13Z",
    "updated_at": "2017-12-04T11:59:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "@tdpetrou, you are correct. I had forgotten how `apply` works as I use my [own version](https://github.com/has2k1/plotnine/blob/f58573de9a4acc02c46c6a67cf7d32754e148a00/plotnine/utils.py#L585) because of the double execution in fast-slow path selection process."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348980882",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-348980882",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 348980882,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODk4MDg4Mg==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T14:40:00Z",
    "updated_at": "2017-12-04T15:53:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hum indeed, there is no chance I would have thought about using it in a aggregation context just by reading the doc however...\r\nMoreover, I still find the solution with `apply` a bit too convoluted. The `agg_assign` approach seemed more straightforward and understandable.\r\n\r\nSince there was never really a statement about it, is the `dict-of-dict` approach (which, albeit currently deprecated, is already implemented and also solves all these issues) really definitely out of the question?\r\n\r\nExcept for the `agg_assign` approach, `dict-of-dict` still seems the most simple one, and doesn't need any coding, just un-deprecating."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349002842",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-349002842",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 349002842,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTAwMjg0Mg==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T15:49:01Z",
    "updated_at": "2017-12-04T15:49:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "The benefit and drawback of the `agg_assign` approach is that it pushes the column selection *into the aggregation method*. In all the examples, the `x` passed to the `lambda` is something like `self.get_group(group)` for each group in `self`, a `DataFrameGroupBy` object. This is nice because it cleanly separates the *naming*, which is in `**kwargs`, from the *selection*, which is in the function.\r\n\r\nThe drawback is that your nice, generic aggregation functions now have to be concerned with column selection. There's no free lunch! That means you'll end up with many helpers like `lambda x: x[col].min`. You'll also need to be careful with things like `np.min` which reduces over all dimensions, vs. `pd.DataFrame.min`, which reduces over `axis=0`. That's why something like `agg_assign` wouldn't be equivalent to `apply`. `apply` still operates column-wise for certain methods.\r\n\r\nI'm not sure about these tradeoffs vs. the dict-of-dicts method, but I'm curious to hear other people's thoughts. Here's a rough sketch of `agg_assign`, which I've called which I've called `agg_table` to emphasize that the functions are being passed the tables, not columns:\r\n\r\n```python\r\nfrom collections import defaultdict\r\n\r\nimport pandas as pd\r\nimport numpy as np\r\nfrom pandas.core.groupby import DataFrameGroupBy\r\n\r\nmydf = pd.DataFrame(\r\n    {\r\n        'cat': ['A', 'A', 'A', 'B', 'B', 'C'],\r\n        'energy': [1.8, 1.95, 2.04, 1.25, 1.6, 1.01],\r\n        'distance': [1.2, 1.5, 1.74, 0.82, 1.01, 0.6]\r\n    },\r\n    index=range(6)\r\n)\r\n\r\n\r\ndef agg_table(self, **kwargs):\r\n    output = defaultdict(dict)\r\n    for group in self.groups:\r\n        for k, v in kwargs.items():\r\n            output[k][group] = v(self.get_group(group))\r\n    \r\n    return pd.concat([pd.Series(output[k]) for k in output],\r\n                     keys=list(output),\r\n                     axis=1)\r\n\r\nDataFrameGroupBy.agg_table = agg_table\r\n```\r\n\r\nUsage\r\n\r\n```python\r\n\r\n>>> gr = mydf.groupby(\"cat\")\r\n>>> gr.agg_table(n=len,\r\n                 foo=lambda x: x.energy.min(),\r\n                 bar=lambda y: y.distance.min())\r\n\r\n   n   foo   bar\r\nA  3  1.80  1.20\r\nB  2  1.25  0.82\r\nC  1  1.01  0.60\r\n```\r\n\r\nI suspect we could do a bit to make the performance of this less awful, but not nearly as much as `.agg` does..."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349055711",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-349055711",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 349055711,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTA1NTcxMQ==",
    "user": {
      "login": "maxu777",
      "id": 11424941,
      "node_id": "MDQ6VXNlcjExNDI0OTQx",
      "avatar_url": "https://avatars0.githubusercontent.com/u/11424941?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/maxu777",
      "html_url": "https://github.com/maxu777",
      "followers_url": "https://api.github.com/users/maxu777/followers",
      "following_url": "https://api.github.com/users/maxu777/following{/other_user}",
      "gists_url": "https://api.github.com/users/maxu777/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/maxu777/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/maxu777/subscriptions",
      "organizations_url": "https://api.github.com/users/maxu777/orgs",
      "repos_url": "https://api.github.com/users/maxu777/repos",
      "events_url": "https://api.github.com/users/maxu777/events{/privacy}",
      "received_events_url": "https://api.github.com/users/maxu777/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T18:23:30Z",
    "updated_at": "2017-12-04T18:23:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "Could someone from the Pandas Core Team please explain what is the main reason for deprecating of relabeling dicts in `groupby.agg`?\r\n\r\nI could easily understand if it causes too much problems to maintain the code, but if it's about complexity for the end user - i would also opt for bringing it back, as it's pretty clear compared to needed workarounds...\r\n\r\nThank you!"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349061408",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-349061408",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 349061408,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTA2MTQwOA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T18:40:43Z",
    "updated_at": "2017-12-04T18:40:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Could someone from the Pandas Core Team please explain what is the main reason for deprecating of relabeling dicts in groupby.agg?\r\n\r\nDid you see https://github.com/pandas-dev/pandas/pull/15931/files#diff-52364fb643114f3349390ad6bcf24d8fR461?\r\n\r\nThe primary reason was that dict-keys were overloaded to do two things. For Series / SeriesGroupBy, they're for naming. For DataFrame/DataFrameGroupBy, they're for selecting a column.\r\n\r\n```python\r\nIn [32]: mydf.aggregate({\"distance\": \"min\"})\r\nOut[32]:\r\ndistance    0.6\r\ndtype: float64\r\n\r\nIn [33]: mydf.aggregate({\"distance\": {\"foo\": \"min\"}})\r\n/Users/taugspurger/Envs/pandas-dev/bin/ipython:1: FutureWarning: using a dict with renaming is deprecated and will be removed in a future version\r\n  #!/Users/taugspurger/Envs/pandas-dev/bin/python3.6\r\nOut[33]:\r\n     distance\r\nfoo       0.6\r\n\r\nIn [34]: mydf.distance.agg({\"foo\": \"min\"})\r\nOut[34]:\r\nfoo    0.6\r\nName: distance, dtype: float64\r\n\r\nIn [35]: mydf.groupby(\"cat\").agg({\"distance\": {\"foo\": \"min\"}})\r\n/Users/taugspurger/Envs/pandas-dev/lib/python3.6/site-packages/pandas/pandas/core/groupby.py:4201: FutureWarning: using a dict with renaming is deprecated and will be removed in a future version\r\n  return super(DataFrameGroupBy, self).aggregate(arg, *args, **kwargs)\r\nOut[35]:\r\n    distance\r\n         foo\r\ncat\r\nA       1.20\r\nB       0.82\r\nC       0.60\r\n\r\nIn [36]: mydf.groupby(\"cat\").distance.agg({\"foo\": \"min\"})\r\n/Users/taugspurger/Envs/pandas-dev/bin/ipython:1: FutureWarning: using a dict on a Series for aggregation\r\nis deprecated and will be removed in a future version\r\n  #!/Users/taugspurger/Envs/pandas-dev/bin/python3.6\r\nOut[36]:\r\n      foo\r\ncat\r\nA    1.20\r\nB    0.82\r\nC    0.60\r\n```\r\n\r\nThis isn't the *most* confusing thing in pandas probably, so perhaps we could revisit it :) I'm presumably missing some edge cases. But even if we do remove dict-of-dicts aggregations, we still have the inconsistency between naming and column selection:\r\n\r\nFor Series / SeriesGroupBy the dictionary keys are always for naming the output.\r\n\r\nFor DataFrame / DataFrameGroupby, the dict keys are always for selection. With dict-of-dicts we select a column, and then the inner dict is for naming the output, just like Series / SeriesGroupBy. "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349089667",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-349089667",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 349089667,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTA4OTY2Nw==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T20:09:30Z",
    "updated_at": "2017-12-04T20:09:50Z",
    "author_association": "MEMBER",
    "body": "We discussed this briefly before (somewhere in the long discussion about the deprecation), and I proposed something similar here: https://github.com/pandas-dev/pandas/pull/14668#issuecomment-274508089. But in the end only the deprecation was implemented, and not the ideas for making the other functionality of using dicts (the 'renaming' function) easier. \r\n\r\nThe problem was that dicts were both used for 'selection' (on which column do you want this function to be applied) and 'renaming' (what should be the resulting column name when applying this function). An alternative syntax, apart from dicts, could be keyword arguments, as is discussed here in the `agg_assign` proposal. \r\nI am still in favor to explore this possibility, whether it is in `agg` itself or in a new method like `agg_assign`.\r\n\r\nWhat I proposed back then was something similar to `agg_assign` but using a dict per keyword instead of a lambda function. Translated to the example here, this would be something like:\r\n\r\n```\r\nmydf.groupby('cat').agg(\r\n    energy_sum={'energy': 'sum'},\r\n    energy_p98={'energy': lambda x: np.percentile(x, 98)},\r\n    energy_p17={'energy': lambda x: np.percentile(x, 17)},\r\n    distance_sum={'distance': 'sum'},\r\n    distance_mean={'distance': 'mean'},\r\n    distance_mad={'distance': smrb.mad},\r\n    distance_mad_c1={'distance': mad_c1})\r\n```\r\n\r\nI am not sure this is necessarily more readable or easier to write as the version with all lambdas, but, this one could potentially be more performant, as pandas can still use the optimized implementations for sum, mean, etc on those columns where you do not have a lambda or user specified function.\r\n\r\nA big question with this approach would be what `df.groupby('cat').agg(foo='mean')` would mean? That would logically apply 'mean' to all columns since you didn't make any selection (similar to `{'col1' : {'foo': 'mean'}, 'col2': {'foo':'mean'}, 'col3': ...}` before). But, that would result in multi-indexed columns, while in the example above I think it would be nice to not end up with MI columns.\r\n\r\nI think the above *can* be done backwards compatible inside the existing `agg`, but the question is whether this is needed. \r\nI also think this would nicely extend to the `series` case like:\r\n\r\n```\r\nmydf.groupby('cat').distance.agg(\r\n    distance_sum='sum',\r\n    distance_mean='mean',\r\n    distance_mad=smrb.mad,\r\n    distance_mad_c1=mad_c1)\r\n```\r\n\r\n(and you could even consider to do the above one time for 'distance' and once for 'energy' and concat the result if you don't like all the dicts / lambda's)\r\n\r\n@TomAugspurger In your example simple implementation of `agg_table`, wouldn't it be better to iterate over the different functions to be applied, instead of iterating of the groups, and in the end concatting the new columns by axis=1 instead of concatting the newly formed rows by axis=0 ?\r\n\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349090402",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-349090402",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 349090402,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTA5MDQwMg==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T20:11:58Z",
    "updated_at": "2017-12-04T20:11:58Z",
    "author_association": "MEMBER",
    "body": "BTW, @zertrin @tdpetrou @smcateer @pirsquared and others, thanks a lot for raising this issue and giving such detailed feedback. Such feedback and community involvement is *very* important!"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/352590614",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-352590614",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 352590614,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MjU5MDYxNA==",
    "user": {
      "login": "smcateer",
      "id": 8705373,
      "node_id": "MDQ6VXNlcjg3MDUzNzM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8705373?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/smcateer",
      "html_url": "https://github.com/smcateer",
      "followers_url": "https://api.github.com/users/smcateer/followers",
      "following_url": "https://api.github.com/users/smcateer/following{/other_user}",
      "gists_url": "https://api.github.com/users/smcateer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/smcateer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/smcateer/subscriptions",
      "organizations_url": "https://api.github.com/users/smcateer/orgs",
      "repos_url": "https://api.github.com/users/smcateer/repos",
      "events_url": "https://api.github.com/users/smcateer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/smcateer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-18T23:26:44Z",
    "updated_at": "2017-12-18T23:39:01Z",
    "author_association": "NONE",
    "body": "I actually really like the pattern suggested by @tdpetrou (using apply with a function that returns a Series) - probably even better than the dict of dicts.\r\n\r\nIf the function returns ` pd.Series(data, index=data.keys())` are we guaranteed to get the indices in the right order? (Just thinking about how best to implement the pattern in my code - at the risk of drifting off-topic).\r\n\r\nEdit: sorry, I misunderstood the point of the index argument (it is optional here, only needed if you want to specify the order of the columns - returning ` pd.Series(data)` does the job for me)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/355458110",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-355458110",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 355458110,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTQ1ODExMA==",
    "user": {
      "login": "reesehopkins",
      "id": 15884962,
      "node_id": "MDQ6VXNlcjE1ODg0OTYy",
      "avatar_url": "https://avatars1.githubusercontent.com/u/15884962?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/reesehopkins",
      "html_url": "https://github.com/reesehopkins",
      "followers_url": "https://api.github.com/users/reesehopkins/followers",
      "following_url": "https://api.github.com/users/reesehopkins/following{/other_user}",
      "gists_url": "https://api.github.com/users/reesehopkins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/reesehopkins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/reesehopkins/subscriptions",
      "organizations_url": "https://api.github.com/users/reesehopkins/orgs",
      "repos_url": "https://api.github.com/users/reesehopkins/repos",
      "events_url": "https://api.github.com/users/reesehopkins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/reesehopkins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-05T02:38:46Z",
    "updated_at": "2018-01-05T02:38:46Z",
    "author_association": "NONE",
    "body": "Would @tdpetrou's example work with `first` & `last` aggregations? \r\n\r\nI had to resort to head/tail like this\r\n\r\n```python\r\ndef agg_funcs(x):\r\n    data = {'start':x['DATE_TIME'].head(1).values[0],\r\n           'finish':x['DATE_TIME'].tail(1).values[0],\r\n           'events':len(x['DATE_TIME'])}\r\n    return pd.Series(data, index = list(data.keys()))\r\n\r\nresults = df.groupby('col').apply(agg_funcs)\r\n```"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/384422672",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-384422672",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 384422672,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4NDQyMjY3Mg==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-25T20:26:07Z",
    "updated_at": "2018-04-25T20:26:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'd still like to address this, but I don't think it'll be done for 0.23."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/396382979",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-396382979",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 396382979,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjM4Mjk3OQ==",
    "user": {
      "login": "BodonFerenc",
      "id": 39382130,
      "node_id": "MDQ6VXNlcjM5MzgyMTMw",
      "avatar_url": "https://avatars1.githubusercontent.com/u/39382130?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/BodonFerenc",
      "html_url": "https://github.com/BodonFerenc",
      "followers_url": "https://api.github.com/users/BodonFerenc/followers",
      "following_url": "https://api.github.com/users/BodonFerenc/following{/other_user}",
      "gists_url": "https://api.github.com/users/BodonFerenc/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/BodonFerenc/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/BodonFerenc/subscriptions",
      "organizations_url": "https://api.github.com/users/BodonFerenc/orgs",
      "repos_url": "https://api.github.com/users/BodonFerenc/repos",
      "events_url": "https://api.github.com/users/BodonFerenc/events{/privacy}",
      "received_events_url": "https://api.github.com/users/BodonFerenc/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-11T20:51:11Z",
    "updated_at": "2018-06-11T20:51:11Z",
    "author_association": "NONE",
    "body": "Could @tdpetrou's approach work without defining a function that we will never use again in our code? Coming from a Q/Kdb+ world (similar to SQL) I am confused why we need to create any temporal variable/function for a simple select statement."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/396457464",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-396457464",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 396457464,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjQ1NzQ2NA==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-12T03:51:57Z",
    "updated_at": "2018-06-12T03:52:58Z",
    "author_association": "CONTRIBUTOR",
    "body": "OP here.\r\n\r\nHonestly, after all this time and the plenty of discussion in #15931 and here, I am still not convinced that this is a good idea to deprecate relabeling dicts.\r\n\r\nIn the end, none of the alternatives proposed here are more intuitive to the users than the current relabeling dict approach IMHO. When it was in the documentation, just with one example it was clear how this works, and it is very flexible.\r\n\r\nOf course pandas developers may still think otherwise, just chiming in with the point of view of an user."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/396560270",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-396560270",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 396560270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5NjU2MDI3MA==",
    "user": {
      "login": "tdpetrou",
      "id": 7226751,
      "node_id": "MDQ6VXNlcjcyMjY3NTE=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7226751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tdpetrou",
      "html_url": "https://github.com/tdpetrou",
      "followers_url": "https://api.github.com/users/tdpetrou/followers",
      "following_url": "https://api.github.com/users/tdpetrou/following{/other_user}",
      "gists_url": "https://api.github.com/users/tdpetrou/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tdpetrou/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tdpetrou/subscriptions",
      "organizations_url": "https://api.github.com/users/tdpetrou/orgs",
      "repos_url": "https://api.github.com/users/tdpetrou/repos",
      "events_url": "https://api.github.com/users/tdpetrou/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tdpetrou/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-12T11:43:15Z",
    "updated_at": "2018-06-12T11:43:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "Even the relabeling dict approach is not very intuitive. In my opinion the syntax should be similar to SQL - `func(column_name) as new_column_name`. In Python we can do this with a three-item tuple. `(func, column_name, new_column_name)`. This is how dexplo does groupby aggregation.\r\n\r\n![dexplo](https://user-images.githubusercontent.com/7226751/41288274-c32739ac-6e13-11e8-8cbb-8e1b2d75ce23.jpg)\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/403119008",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-403119008",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 403119008,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzExOTAwOA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-06T18:55:55Z",
    "updated_at": "2018-07-06T18:55:55Z",
    "author_association": "MEMBER",
    "body": "@zertrin do you have feedback on my proposal above: https://github.com/pandas-dev/pandas/issues/18366/#issuecomment-349089667 \r\nIn the end, it kind of inverts the order of the dict: instead of \"{col: {name: func}}\" it would be kind of \"\\*\\*{name: {col: func}}\""
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/403192624",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-403192624",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 403192624,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzE5MjYyNA==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T06:26:31Z",
    "updated_at": "2018-07-07T06:28:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jorisvandenbossche I have considered your approach. The thing is, I don't really see what additional advantages it brings over the current approach.\r\n\r\nTo put it more bluntly, given the following choices:\r\n\r\n1. Undeprecate current behaviour which works well (a few lines of deprecation code to remove, re-add the piece of documentation that was removed)\r\n2. Implement your proposal (significant changes to be made in the code, pursue with deprecation of current approach, necessity for all users to adapt their code)\r\n\r\nI don't see why we should choose 2 unless it brings meaningful and tangible advantages from a developer and user perspective.\r\n\r\nTo address some of the points in your proposal above:\r\n\r\n> The problem was that dicts were both used for 'selection' (on which column do you want this function to be applied) and 'renaming' (what should be the resulting column name when applying this function). \r\n\r\nSince it was nicely documented before, I don't believe it was an issue for *users*. Personally, I got the point immediately looking at the examples in the documentation. (EDIT: and I thought: _\"yay! very useful construct, it exactly matches what I was looking for. Nice.\"_)\r\n\r\n> An alternative syntax, apart from dicts, could be keyword arguments\r\n\r\nOne of the attractive thing to use the dict-of-dict approach is that users can be easily generate it dynamically with some other code. As you pointed out in the comment just above this one, moving to keyword arguments as in your proposition would still allow for this via the `**{name: {col: func}}` construct. So I'm not against your proposal. I just don't see the value added and the necessity of such changes when we already achieve the same level of functionality with the current implemented system.\r\n\r\nIn the end, you proposal would be _okay_ if pandas core dev have a strong feeling against the current approach. I just don't see any benefit as a _user_. (in fact I see the drawback of changing all existing user code to make it work again with the new proposition)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/403221440",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-403221440",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 403221440,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzIyMTQ0MA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T14:59:18Z",
    "updated_at": "2018-07-07T14:59:18Z",
    "author_association": "MEMBER",
    "body": "@zertrin we discussed this yesterday with some core devs, but didn't get to writing the summary here. So now I am going to do that, *before* answering to your comment, to only reflect our thoughts of yesterday.\r\n\r\n---\r\n\r\nSo first to state, the notion that a basic functionality like the SQL \"SELECT avg(col2) as col2_avg\" should work and be easy, is something we completely agree on, and we really want to have a solution for this.\r\n\r\nApart from the original reasons we decided to deprecate this (which may or may not be that strong), the current (deprecated) dicts of dicts is also not *that* ideal, as this creates a MultiIndex that you actually never want:\r\n\r\n```\r\nIn [1]: df = pd.DataFrame({'A': ['a', 'b', 'a'], 'B': range(3), 'C': [.1, .2, .3]})\r\n\r\nIn [3]: gr = df.groupby('A')\r\n\r\nIn [4]: gr.agg({'B': {'b_sum': 'sum'}, 'C': {'c_mean': 'mean', 'c_count': 'count'}})\r\nOut[4]: \r\n        C            B\r\n  c_count c_mean b_sum\r\nA                     \r\na       2    0.2     2\r\nb       1    0.2     1\r\n```\r\n\r\nIn the above, the first level of the MultiIndex is superfluous, as you already specifically renamed the columns  (in the example in the OP, this is also directly followed by dropping the first level of the columns). \r\nIt is however hard to change this because you can also do things like `gr.agg(['sum', 'mean'])` or (mixed) `gr.agg({'B': ['sum', 'mean'], 'C': {'c_mean': 'mean', 'c_count': 'count'}})` were the MultiIndex is needed and makes sense. \r\n\r\nSo one of the proposals that was mentioned in the discussion above, was to have a way to specify the final column names separately (eg https://github.com/pandas-dev/pandas/issues/18366#issuecomment-346683449). \r\nAdding eg an extra keyword to `aggregate` to specify the column names, like  \r\n\r\n```\r\ngr.agg({'B': 'sum', 'C': ['mean', 'count']}, columns=['b_sum', 'c_mean', 'c_count'])\r\n```\r\n\r\nwould be possible. \r\nHowever, if we split the column/function specification and the new column names, we can also make this more generic than a new keyword, and do something like:\r\n\r\n```\r\ngr.agg({'B': 'sum', 'C': ['mean', 'count']}).rename(columns=['b_sum', 'c_mean', 'c_count'])\r\n```\r\n\r\nThis needs https://github.com/pandas-dev/pandas/issues/14829 to be solved (something we want to do for 0.24.0). \r\n(**important note**: for this we *do* need to fix the duplicate names problem of lambda functions, so we should do some kind of automatic deduplication of the names if we want to support this solution.)\r\n\r\n---\r\n\r\nThen, we still like the way of the keyword arguments for renaming. Reasons for this are:\r\n\r\n- it is similar to how `assign` works in pandas, and also consistent with how `groupby().aggregate()` works in ibis (and also similar to how it looks in eg dplyr in R)\r\n- it directly gives you the non-hierarchical column names that you would want (no MultiIndex)\r\n- for the simple cases (also eg for Series case), I think it is simpler as the dict of dict\r\n\r\nWe still had a bit of discussion how it could look like. What I proposed above was (to use the equivalent column/function selection as in my first examples):\r\n\r\n```\r\ngr.agg(b_sum={'B': 'sum'}, c_mean={'C': 'mean'}, c_count={'C': 'count'})\r\n```\r\n\r\nYou still can build up this specification as a dict of dicts, but with the inner and outer level swapped compared to the current (deprecated) version:\r\n\r\n```\r\ngr.agg(**{'b_sum': {'B': 'sum'}, 'c_mean': {'C': 'mean'}, 'c_count': {'C': 'count'})\r\n```\r\n\r\n(we could have a example helper function that converts the existing dicts of dicts to this version)\r\n\r\nHowever, the dict is always only a single `{col: func}`, and those multiple single element dicts look a bit strange. So an alternative we thought of is to use tuples:\r\n\r\n```\r\ngr.agg(b_sum=('B', 'sum'), c_mean=('C', 'mean'), c_count=('C', 'count'))\r\n```\r\n\r\nThis *looks* a bit better, but on the other hand the `{'B': 'sum'}` dict is consistent with the other APIs for specifying the column on which to apply the function.\r\n\r\n---\r\n\r\nBoth suggestions above (the easier renaming afterwards, and the keyword-based naming) are in principle orthogonal, but it could be nice to have both (or still something else based on further discussion)\r\n\r\n "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/403240100",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-403240100",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 403240100,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMzI0MDEwMA==",
    "user": {
      "login": "zertrin",
      "id": 1447163,
      "node_id": "MDQ6VXNlcjE0NDcxNjM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1447163?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zertrin",
      "html_url": "https://github.com/zertrin",
      "followers_url": "https://api.github.com/users/zertrin/followers",
      "following_url": "https://api.github.com/users/zertrin/following{/other_user}",
      "gists_url": "https://api.github.com/users/zertrin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zertrin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zertrin/subscriptions",
      "organizations_url": "https://api.github.com/users/zertrin/orgs",
      "repos_url": "https://api.github.com/users/zertrin/repos",
      "events_url": "https://api.github.com/users/zertrin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zertrin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-07T20:09:42Z",
    "updated_at": "2018-07-07T20:09:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for forwarding here the current thoughts from the devs  \r\n\r\nI acknowledge the (, in my opinion, only) drawback of the deprecated dict-of-dict approach with the resulting MultiIndex. Could be flattened if the user pass an additional option (yeah YAO :-/ ).\r\n\r\nAs mentioned, I am not against the second version, as long as it stays possible to:\r\n- generate things dynamically somehow and unpack it (thanks to the `**{}` construct, yay Python!)\r\n- keep the renaming and the aggregation specification close together (having to keep track of two lists such that their order stays the same is plain annoying as a user IMHO)\r\n- use lambda or partial functions without needing workarounds because of the (potentially lack of or conflict with) function names.\r\n\r\nAs such, the last suggestion (with dicts or tuples for the col>func mapping) is okay I think.\r\n\r\nThe first proposition in the previous comment can be implemented if you really want to, but my feedback on this is that, as a user, I wouldn't choose to use it over the second alternative because of the pain of keeping things in sync between two lists."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/425212844",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-425212844",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 425212844,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyNTIxMjg0NA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-27T19:21:56Z",
    "updated_at": "2018-09-27T19:21:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "Discussed at the dev meeting today.\r\n\r\nShort summary\r\n\r\n1. @jorisvandenbossche will try to implement `gr.agg(b_sum=(\"B\", \"sum), ...)`, i.e. when there's no `arg` passed to `*GroupBy.agg`, interpret kwargs as `<output_name>=(<selection>, <aggfunc>)`\r\n2. Orthogonal to this issues, we'd like to implement [MutliIndex.flatten](\r\nhttps://github.com/pandas-dev/pandas/issues/19950) and provide a `flatten=True` keyword to `.agg`"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/476597674",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18366#issuecomment-476597674",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18366",
    "id": 476597674,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NjU5NzY3NA==",
    "user": {
      "login": "plankthom",
      "id": 1620679,
      "node_id": "MDQ6VXNlcjE2MjA2Nzk=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1620679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/plankthom",
      "html_url": "https://github.com/plankthom",
      "followers_url": "https://api.github.com/users/plankthom/followers",
      "following_url": "https://api.github.com/users/plankthom/following{/other_user}",
      "gists_url": "https://api.github.com/users/plankthom/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/plankthom/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/plankthom/subscriptions",
      "organizations_url": "https://api.github.com/users/plankthom/orgs",
      "repos_url": "https://api.github.com/users/plankthom/repos",
      "events_url": "https://api.github.com/users/plankthom/events{/privacy}",
      "received_events_url": "https://api.github.com/users/plankthom/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-26T12:10:01Z",
    "updated_at": "2019-03-26T12:54:38Z",
    "author_association": "NONE",
    "body": "Maybe this helps: my workaround for the deprecation are these helper functions that replaces the alias->aggr maps with list of correctly named functions:\r\n```python\r\ndef aliased_aggr(aggr, name):\r\n    if isinstance(aggr,str):\r\n        def f(data):\r\n            return data.agg(aggr)\r\n    else:\r\n        def f(data):\r\n            return aggr(data)\r\n    f.__name__ = name\r\n    return f\r\n\r\ndef convert_aggr_spec(aggr_spec):\r\n    return {\r\n        col : [ \r\n            aliased_aggr(aggr,alias) for alias, aggr in aggr_map.items() \r\n        ]  \r\n        for col, aggr_map in aggr_spec.items() \r\n    }\r\n```\r\nwhich gives the old behaviour with:\r\n```\r\nmydf_agg = mydf.groupby('cat').agg(convert_aggr_spec{\r\n    'energy': {\r\n        'total_energy': 'sum',\r\n        'energy_p98': lambda x: np.percentile(x, 98),  # lambda\r\n        'energy_p17': lambda x: np.percentile(x, 17),  # lambda\r\n    },\r\n    'distance': {\r\n        'total_distance': 'sum',\r\n        'average_distance': 'mean',\r\n        'distance_mad': smrb.mad,   # original function\r\n        'distance_mad_c1': mad_c1,  # partial function wrapping the original function\r\n    },\r\n}))\r\n```\r\nwhich is the same as\r\n```python\r\nmydf_agg = mydf.groupby('cat').agg({\r\n    'energy': [ \r\n        aliased_aggr('sum', 'total_energy'),\r\n        aliased_aggr(lambda x: np.percentile(x, 98), 'energy_p98'),\r\n        aliased_aggr(lambda x: np.percentile(x, 17), 'energy_p17')\r\n    ],\r\n    'distance': [\r\n         aliased_aggr('sum', 'total_distance'),\r\n         aliased_aggr('mean', 'average_distance'),\r\n         aliased_aggr(smrb.mad, 'distance_mad'),\r\n         aliased_aggr(mad_c1, 'distance_mad_c1'),\r\n    ]\r\n})\r\n```\r\nThis works for me, but probably won't work in some corner cases ...\r\n\r\n*Update*: found out that renaming is not necessary, as tuples in an aggregation specification are interpreted as (alias, aggr). So the alias_aggr function is not needed, and the conversion becomes:\r\n```python\r\ndef convert_aggr_spec(aggr_spec):\r\n    return {\r\n        col : [ \r\n           (alias,aggr) for alias, aggr in aggr_map.items() \r\n        ]  \r\n        for col, aggr_map in aggr_spec.items() \r\n    }\r\n```"
  }
]
