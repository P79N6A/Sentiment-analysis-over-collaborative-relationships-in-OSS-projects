[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/406709853",
    "html_url": "https://github.com/pandas-dev/pandas/issues/21998#issuecomment-406709853",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/21998",
    "id": 406709853,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjcwOTg1Mw==",
    "user": {
      "login": "jschendel",
      "id": 5332445,
      "node_id": "MDQ6VXNlcjUzMzI0NDU=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5332445?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jschendel",
      "html_url": "https://github.com/jschendel",
      "followers_url": "https://api.github.com/users/jschendel/followers",
      "following_url": "https://api.github.com/users/jschendel/following{/other_user}",
      "gists_url": "https://api.github.com/users/jschendel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jschendel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jschendel/subscriptions",
      "organizations_url": "https://api.github.com/users/jschendel/orgs",
      "repos_url": "https://api.github.com/users/jschendel/repos",
      "events_url": "https://api.github.com/users/jschendel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jschendel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-20T19:54:04Z",
    "updated_at": "2018-07-20T19:54:04Z",
    "author_association": "MEMBER",
    "body": "xref #19480\r\n\r\nThis is reasonable, though some care is needed if these operations are to work between intervals with mixed `closed`.  My initial inclination was to simply not allow mixed `closed` operations, but they seem generally well defined after thinking about it.\r\n\r\nFor example, the following seems reasonable:\r\n```python\r\nIn [2]: i0 = pd.Interval(0, 2, closed='both')\r\n\r\nIn [3]: i1 = pd.Interval(1, 3, closed='neither')\r\n\r\nIn [4]: i0.intersection(i1)\r\nOut[4]: Interval(1, 2, closed='right')\r\n```\r\n\r\nThe only thing that immediately comes to mind as problematic is `union`.  Mixed `closed` should be fine if the intervals are overlapping.  For example, using the intervals defined above, the following seems reasonable:\r\n```python\r\nIn [5]: i0.union(i1)\r\nOut[5]: Interval(0, 3, closed='left')\r\n```\r\n\r\nNon-overlapping intervals with the same `closed` should also be fine, though I'd like to note that my preference would be to return an `IntervalArray` (newly implemented, slated for 0.24.0) instead of an `IntervalIndex`:\r\n```python\r\nIn [6]: i2 = pd.Interval(8, 10, closed='both')\r\n\r\nIn [7]: i0.union(i2)\r\nOut[7]:\r\nIntervalArray([[0, 2], [8, 10]],\r\n              closed='both',\r\n              dtype='interval[int64]')\r\n```\r\n\r\nThe problematic case for `union` is when you have mixed `closed` intervals that are non-overlapping.  We can't use `IntervalArray` (or `IntervalIndex`) in that case, as they require all intervals to be closed on the same side.  The options would be to either raise an error, or return a numpy object dtype array:\r\n```python\r\nIn [8]: i3 = pd.Interval(8, 10, closed='neither')\r\n\r\nIn [9]: i0.union(i3)\r\nOut[9]: array([Interval(0, 2, closed='both'), Interval(8, 10, closed='neither')], dtype=object)\r\n```\r\nI'm not sure if an object dtype array actually provides an utility here, and seems a bit unnatural, so I'd lean towards raising.  Could be convinced otherwise if anyone has a practical use for it though."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/406718770",
    "html_url": "https://github.com/pandas-dev/pandas/issues/21998#issuecomment-406718770",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/21998",
    "id": 406718770,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNjcxODc3MA==",
    "user": {
      "login": "jschendel",
      "id": 5332445,
      "node_id": "MDQ6VXNlcjUzMzI0NDU=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5332445?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jschendel",
      "html_url": "https://github.com/jschendel",
      "followers_url": "https://api.github.com/users/jschendel/followers",
      "following_url": "https://api.github.com/users/jschendel/following{/other_user}",
      "gists_url": "https://api.github.com/users/jschendel/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jschendel/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jschendel/subscriptions",
      "organizations_url": "https://api.github.com/users/jschendel/orgs",
      "repos_url": "https://api.github.com/users/jschendel/repos",
      "events_url": "https://api.github.com/users/jschendel/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jschendel/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-20T20:31:22Z",
    "updated_at": "2018-07-20T20:31:22Z",
    "author_association": "MEMBER",
    "body": "Actually, I think `difference` could also be similarly problematic, even when both intervals are closed on the same side.  Specifically, I'd expect problematic behavior to occur with nested intervals:\r\n\r\n```python\r\nIn [2]: i0 = pd.Interval(0, 3, closed='both')\r\n\r\nIn [3]: i1 = pd.Interval(1, 2, closed='both')\r\n\r\nIn [4]: i0.difference(i1)\r\nOut[4]: array([Interval(0, 1, closed='left'), Interval(2, 3, closed='right')], dtype=object)\r\n```\r\n\r\nBut with mixed `closed` you could actually get a valid `IntervalArray`:\r\n```python\r\nIn [5]: i2 = pd.Interval(1, 2, closed='neither')\r\n\r\nIn [6]: i0.difference(i2)\r\nOut[6]:\r\nIntervalArray([[0, 1], [2, 3]],\r\n              closed='both',\r\n              dtype='interval[int64]')\r\n```\r\n\r\nSo not really sure if `difference` should be supported, as it can become a bit confusing from a user perspective to keep track of what is valid and what isn't (i.e. what returns an `IntervalArray` vs. what raises/returns an object dtype array).\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/408431102",
    "html_url": "https://github.com/pandas-dev/pandas/issues/21998#issuecomment-408431102",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/21998",
    "id": 408431102,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwODQzMTEwMg==",
    "user": {
      "login": "haleemur",
      "id": 6108231,
      "node_id": "MDQ6VXNlcjYxMDgyMzE=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/6108231?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/haleemur",
      "html_url": "https://github.com/haleemur",
      "followers_url": "https://api.github.com/users/haleemur/followers",
      "following_url": "https://api.github.com/users/haleemur/following{/other_user}",
      "gists_url": "https://api.github.com/users/haleemur/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/haleemur/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/haleemur/subscriptions",
      "organizations_url": "https://api.github.com/users/haleemur/orgs",
      "repos_url": "https://api.github.com/users/haleemur/repos",
      "events_url": "https://api.github.com/users/haleemur/events{/privacy}",
      "received_events_url": "https://api.github.com/users/haleemur/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-27T14:13:43Z",
    "updated_at": "2018-07-27T14:13:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jschendel  you are correct in the above observations. The complexity in my proposal derives from trying to return multiple intervals in either `IntervalIndex` or `IntervalRange` with mixed boundary types.\r\n\r\nI looked into the behaviour of [postgresql's range types][1], and perhaps we can model these operations similarly. Postgresql avoids the mixed boundary type problem by only returning a single value (boolean or single-continuous-interval) as result.\r\n\r\nI think the following range operators from postgresql taking two intervals as arguments should be interesting for pandas users:\r\n\r\nOperator | Description | Example | Result\r\n-- | -- | -- | --\r\n`&&` | overlap (have points in common) |             `int8range(3,7) && int8range(4,12)` |            `t`\r\n`<<` |                                  strictly left of |      `int8range(1,10) << int8range(100,110)` |            `t`\r\n`>>` |                                strictly right of |        `int8range(50,60) >> int8range(20,30)` |            `t`\r\n`&<` |     does not extend to the right of |          `int8range(1,20) &< int8range(18,20)` |            `t`\r\n`&>` |        does not extend to the left of |           `int8range(7,20) &> int8range(5,10)` |            `t`\r\n`-\\|-` |                                  is adjacent to |  `numrange(1.1,2.2) -\\|- numrange(2.2,3.3)` |            `t`\r\n  `+` |                                               union |         `numrange(5,15) + numrange(10,20)` |     `[5,20)`\r\n   `*` |                                     intersection |             `int8range(5,15) * int8range(10,20)` |   `[10,15)`\r\n   `-` |                                        difference |             `int8range(5,15) - int8range(10,20)` |     `[5,10)`\r\n\r\nand this function:\r\n\r\nFunction | Return Type | Description | Example | Result\r\n-- | -- | -- | -- | --\r\n`range_merge(anyrange, anyrange)` | anyrange | the smallest range which includes both of the given ranges | `range_merge('[1,2)'::int4range, '[3,4)'::int4range)` | `[1,4)`\r\n\r\n*examples of how postgresql handles non trivial range operations*:\r\n\r\nintersection:\r\n```\r\nhal=> select int8range(4,8) * int8range(10,20);\r\n ?column?\r\n----------\r\n empty\r\n(1 row)\r\n```\r\n\r\ndifference:\r\n```\r\nhal=> select int8range(4,8) - int8range(5,7);\r\nERROR:  result of range difference would not be contiguous\r\n```\r\nunion:\r\n```\r\nhal=> select int8range(4,8) + int8range(10,20);\r\nERROR:  result of range union would not be contiguous\r\n```\r\n\r\nI think we could implement behaviour similar to casting functions, where the `difference`  & `union` functions would have an `errors` parameter, with the following options: `raise|coerce|first|last|greatest|smallest`\r\n\r\n* raise: raises an error\r\n* coerce: sets the value to np.nan\r\n* first: returns the first interval in the the result array\r\n* last: returns the last interval in the result array\r\n* greatest: returns the biggest interval in the result array\r\n* smallest: returns the smallest interval in the result array\r\n\r\n`greatest` & `smallest` could be useful options for the difference operation.\r\n\r\n[1]: https://www.postgresql.org/docs/current/static/functions-range.html"
  }
]
