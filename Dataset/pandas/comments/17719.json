[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/333145598",
    "html_url": "https://github.com/pandas-dev/pandas/issues/17719#issuecomment-333145598",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/17719",
    "id": 333145598,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzE0NTU5OA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-29T14:42:21Z",
    "updated_at": "2017-09-29T14:42:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think your first example, under \"A current possibility...\", is incomplete?  IIUC, you want something like\r\n\r\n```python\r\nIn [26]: values = ['High'] * 40 + ['Medium'] * 10 + ['Low'] * 5 + ['No idea'] * 5\r\n\r\nIn [27]: pd.Categorical(values)\r\nOut[27]:\r\n[High, High, High, High, High, ..., No idea, No idea, No idea, No idea, No idea]\r\nLength: 60\r\nCategories (4, object): [High, Low, Medium, No idea]\r\n```\r\n\r\nTwo thoughts:\r\n\r\nHaving `categories` be a dict-like structure doesn't fit with how pandas represents them currently. I don't see a clean way of doing both.\r\n\r\nFor your `value_labels`, it seems like you have multiple values of \"missing\". Pandas has a single value for nulls, and for categoricals they're coded as -1. I think users should normalize their data before category encoding it.\r\n\r\n> I can do this by keeping external structures and such, but I think that this could be an improvement to pandas\r\n\r\nThis seems OK to me. In my mind you would have a sandwich of\r\n\r\nExternal dictionary -> pandas Categorical -> operations -> Export"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/333173275",
    "html_url": "https://github.com/pandas-dev/pandas/issues/17719#issuecomment-333173275",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/17719",
    "id": 333173275,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzE3MzI3NQ==",
    "user": {
      "login": "robertour",
      "id": 1033512,
      "node_id": "MDQ6VXNlcjEwMzM1MTI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1033512?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/robertour",
      "html_url": "https://github.com/robertour",
      "followers_url": "https://api.github.com/users/robertour/followers",
      "following_url": "https://api.github.com/users/robertour/following{/other_user}",
      "gists_url": "https://api.github.com/users/robertour/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/robertour/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/robertour/subscriptions",
      "organizations_url": "https://api.github.com/users/robertour/orgs",
      "repos_url": "https://api.github.com/users/robertour/repos",
      "events_url": "https://api.github.com/users/robertour/events{/privacy}",
      "received_events_url": "https://api.github.com/users/robertour/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-29T16:26:17Z",
    "updated_at": "2017-09-29T16:26:17Z",
    "author_association": "NONE",
    "body": "> I think your first example, under \"A current possibility...\", is incomplete?\r\n\r\nI missed the seconde parameter in `s = pd.Series(pd.Categorical.from_codes( values_of_column , categories= labels ))` (I corrected it now).\r\n\r\n> For your value_labels, it seems like you have multiple values of \"missing\". Pandas has a single value for nulls, and for categoricals they're coded as -1. I think users should normalize their data before category encoding it.\r\n\r\nI think so too, but unfortunately real life projects don't allow me to convince all ppl around me to keep things so consistently. They would insist that there is differences between 'no answer' and \"doesn't apply\"\r\n\r\n> External dictionary -> pandas Categorical -> operations -> Export\r\n\r\nThat would be incomplete:\r\n\r\nExternal dictionary -> pandas Categorical -> operations -> inverse dictionary > Export\r\n\r\nThe issue is that the users want to see the same ids for the codes, before and after the procedure, if 99999 means 'No Idea'; they want to see both, 'No Idea' (text) and 99999 (code). To be fair, some of the keep the 99999 accross projects and files, so it wouldn't be OK for me to just change it. \r\n\r\nNote that the above pipeline, i.e. External dictionary -> pandas Categorical -> operations -> inverse dictionary > Export, involves iterating over the data 3 times. If pandas would accept dictionaries, the conversion could be straight forward.\r\n\r\nFinally, I would like to reiterate my last point: Given the 1:1 nature of this relation, this could also be refined in order to have some dual representation of values, specially when one is dealing with similar data from different sources. For example, one database use the 2 letter ISO country representation (e.g. 'US') and another 3 letter ISO country representation (e.g. 'USA')."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/333176925",
    "html_url": "https://github.com/pandas-dev/pandas/issues/17719#issuecomment-333176925",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/17719",
    "id": 333176925,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzE3NjkyNQ==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-29T16:41:39Z",
    "updated_at": "2017-09-29T16:41:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hmm, could you check your example again?\r\n\r\n```python\r\nvalues_of_column = [1,99999,3,1] # would correspond to 'High', 'No Idea', 'Low', 'High'\r\nlabels = ['dummy0']  + ['Hight','Medium','Low'] + [ f'dummy{i}' for i in range(4,99999)] + ['No idea']\r\ns = pd.Series(pd.Categorical.from_codes( values_of_column , categories= labels ))\r\n```\r\n\r\nSeems strange since you end up with 4 values, but 100,000 categories. Typically the number of values is large, and the categories small.\r\n\r\n> The issue is that the users want to see the same ids for the codes, before and after the procedure, if 99999 means 'No Idea'; they want to see both, 'No Idea' (text) and 99999 (code)\r\n\r\nWho's the user here? Excel / SPSS users, or pandas? Pandas users don't get any control over the codes really, so I'll assume excel.\r\n\r\n> ... involves iterating over the data 3 times.\r\n\r\nI'm probably misunderstanding then. Once you have the data in a Categorical, I think you'd just be manipulating categories, which is fast.\r\n\r\nPerhaps you could show an example with two datasets\r\n\r\n```\r\ndata1 = 'country\\nUSA\\nUSA\\nUSA\\nAUS\\nAUS\\nAUS'\r\ndata2 = 'country\\nUS\\nUS\\nUS\\nAU\\nAU\\nAU'\r\ndf1 = pd.read_csv(StringIO(data1), dtype='category')\r\ndf2 = pd.read_csv(StringIO(data2), dtype='category')\r\n```\r\n\r\nWhat kind of operations are you hoping to do?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/333303637",
    "html_url": "https://github.com/pandas-dev/pandas/issues/17719#issuecomment-333303637",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/17719",
    "id": 333303637,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzMzMwMzYzNw==",
    "user": {
      "login": "robertour",
      "id": 1033512,
      "node_id": "MDQ6VXNlcjEwMzM1MTI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1033512?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/robertour",
      "html_url": "https://github.com/robertour",
      "followers_url": "https://api.github.com/users/robertour/followers",
      "following_url": "https://api.github.com/users/robertour/following{/other_user}",
      "gists_url": "https://api.github.com/users/robertour/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/robertour/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/robertour/subscriptions",
      "organizations_url": "https://api.github.com/users/robertour/orgs",
      "repos_url": "https://api.github.com/users/robertour/repos",
      "events_url": "https://api.github.com/users/robertour/events{/privacy}",
      "received_events_url": "https://api.github.com/users/robertour/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-09-30T11:51:59Z",
    "updated_at": "2017-09-30T11:51:59Z",
    "author_association": "NONE",
    "body": "> Seems strange since you end up with 4 values, but 100,000 categories. \r\n\r\nI guess that is what I called ugly :). You can put as many values as you want in the example:\r\n\r\n    values_of_column = [1,99999,3,2,1,1,2,2,2,1] # would correspond to 'High', 'No Idea', 'Low', 'High'\r\n    labels = ['dummy0']  + ['Hight','Medium','Low'] + [ f'dummy{i}' for i in range(4,99999)] + ['No idea']\r\n    s = pd.Series(pd.Categorical.from_codes( values_of_column , categories= labels ))\r\n\r\nHowever, even if you add 1 000 000 values, you will end with only using 4 categories out of 100000. Notice that in order to add `['No idea']` with the code `99999`, I need to insert a lot of dummy values [ `f'dummy{i}' for i in range(4,99999)] `. \r\n\r\nTo be sure, I am not doing the above (it would be just the possibility if I want to avoid the conversions of formats, hence I am also proposing the idea). I use an alternative to this, which is creating an inverse dictionary:\r\n\r\n    >>> value_labels = {\r\n        1 :  'High',\r\n        2 :  'Medium',\r\n        3 : 'Low',\r\n        99999 : 'No idea',\r\n    }\r\n    >>> labels_values = { v: k for k, v in value_labels}\r\n    labels_values = {\r\n        'High': 1,\r\n        'Medium': 2,\r\n        'Low' : 3,\r\n        'No idea' : 99999,\r\n    }\r\n\r\nNow let's say that `value_labels` and `values_of_columns` come from somewhere else (SPSS, Excel, or SQL - in SQL, 99999 could be a primary key in another table). Then, I do something like the following:\r\n\r\n    value_labels = {1 :  'High', 2 :  'Medium',3 : 'Low',99999 : 'No idea',}\r\n    values_of_column = [1,99999,3,2,1,1,2,2,2,1]\r\n    labels_of_columns = [ value_labels[i] for i in values_of_column ]\r\n\r\n    # Iteration 1: (usually I would be reading directly from the source, e.g. excel file)\r\n    df = DataFrame(labels_of_columns,columns=['Rate'])\r\n\r\n    # Iteration 2: replace the values (e.g. 99999) with the labels (e.g. 'No idea')\r\n    df.replace({'Rate': value_labels})\r\n\r\n    # Iteration 3: let pandas do the categories\r\n    df[\"Rate\"] = df[\"Rate\"].astype('category')\r\n\r\n    # operations; some could involve the use of the indeces (i.e. 999999)\r\n    # an others the use of the strings (i.e. 'No idea')\r\n\r\n    # And now save the dataframe back to the original source\r\n\r\n    # Reverse the dictionary\r\n    label_values = { v: k for k, v in value_labels}\r\n\r\n    # Iteration 4: go back to the initial column made out of values\r\n    df.replace({'Rate': label_values})\r\n\r\nI actually needed 4 iterations (but one may be ignored as it corresponds to reading the file). In any case, I am looking to do something like:\r\n\r\n    df = DataFrame(values_of_columns,columns=['Rate'])\r\n    df['Rate'].as_category_using_dictionary(value_labels)\r\n\r\nInternally, the dataframe would use the value_labels for the dual representation that it currently does with a list. In theory, there wouldn't be any need to iterate over the rows. In practice, it might be important to make sure that the dictionary `value_labels` does contain all the possible values, e.g. make sure that the value 99999 in `values_of_columns` exists in `value_labels`.\r\n\r\n> Who's the user here? Excel / SPSS users, or pandas? Pandas users don't get any control over the codes really, so I'll assume excel.\r\n\r\nThe user is somebody to ask me to do complex operation in an SPSS/Excel file (presumably complicated to perform in those tools, or requiring a lot of clicks and they want it automatized). They, for example, want a new column based on others. I typically read the file, do the operation (based on some categorical columns) and save the file with the new column without affecting the current content of the file. This varies across formats: in SPSS there is the metadata associated to the column; in R, levels/factors; in Excel; usually other sheets; in SQL, primary keys to other tables.\r\n\r\nThe operations that the user needs could also involve using the values, i.e. 99999, or/and the labels, i.e. 'No idea'. The values can be associated to other tables (easier if you think in terms of SQL primary keys, although not necessarily the case), and the labels are string that might be used in the constructions of new columns. For some columns, I need the values, for others, the labels.\r\n\r\n> I'm probably misunderstanding then. Once you have the data in a Categorical, I think you'd just be manipulating categories, which is fast.\r\n\r\nYes, this is a good idea! Now that I think about it, I could use this to create a better solution than my inverse dictionaries, meaning, saving iterations. However, this would also involve a tricky creation of consistent lists that matches the pandas indexes. \r\n\r\nIMHO, category columns depending on dictionaries seems a more intuitive and flexible approach than the current list index, which restricts the values to be ordered and continuing indexes that corresponds to entries in a list."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/335736280",
    "html_url": "https://github.com/pandas-dev/pandas/issues/17719#issuecomment-335736280",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/17719",
    "id": 335736280,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzNTczNjI4MA==",
    "user": {
      "login": "robertour",
      "id": 1033512,
      "node_id": "MDQ6VXNlcjEwMzM1MTI=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1033512?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/robertour",
      "html_url": "https://github.com/robertour",
      "followers_url": "https://api.github.com/users/robertour/followers",
      "following_url": "https://api.github.com/users/robertour/following{/other_user}",
      "gists_url": "https://api.github.com/users/robertour/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/robertour/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/robertour/subscriptions",
      "organizations_url": "https://api.github.com/users/robertour/orgs",
      "repos_url": "https://api.github.com/users/robertour/repos",
      "events_url": "https://api.github.com/users/robertour/events{/privacy}",
      "received_events_url": "https://api.github.com/users/robertour/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-10-11T08:40:39Z",
    "updated_at": "2017-10-11T08:40:39Z",
    "author_association": "NONE",
    "body": "I recently improved some of the code by using an special implementation of a sparse list (based on [this](https://pypi.python.org/pypi/sparse_list) ). Internally, the sparse has a dictionary with the existent index-valuess that returns a default value (usually None) when the index list doesn't exist. In my case, I modify the implementation to return a unique dummy value (e.g. 'dummy_1') when there is no code-label ([L31](https://github.com/robertour/python_sparse_list/blob/master/sparse_list.py#L31) and [L61](https://github.com/robertour/python_sparse_list/blob/master/sparse_list.py#L61)).\r\n\r\nThis doesn't solve yet the problem with negative codes (or strings) as pandas restrict the values between -1 to len(categories). The current sparse list doesn't accept negative indexes either but that could be fixed.\r\n\r\nJust an idea...\r\n "
  }
]
