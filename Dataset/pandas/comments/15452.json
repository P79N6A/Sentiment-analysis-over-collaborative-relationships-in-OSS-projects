[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/280850517",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-280850517",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 280850517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDg1MDUxNw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-18T14:55:35Z",
    "updated_at": "2017-02-18T14:55:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "these are not equivalent, asking for a scalar, e.g. ``s.loc[('not', 'found')]`` is the equivalent operation and this *does* raise ``KeyError``. \r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/280851391",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-280851391",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 280851391,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDg1MTM5MQ==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-18T15:10:14Z",
    "updated_at": "2017-02-18T15:10:14Z",
    "author_association": "MEMBER",
    "body": "@jreback , while indeed the most strict equivalent to \r\n\r\n``` python\r\n# flat Index, looking for a list of values\r\ns.reset_index().loc[['not', 'found']] \r\n```\r\n\r\nis not really\r\n\r\n``` python\r\n# MultiIndex, looking for a list of values (in first level)\r\ns.loc[['not', 'found']]\r\n```\r\nbut rather\r\n\r\n``` python\r\n# MultiIndex, looking for a list of (complete) keys\r\ns.loc[[('not', 'found1'), ('not', 'found2')]] \r\n```\r\n, your example is not related to any of those (compare to ``s.reset_index().loc[[1, 2]]``, which does not return a scalar, and neither ``s.reset_index().loc[[1, 'a']]`` does!). And by the way, the last example above is even more incoherent:\r\n``` python\r\nIn [6]: s.loc[[('not', 'found1'), ('not', 'found2')]]\r\nOut[6]: \r\nnot  found1   NaN\r\n     found2   NaN\r\ndtype: float64\r\n```\r\n... but at least there seems to be some reasoning behind (not clear to me)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/280868000",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-280868000",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 280868000,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDg2ODAwMA==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-18T19:12:40Z",
    "updated_at": "2017-02-18T19:12:40Z",
    "author_association": "MEMBER",
    "body": "Or if you want a more concise example: ``s.iloc[:2].loc[[s.index[-1]]]`` will raise ``KeyError`` if ``s`` has a flat ``Index``, and not if it has a ``MultiIndex``"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/280914945",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-280914945",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 280914945,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MDkxNDk0NQ==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-19T12:09:38Z",
    "updated_at": "2017-02-19T12:09:38Z",
    "author_association": "MEMBER",
    "body": ">  asking for a scalar, e.g. s.loc[('not', 'found')] is the equivalent operation and this does raise KeyError.\r\n\r\nthat is asking for a scalar label, but @toobaz issue was *a list of labels*, so the equivalent would indeed rather be (but of course it difficult to pinpoint an exact equivalent):\r\n\r\n```\r\nIn [97]: s.loc[[('not', 'found'), ('also', 'not')]]\r\nOut[97]: \r\nnot   found   NaN\r\nalso  not     NaN\r\ndtype: float64\r\n```\r\n\r\nwhich does a reindex. Thus, different from single Index indexing, where it only does a reindex when at least one label of the list is included in the Index.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/281542685",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-281542685",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 281542685,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4MTU0MjY4NQ==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-22T01:50:49Z",
    "updated_at": "2017-02-22T05:31:03Z",
    "author_association": "MEMBER",
    "body": "@jreback @jorisvandenbossche to be honest, I don't get why it was decided in the first place to make ``.loc`` behave like ``.reindex`` at all (e.g. change the structure of the indexed index). It seems to me completely incoherent with regular ``.loc`` behavior, and also undocumented. In my view, we should enforce the following general rules:\r\n\r\n- ``s.loc[list_of_things]`` for a ``Series`` or ``df.loc[list_of_things, :]`` for a ``DataFrame`` should always (except when they raise some error, obviously) return an object of the same kind and with an index of the same depth (including 1) as ``s`` and ``df``, respectively (where ``list_of_things`` is not necessarily a ``list``, but rather anything that we interpret as a list of labels/levels, including ``Index``es)\r\n- such index must contain a subset of the labels of the index of ``s``, or ``df`` (possibly repeated, however, and/or in another order)\r\n\r\nAnd I know it's probably late to say this, but concerning this bug, the cleanest solution would seem to me to abandon the [rule](http://pandas.pydata.org/pandas-docs/stable/indexing.html#selection-by-label) (documented, this time) ``At least 1 of the labels for which you ask, must be in the index or a ``KeyError`` will be raised!``, and allow an empty ``DataFrame``/``Series`` to be returned when looking for a list of missing labels (even in a flat ``Index``). By the way, ``pd.Series(range(2)).loc[[]]`` is currently incoherent with the docs, since it doesn't raise.\r\n\r\nOr alternatively, we could decide to be strict and raise a ``KeyError`` whenever _any of the provided labels_  (or partial labels, when indexing only on some levels) is missing.\r\n\r\nI understand that either of the two would break existing code. But the current compromise, in which we raise only if we do not find at least one label, seems to me a source of headaches both for the pandas user and for the pandas developer.\r\n\r\n(sorry if this was already discussed somewhere I couldn't find)"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/285329344",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-285329344",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 285329344,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTMyOTM0NA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T11:40:22Z",
    "updated_at": "2017-03-09T11:40:22Z",
    "author_association": "MEMBER",
    "body": "To come back to the original issue of `s.loc[['not', 'found']]`, the question is maybe also how this exactly should be interpreted. \r\nIt's a list of labels. But, is it a list of full labels (spanning all levels) (like `s.loc[[('not', 'found'), ('also', 'not')]]` but where you give wrong labels)? Or is it a list of labels for the first level (like `s.loc[(['not', 'found'], ), :]`)\r\n\r\nBecause the desired result may be different depending on how it is interpreted (or at least the current behaviour). And  `s.loc[['not', 'found']]` is a bit ambiguous."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/285333837",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-285333837",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 285333837,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTMzMzgzNw==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T12:03:44Z",
    "updated_at": "2017-03-09T12:03:44Z",
    "author_association": "MEMBER",
    "body": "@toobaz there is also a difference in the 'reindexing' behaviour of loc between single Index and MultiIndex. \r\nFor an Index, it is 'real' reindex:\r\n\r\n```\r\nIn [69]: s.reset_index(level=1, drop=True).loc[[1, 3]]\r\nOut[69]: \r\n1    0.0\r\n1    1.0\r\n3    NaN\r\ndtype: float64\r\n```\r\n\r\nso introducing NaN for the labels that did not exist in the original index. \r\nFor a MultiIndex, this is not done (following from the fact that pandas cannot know how to fill in the other levels), so here it is a 'reindex but only with the existing labels':\r\n\r\n```\r\nIn [70]: s.loc[[1, 3], :]\r\nOut[70]: \r\n1  a    0\r\n   b    1\r\ndtype: int64\r\n```\r\n\r\nSo following that idea, you could see the original case here as equivalent to indexing with an empty list:\r\n\r\n```\r\nIn [71]: s.reset_index(level=1, drop=True).loc[[]]\r\nOut[71]: Series([], dtype: int64)\r\n\r\nIn [73]: s.loc[[3, 4],:]\r\nOut[73]: Series([], dtype: int64)\r\n\r\nIn [74]: s.loc[[],:]\r\nOut[74]: Series([], dtype: int64)\r\n```\r\n\r\nand then the output *could* be interpreted as consistent ..."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/285335007",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-285335007",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 285335007,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTMzNTAwNw==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T12:09:49Z",
    "updated_at": "2017-03-09T12:10:06Z",
    "author_association": "MEMBER",
    "body": "> It's a list of labels. But, is it a list of full labels (spanning all levels) (like s.loc[[('not', 'found'), ('also', 'not')]] but where you give wrong labels)? Or is it a list of labels for the first level (like s.loc[(['not', 'found'], ), :])\r\n\r\nI gave it as granted that every time we ask ``s.something_involving_our(given_list)`` we want ``a_series_having_as_content([s.something_involving_our(x) for x in given_list])``.\r\n\r\nIn your first option, you have ``('not', 'found')`` as tuples, not lists. My understanding is that ``pandas`` draws a sharp distinction between lists and tuples (the former being collection, the latter being possibly composed keys), and that this is very useful! So I gave it as granted that we wanted the second."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/285336955",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-285336955",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 285336955,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTMzNjk1NQ==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T12:20:25Z",
    "updated_at": "2017-03-09T12:20:25Z",
    "author_association": "MEMBER",
    "body": "> So following that idea, you could see the original case here as equivalent to indexing with an empty list:\r\n> [...]\r\n> and then the output could be interpreted as consistent ...\r\n\r\nSure! And this reveals, strictly speaking, another very perverse (although well known) bug: since the docs say ``At least 1 of the labels for which you ask, must be in the index or a ``KeyError`` will be raised!``, and this is _false_ when you pass an empty list, then the empty list should raise too.\r\n\r\nNow, if I will be able to convince you that the current behaviour is perverse (I mean my proposal above about managing missing labels - but we can discuss it elsewhere), I will take care of required changes, and the problem will disappear, everything will be coherent, and I will be happy. But assuming this does not happen, we will update the docs stating \"_except when passing an empty list_\", and then again the expected behaviour for _this_ bug will be clear (since I am _not_ passing an empty list)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/285350206",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-285350206",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 285350206,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTM1MDIwNg==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T13:24:58Z",
    "updated_at": "2017-03-09T13:24:58Z",
    "author_association": "MEMBER",
    "body": "> In your first option, you have ('not', 'found') as tuples, not lists. \r\n\r\nNo, it is a list of tuples (`[('not', 'found'), ('also', 'not')]`), or a list of scalars (`['not', 'found']`), but both are a list.\r\n\r\n> I gave it as granted that every time we ask s.something_involving_our(given_list) we want a_series_having_as_content([s.something_involving_our(x) for x in given_list]).\r\n\r\nThat's maybe a good analogy to reason about the behaviour of a single list, yes. And to justify that `s.loc[[1, 2]]` works how it works (because you could say that this is actually interpreted as `s.loc[([1,2], slice(None))]`\r\n\r\n> Sure! And this reveals, strictly speaking, another very perverse (although well known) bug: since the docs say At least 1 of the labels for which you ask, must be in the index or aKeyErrorwill be raised!, and this is false when you pass an empty list, then the empty list should raise too.\r\n\r\nI am not sure we should call it a bug, as it could also be a design choice (although maybe a questionable one). But I would open a separate issue for that (focusing on the plain Index case). "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/285405198",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-285405198",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 285405198,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NTQwNTE5OA==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-09T16:37:00Z",
    "updated_at": "2017-03-09T16:48:26Z",
    "author_association": "MEMBER",
    "body": "> In your first option, you have ('not', 'found') as tuples, not lists.\r\n> \r\n> No, it is a list of tuples ([('not', 'found'), ('also', 'not')]), or a list of scalars (['not', 'found']), but both are a list.\r\n\r\nOK: you have tuples, I don't. Tuples (can) mean \"pieces of keys\" (one per level), lists _never_ do. Tuples can also contain lists (as in your example below), but they again mean \"pieces of keys\", except that for each level you have several pieces rather than only one. It is a beautiful convention without which I would never know what to expect from ``.loc[]`` on ``MultiIndex``: tuples go horizontally, lists go vertically.\r\n\r\n\r\n> That's maybe a good analogy to reason about the behaviour of a single list, yes. And to justify that s.loc[[1, 2]] works how it works (because you could say that this is actually interpreted as s.loc[([1,2], slice(None))]\r\n\r\nExactly!\r\n\r\n> I am not sure we should call it a bug, as it could also be a design choice (although maybe a questionable one).\r\n\r\nSorry, you are right, I know it's a design choice... I meant that as of now, it is just a _documentation_ bug (except that I would like to fix the code rather than the docs, but I agree to talk about this in a separate issue).\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/286146444",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-286146444",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 286146444,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjE0NjQ0NA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-13T15:40:51Z",
    "updated_at": "2017-03-13T15:40:51Z",
    "author_association": "MEMBER",
    "body": "> OK: you have tuples I don't. Tuples (can) mean \"pieces of keys\" (one per level), lists never do. Tuples can also contain lists (as in your example below), but they again mean \"pieces of keys\", except that for each level you have several pieces rather than only one. It is a beautiful convention without which I would never know what to expect from .loc[] on MultiIndex.\r\n\r\nThis part I don't fully understand. But we may be confused by each other terminology. \r\nI also don't have tuples in the actual issue we are discussing (apart from the tuples within the list), I only use them (if you mean the `s.loc[([1,2], slice(None))]`) to clarify how the list can be interpreted. As to me, that form is the 'fully specified' form that is non-ambiguous.\r\n\r\n> Tuples (can) mean \"pieces of keys\" (one per level), lists never do.\r\n\r\nWell, that is my question. Do lists never mean that? Because the result of `s.loc[[1, 2]]` also *looks* like the list is interpreted as a specification of the first level (is this what you mean with \"pieces of keys\"?)\r\n\r\nBy the way, the \r\n\r\n\r\n\r\n>>   I gave it as granted that every time we ask s.something_involving_our(given_list) we want a_series_having_as_content([s.something_involving_our(x) for x in given_list]).\r\n\r\n> That's maybe a good analogy to reason about the behaviour of a single list,\r\n\r\ndoes not fully hold if you have more than two levels:\r\n\r\n```\r\n\r\nIn [7]: midx = pd.MultiIndex.from_product([['A0', 'A1', 'A2'], ['B0', 'B1'], ['C0', 'C1']])\r\n\r\nIn [8]: s = pd.Series(range(len(midx)), index=midx)\r\n\r\n# a non-fully specified tuple works as a single element\r\nIn [9]: s[('A0', 'B0')]\r\nOut[9]: \r\nC0    0\r\nC1    1\r\ndtype: int64\r\n\r\n# but not as a list of those\r\nIn [10]: s[[('A0', 'B0'), ('A1', 'B1')]]\r\nOut[10]: \r\nA0  B0   NaN\r\nA1  B1   NaN\r\ndtype: float64\r\n```\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/286160671",
    "html_url": "https://github.com/pandas-dev/pandas/issues/15452#issuecomment-286160671",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/15452",
    "id": 286160671,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI4NjE2MDY3MQ==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-03-13T16:24:58Z",
    "updated_at": "2017-03-13T16:24:58Z",
    "author_association": "MEMBER",
    "body": "> This part I don't fully understand. But we may be confused by each other terminology.\r\n> I also don't have tuples in the actual issue we are discussing (apart from the tuples within the list)\r\n\r\nI was referring precisely to the tuples within the list\r\n\r\n\r\n\r\n\r\n> Tuples (can) mean \"pieces of keys\" (one per level), lists never do.\r\n> \r\n> Well, that is my question. Do lists never mean that? Because the result of s.loc[[1, 2]] also looks like the list is interpreted as a specification of the first level (is this what you mean with \"pieces of keys\"?)\r\n\r\nOK, seems like my wording was confusing. What I meant was: tuples broadcast across levels, lists never do. (By \"pieces of keys\" I meant \"different pieces of one same key\", or of multiple keys, but with emphasis that different components refer to different levels.)\r\n\r\n> That's maybe a good analogy to reason about the behaviour of a single list,\r\n> \r\n> does not fully hold if you have more than two levels:\r\n\r\nGood catch... I'm pretty sure we want to consider ``Out[10]`` as a bug. And more precisely:\r\n1. the current behaviour with missing labels is, in general, weird (and we will discuss separately)\r\n2. ... and it is the reason why ``.loc`` was made to act like ``.reindex`` when it does not find labels on ``MultiIndex``es (and I think this should be fixed too - it should at least act like ``.loc`` for those labels which it does find, and I think it is more in general documented - but we should also discuss this separately)\r\n3. ... but since in your example there are _no_ missing labels (they are incomplete, but not missing, precisely as if you did ``s[['A0', 'A1']]``), ``Out[10]`` is a bug even if you don't agree with me on fixing 1. and 2.\r\n\r\nYou don't even need the three levels to contradict me, try the following ;-)\r\n\r\n``` python\r\nIn [2]: s = pd.Series(range(6), index=pd.MultiIndex.from_product([['A0', 'A1', 'A2'], ['B0', 'B1']]))\r\n\r\nIn [3]: s.loc[[('A0',), ('A1',)]]\r\n```\r\n(clearly another bug - or the same, for what it matters)\r\n\r\n(By the way, before you take me more literally than I intended: I meant ``s.something_involving_our(given_list)`` limited to the case in which ``something_involving_our`` is a call to an indexer... the API is so big that any general statement about it should be easy to falsify ;-) )"
  }
]
