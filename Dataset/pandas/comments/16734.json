[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/309691379",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16734#issuecomment-309691379",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16734",
    "id": 309691379,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTY5MTM3OQ==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T09:03:24Z",
    "updated_at": "2017-06-20T09:03:24Z",
    "author_association": "MEMBER",
    "body": "> Label-based indexing without slicing should be possible with .loc even when the dataframe is not lexsorted\r\n\r\nNotice this is specific to indexing with lists (and booleans, but not single labels). Anyway, I'll push a PR in minutes."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/309692755",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16734#issuecomment-309692755",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16734",
    "id": 309692755,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTY5Mjc1NQ==",
    "user": {
      "login": "dr-leo",
      "id": 3160562,
      "node_id": "MDQ6VXNlcjMxNjA1NjI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3160562?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dr-leo",
      "html_url": "https://github.com/dr-leo",
      "followers_url": "https://api.github.com/users/dr-leo/followers",
      "following_url": "https://api.github.com/users/dr-leo/following{/other_user}",
      "gists_url": "https://api.github.com/users/dr-leo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dr-leo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dr-leo/subscriptions",
      "organizations_url": "https://api.github.com/users/dr-leo/orgs",
      "repos_url": "https://api.github.com/users/dr-leo/repos",
      "events_url": "https://api.github.com/users/dr-leo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dr-leo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T09:08:36Z",
    "updated_at": "2017-06-20T09:08:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "Great!\n\nTo add one perhaps self-evident corner case: in a multi-indexed df, ':'\nshould be permissible as well.\n\ndf.loc[['a', 'c'], :, ['two', 'one']]\n\nThis is not a tested code example. But the idea should be clear: If the\nslice captures the entire row/col, sorting should not be required either.\n\nAm 20.06.2017 um 11:03 schrieb Pietro Battiston:\n>\n>     Label-based indexing without slicing should be possible with .loc\n>     even when the dataframe is not lexsorted\n>\n> Notice this is specific to indexing with lists (and booleans, but not\n> single labels). Anyway, I'll push a PR in minutes.\n>\n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pandas-dev/pandas/issues/16734#issuecomment-309691379>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ADA58tH0g-2wYxOZpP_7dFMyrQ35Nzbxks5sF4r4gaJpZM4N_QR5>.\n>\n\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/309705579",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16734#issuecomment-309705579",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16734",
    "id": 309705579,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTcwNTU3OQ==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T09:58:56Z",
    "updated_at": "2017-06-20T09:58:56Z",
    "author_association": "MEMBER",
    "body": "> If the slice captures the entire row/col, sorting should not be required either.\r\n\r\nYes, the fix contemplates this use case."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/309709731",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16734#issuecomment-309709731",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16734",
    "id": 309709731,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTcwOTczMQ==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T10:17:20Z",
    "updated_at": "2017-06-20T10:17:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "well @toobaz pushed a fix, but ideally you would have a copy-pastable example in the top section. IOW is just code and not relying on external library."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/309712236",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16734#issuecomment-309712236",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16734",
    "id": 309712236,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwOTcxMjIzNg==",
    "user": {
      "login": "toobaz",
      "id": 1224492,
      "node_id": "MDQ6VXNlcjEyMjQ0OTI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1224492?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/toobaz",
      "html_url": "https://github.com/toobaz",
      "followers_url": "https://api.github.com/users/toobaz/followers",
      "following_url": "https://api.github.com/users/toobaz/following{/other_user}",
      "gists_url": "https://api.github.com/users/toobaz/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/toobaz/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/toobaz/subscriptions",
      "organizations_url": "https://api.github.com/users/toobaz/orgs",
      "repos_url": "https://api.github.com/users/toobaz/repos",
      "events_url": "https://api.github.com/users/toobaz/events{/privacy}",
      "received_events_url": "https://api.github.com/users/toobaz/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-20T10:28:34Z",
    "updated_at": "2017-06-20T10:28:34Z",
    "author_association": "MEMBER",
    "body": "For future reference:\r\n\r\n``` python\r\nIn [2]: _mklbl = lambda prefix, n: [\"%s%s\" % (prefix, i) for i in range(n)]\r\n\r\nIn [3]: index = MultiIndex.from_product([_mklbl('A', 4), _mklbl('B', 2),\r\n   ...:                                  _mklbl('C', 4), _mklbl('D', 2)])\r\n\r\nIn [4]: columns = MultiIndex.from_tuples([('a', 'foo'), ('a', 'bar'),\r\n   ...:                                   ('b', 'foo'), ('b', 'bah')],\r\n   ...:                                  names=['lvl0', 'lvl1'])\r\n\r\nIn [5]: df = DataFrame(-1, index=index, columns=columns)\r\n\r\nIn [6]: df.loc['A1', ('a', slice(None))]\r\n---------------------------------------------------------------------------\r\nUnsortedIndexError                        Traceback (most recent call last)\r\n<ipython-input-6-0160dbc496d0> in <module>()\r\n----> 1 df.loc['A1', ('a', slice(None))]\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in __getitem__(self, key)\r\n   1327             except (KeyError, IndexError):\r\n   1328                 pass\r\n-> 1329             return self._getitem_tuple(key)\r\n   1330         else:\r\n   1331             key = com._apply_if_callable(key, self.obj)\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_tuple(self, tup)\r\n    834     def _getitem_tuple(self, tup):\r\n    835         try:\r\n--> 836             return self._getitem_lowerdim(tup)\r\n    837         except IndexingError:\r\n    838             pass\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_lowerdim(self, tup)\r\n    946         # we may have a nested tuples indexer here\r\n    947         if self._is_nested_tuple_indexer(tup):\r\n--> 948             return self._getitem_nested_tuple(tup)\r\n    949 \r\n    950         # we maybe be using a tuple to represent multiple dimensions here\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_nested_tuple(self, tup)\r\n   1025 \r\n   1026             current_ndim = obj.ndim\r\n-> 1027             obj = getattr(obj, self.name)._getitem_axis(key, axis=axis)\r\n   1028             axis += 1\r\n   1029 \r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_axis(self, key, axis)\r\n   1547             # nested tuple slicing\r\n   1548             if is_nested_tuple(key, labels):\r\n-> 1549                 locs = labels.get_locs(key)\r\n   1550                 indexer = [slice(None)] * self.ndim\r\n   1551                 indexer[axis] = locs\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexes/multi.py in get_locs(self, tup)\r\n   2267                                      'to be fully lexsorted tuple len ({0}), '\r\n   2268                                      'lexsort depth ({1})'\r\n-> 2269                                      .format(len(tup), self.lexsort_depth))\r\n   2270 \r\n   2271         # indexer\r\n\r\nUnsortedIndexError: 'MultiIndex Slicing requires the index to be fully lexsorted tuple len (2), lexsort depth (1)'\r\n\r\nIn [7]: df.loc['A1', ('a', ['foo'])]\r\n---------------------------------------------------------------------------\r\nUnsortedIndexError                        Traceback (most recent call last)\r\n<ipython-input-7-84c90c00aa28> in <module>()\r\n----> 1 df.loc['A1', ('a', ['foo'])]\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in __getitem__(self, key)\r\n   1327             except (KeyError, IndexError):\r\n   1328                 pass\r\n-> 1329             return self._getitem_tuple(key)\r\n   1330         else:\r\n   1331             key = com._apply_if_callable(key, self.obj)\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_tuple(self, tup)\r\n    834     def _getitem_tuple(self, tup):\r\n    835         try:\r\n--> 836             return self._getitem_lowerdim(tup)\r\n    837         except IndexingError:\r\n    838             pass\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_lowerdim(self, tup)\r\n    946         # we may have a nested tuples indexer here\r\n    947         if self._is_nested_tuple_indexer(tup):\r\n--> 948             return self._getitem_nested_tuple(tup)\r\n    949 \r\n    950         # we maybe be using a tuple to represent multiple dimensions here\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_nested_tuple(self, tup)\r\n   1025 \r\n   1026             current_ndim = obj.ndim\r\n-> 1027             obj = getattr(obj, self.name)._getitem_axis(key, axis=axis)\r\n   1028             axis += 1\r\n   1029 \r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexing.py in _getitem_axis(self, key, axis)\r\n   1547             # nested tuple slicing\r\n   1548             if is_nested_tuple(key, labels):\r\n-> 1549                 locs = labels.get_locs(key)\r\n   1550                 indexer = [slice(None)] * self.ndim\r\n   1551                 indexer[axis] = locs\r\n\r\n/home/nobackup/repo/pandas/pandas/core/indexes/multi.py in get_locs(self, tup)\r\n   2267                                      'to be fully lexsorted tuple len ({0}), '\r\n   2268                                      'lexsort depth ({1})'\r\n-> 2269                                      .format(len(tup), self.lexsort_depth))\r\n   2270 \r\n   2271         # indexer\r\n\r\nUnsortedIndexError: 'MultiIndex Slicing requires the index to be fully lexsorted tuple len (2), lexsort depth (1)'\r\n\r\n```"
  }
]
