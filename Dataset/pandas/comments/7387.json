[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45416355",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7387#issuecomment-45416355",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7387",
    "id": 45416355,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NDE2MzU1",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-07T17:43:57Z",
    "updated_at": "2014-06-07T17:43:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "Here's a way to get started I think. Since `pd.Grouper` is already a pretty generic grouper in that it will return a `pd.TimeGrouper` (if `freq` is specified), its pretty easy to make this create a `pd.SplitGrouper` as needed. (more on this in a bit). This is essentially an implementation for this issue, rather than specific API recommendations (though I touch on this a bit)\n\nsomething like this:\n\n```\ndef DataFrame.split(self, grouper=None, **kwargs):\n\n    if grouper is None:\n        grouper = pd.Grouper(**kwargs)\n\n    return df.groupby(grouper).split()\n```\n\nand `Groupby.split` is equivalent of this (list using a `list` on a groupby object, but just returning the grp's themselves), so this is 'trivial'\n\n```\ndef split(self):\n    return [ grp for g, grp in self ]\n```\n\nSo then can easily add some more keyword args to the current `pd.Grouper`:\n\nhere is the current:\n\n```\nclass Grouper(object):\n    \"\"\"\n    A Grouper allows the user to specify a groupby instruction for a target object\n\n    This specification will select a column via the key parameter, or if the level and/or\n    axis parameters are given, a level of the index of the target object.\n\n    These are local specifications and will override 'global' settings, that is the parameters\n    axis and level which are passed to the groupby itself.\n\n    Parameters\n    ----------\n    key : string, defaults to None\n        groupby key, which selects the grouping column of the target\n    level : name/number, defaults to None\n        the level for the target index\n    freq : string / freqency object, defaults to None\n        This will groupby the specified frequency if the target selection (via key or level) is\n        a datetime-like object\n    axis : number/name of the axis, defaults to None\n    sort : boolean, default to False\n        whether to sort the resulting labels\n\n    additional kwargs to control time-like groupers (when freq is passed)\n\n    closed : closed end of interval; left or right\n    label : interval boundary to use for labeling; left or right\n    convention : {'start', 'end', 'e', 's'}\n        If grouper is PeriodIndex\n\n    Returns\n    -------\n    A specification for a groupby instruction\n```\n\nso `pd.SplitGrouper` simply create the groups (like `TimeGrouper` and `Grouper` do now)\n\nI would propose this functionaility:\n- `partition` and `pad` (stealing from [here](http://toolz.readthedocs.org/en/latest/api.html#toolz.itertoolz.partition), partition by n, these are both new keywords (#4059).\n  \n  I guess `partition` could be also be a tuple, e.g. `(2,3)` to specify that I want n groups to have these lengths (and then repeat)\n- `partition` and `freq` (only `partition` is new): resample first `partition` of that freq (could also take `-partition` for last partiion of that freq) (#3685, maybe #936); this could also be a new keyword `n` to not confuse it with `parttion`\n- `partition` and `sort` (only `partition` is new): with `sort=False` would create groups but do it similarly to `itertools.groupby` (e.g. not reduce the groups, but do them in order)  (#5494), could also take `sort='by_group'` to make this unambiguous\n\nsomething like this:\n\n```\nclass SplitGrouper(Grouper):\n\n    Parameters\n    ----------\n    partition : integer, default None, number of rows to include in each group\n    pad : (need to have options from toolz), how to pad groups specified by partition\n```\n\nIf `partition` has too many meanings, then could add a `n` as well. (but would need to define these cases).\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45418458",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7387#issuecomment-45418458",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7387",
    "id": 45418458,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NDE4NDU4",
    "user": {
      "login": "cpcloud",
      "id": 417981,
      "node_id": "MDQ6VXNlcjQxNzk4MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/417981?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cpcloud",
      "html_url": "https://github.com/cpcloud",
      "followers_url": "https://api.github.com/users/cpcloud/followers",
      "following_url": "https://api.github.com/users/cpcloud/following{/other_user}",
      "gists_url": "https://api.github.com/users/cpcloud/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cpcloud/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cpcloud/subscriptions",
      "organizations_url": "https://api.github.com/users/cpcloud/orgs",
      "repos_url": "https://api.github.com/users/cpcloud/repos",
      "events_url": "https://api.github.com/users/cpcloud/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cpcloud/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-07T19:08:04Z",
    "updated_at": "2014-06-07T19:08:25Z",
    "author_association": "MEMBER",
    "body": "looks good, only suggestion i have is to use the [`partition_all`](http://toolz.readthedocs.org/en/latest/api.html#toolz.itertoolz.partition_all) behavior instead of having a `pad` arg, i.e., instead of padding, just split into `partition` number groups possibly of unequal # of rows\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45418476",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7387#issuecomment-45418476",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7387",
    "id": 45418476,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NDE4NDc2",
    "user": {
      "login": "cpcloud",
      "id": 417981,
      "node_id": "MDQ6VXNlcjQxNzk4MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/417981?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cpcloud",
      "html_url": "https://github.com/cpcloud",
      "followers_url": "https://api.github.com/users/cpcloud/followers",
      "following_url": "https://api.github.com/users/cpcloud/following{/other_user}",
      "gists_url": "https://api.github.com/users/cpcloud/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cpcloud/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cpcloud/subscriptions",
      "organizations_url": "https://api.github.com/users/cpcloud/orgs",
      "repos_url": "https://api.github.com/users/cpcloud/repos",
      "events_url": "https://api.github.com/users/cpcloud/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cpcloud/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-07T19:08:49Z",
    "updated_at": "2014-06-07T19:08:49Z",
    "author_association": "MEMBER",
    "body": "could pad if it's a tuple tho\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45418764",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7387#issuecomment-45418764",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7387",
    "id": 45418764,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1NDE4NzY0",
    "user": {
      "login": "dsm054",
      "id": 980054,
      "node_id": "MDQ6VXNlcjk4MDA1NA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/980054?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dsm054",
      "html_url": "https://github.com/dsm054",
      "followers_url": "https://api.github.com/users/dsm054/followers",
      "following_url": "https://api.github.com/users/dsm054/following{/other_user}",
      "gists_url": "https://api.github.com/users/dsm054/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dsm054/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dsm054/subscriptions",
      "organizations_url": "https://api.github.com/users/dsm054/orgs",
      "repos_url": "https://api.github.com/users/dsm054/repos",
      "events_url": "https://api.github.com/users/dsm054/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dsm054/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-07T19:20:40Z",
    "updated_at": "2014-06-07T19:20:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'll make some time to dig through the pandas questions on SO and look for use cases that we should cover while we're addressing this.\n"
  }
]
