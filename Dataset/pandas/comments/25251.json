[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/462087477",
    "html_url": "https://github.com/pandas-dev/pandas/issues/25251#issuecomment-462087477",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/25251",
    "id": 462087477,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjA4NzQ3Nw==",
    "user": {
      "login": "gfyoung",
      "id": 9273653,
      "node_id": "MDQ6VXNlcjkyNzM2NTM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/9273653?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gfyoung",
      "html_url": "https://github.com/gfyoung",
      "followers_url": "https://api.github.com/users/gfyoung/followers",
      "following_url": "https://api.github.com/users/gfyoung/following{/other_user}",
      "gists_url": "https://api.github.com/users/gfyoung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gfyoung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gfyoung/subscriptions",
      "organizations_url": "https://api.github.com/users/gfyoung/orgs",
      "repos_url": "https://api.github.com/users/gfyoung/repos",
      "events_url": "https://api.github.com/users/gfyoung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gfyoung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-09T23:04:07Z",
    "updated_at": "2019-02-09T23:04:07Z",
    "author_association": "MEMBER",
    "body": "cc @jreback "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/462205296",
    "html_url": "https://github.com/pandas-dev/pandas/issues/25251#issuecomment-462205296",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/25251",
    "id": 462205296,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjIwNTI5Ng==",
    "user": {
      "login": "nmusolino",
      "id": 3150861,
      "node_id": "MDQ6VXNlcjMxNTA4NjE=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/3150861?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nmusolino",
      "html_url": "https://github.com/nmusolino",
      "followers_url": "https://api.github.com/users/nmusolino/followers",
      "following_url": "https://api.github.com/users/nmusolino/following{/other_user}",
      "gists_url": "https://api.github.com/users/nmusolino/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nmusolino/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nmusolino/subscriptions",
      "organizations_url": "https://api.github.com/users/nmusolino/orgs",
      "repos_url": "https://api.github.com/users/nmusolino/repos",
      "events_url": "https://api.github.com/users/nmusolino/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nmusolino/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-11T02:24:23Z",
    "updated_at": "2019-02-11T02:24:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "As a genuine question, how does this compare to using `DataFrame.assign()`?  For example, the zero-to-one, one-to-one, and many-to-one examples:\r\n\r\n```\r\ndf.mapping([None, 'five', transform=5])\r\ndf.mapping([('num', 'translated', translate)])\r\ndf.mapping([(['num', 'name'], 'num-name', lambda row: '-'.join(row.apply(str)))])\r\n```\r\n\r\ncould be written:\r\n\r\n```\r\ndf.assign(**{\r\n    'five': 5,\r\n    'translated': translate(df['num']),\r\n    'num-name': df['num'].astype(str) + df['name'],\r\n})\r\n```\r\n\r\n(`assign` also takes callables for cases where the dataframe is an intermediate value.)\r\n\r\nI could see some cool possibilities if the mapper objects represented deferred operations, and only computed the new columns on an as-needed basis or something like that.\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/462402081",
    "html_url": "https://github.com/pandas-dev/pandas/issues/25251#issuecomment-462402081",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/25251",
    "id": 462402081,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjQwMjA4MQ==",
    "user": {
      "login": "gnilrets",
      "id": 2371577,
      "node_id": "MDQ6VXNlcjIzNzE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2371577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gnilrets",
      "html_url": "https://github.com/gnilrets",
      "followers_url": "https://api.github.com/users/gnilrets/followers",
      "following_url": "https://api.github.com/users/gnilrets/following{/other_user}",
      "gists_url": "https://api.github.com/users/gnilrets/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gnilrets/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gnilrets/subscriptions",
      "organizations_url": "https://api.github.com/users/gnilrets/orgs",
      "repos_url": "https://api.github.com/users/gnilrets/repos",
      "events_url": "https://api.github.com/users/gnilrets/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gnilrets/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-11T16:49:41Z",
    "updated_at": "2019-02-11T16:49:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "@nmusolino - This most important difference between mapping and assign is that mapping can redirect records that have errors.  I use pandas for a lot of ETL work, and when we get garbage or unexpected data in one field, we don't necessarily want that to prevent transforming and loading data for all the other records.  So instead, records with mapping errors are redirected to an error reporting mechanism.\r\n\r\nOne of the more common scenarios I run into is poorly formatted dates:\r\n\r\n```\r\ndf = pd.DataFrame({'my_date_str': ['2017-01-03','garbage data','2017-03-22']})\r\nmapped_df = df.mapping(\r\n    [\r\n        ('my_date_str', 'my_date', lambda v: datetime.datetime.strptime(v, '%Y-%m-%d'))\r\n    ],\r\n    on_error='redirect'\r\n)\r\n\r\nprint(mapped_df.mapped)\r\n#                my_date\r\n# 0  2017-01-03 00:00:00\r\n# 2  2017-03-22 00:00:00\r\n\r\nprint(mapped_df.errors)\r\n#     my_date_str                                          __error__\r\n# 1  garbage data  {'msg': 'ValueError(garbage data): time data '...\r\n```\r\n\r\nAdditionally, something just rubs me wrong about having to reference the dataframe variable in so many places when using assign.  I  try to give my variables descriptive names, and sometimes they can get long, so writing something like this can be cumbersome:\r\n\r\n```\r\nmy_really_important_df.assign(**{\r\n    'five': 5,\r\n    'translated': translate(my_really_important_df['num']),\r\n    'num-name': my_really_important_df['num'].astype(str) + my_really_important_df['name'],\r\n})\r\n```\r\n\r\n... in which case, you'll usually end up creating temporary variables or something (`tmp_df = my_really_important_df` which is equally as icky."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/466262292",
    "html_url": "https://github.com/pandas-dev/pandas/issues/25251#issuecomment-466262292",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/25251",
    "id": 466262292,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NjI2MjI5Mg==",
    "user": {
      "login": "nmusolino",
      "id": 3150861,
      "node_id": "MDQ6VXNlcjMxNTA4NjE=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/3150861?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/nmusolino",
      "html_url": "https://github.com/nmusolino",
      "followers_url": "https://api.github.com/users/nmusolino/followers",
      "following_url": "https://api.github.com/users/nmusolino/following{/other_user}",
      "gists_url": "https://api.github.com/users/nmusolino/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/nmusolino/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/nmusolino/subscriptions",
      "organizations_url": "https://api.github.com/users/nmusolino/orgs",
      "repos_url": "https://api.github.com/users/nmusolino/repos",
      "events_url": "https://api.github.com/users/nmusolino/events{/privacy}",
      "received_events_url": "https://api.github.com/users/nmusolino/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-02-22T03:39:48Z",
    "updated_at": "2019-02-22T03:39:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "Sorry for the delayed reply.  Please note that I write all this as a pandas user, not as someone with any authority in the project.\r\n\r\nI like the declarative look of the library, and the organized error reporting.  \r\n\r\nPandas already has a few ways to compute/insert things in DataFrames, like [`DataFrame.apply()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html), [`DataFrame.assign()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.assign.html), and [`DataFrame.eval()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.eval.html).\r\n\r\nI'd also add that error reporting needs (saving error info in containers, versus logging, versus raising for particular exceptions) will be different for everyone.  It's probably hard for pandas to provide an error-handling mechanism that is fully general, other than simply letting users employ the full range of Python language facilities.\r\n\r\nOne implementation note is that the current mapper library seems to operate row-wise (I could be wrong), while pandas generally tries to steer users to column-wise operations.\r\n\r\nOverall, I think it's great to build a library like this on top of pandas.  Let a thousand flowers bloom, and if this kind of tool is helpful for organizing ETL operations with occasional failures, I think it's totally fine to have it as a supplemental tool for working with pandas.\r\n\r\nPS, some good news about `DataFrame.assign()`:  you can actually pass a callable (e.g. a lambda), which allows a user to add columns to frames without using their name.  \r\n\r\n```python\r\nmy_important_df.reset_index().assign(**{'num-name': lambda df: df['num'].astype('str') + df['name']})\r\n```\r\n\r\n"
  }
]
