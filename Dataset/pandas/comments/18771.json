[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/351562862",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18771#issuecomment-351562862",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18771",
    "id": 351562862,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTU2Mjg2Mg==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-13T23:50:54Z",
    "updated_at": "2017-12-13T23:50:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "why do you think you could hash a mutable object? generically hashing random objects is hard. and not likely to be supported."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/351565160",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18771#issuecomment-351565160",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18771",
    "id": 351565160,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTU2NTE2MA==",
    "user": {
      "login": "jstray",
      "id": 1028628,
      "node_id": "MDQ6VXNlcjEwMjg2Mjg=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1028628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jstray",
      "html_url": "https://github.com/jstray",
      "followers_url": "https://api.github.com/users/jstray/followers",
      "following_url": "https://api.github.com/users/jstray/following{/other_user}",
      "gists_url": "https://api.github.com/users/jstray/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jstray/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jstray/subscriptions",
      "organizations_url": "https://api.github.com/users/jstray/orgs",
      "repos_url": "https://api.github.com/users/jstray/repos",
      "events_url": "https://api.github.com/users/jstray/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jstray/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-14T00:03:02Z",
    "updated_at": "2017-12-14T00:03:02Z",
    "author_association": "NONE",
    "body": "Because I want to cache tables to disk. The hash value allows me to check if the current table version is different from the one on disk, thus avoiding large unnecessary writes.\r\n\r\nWhile I have you -- how do I tell if a column is a dict or other complex type? Loading from e.g. json just gives me \"object\" type for every column."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/351599236",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18771#issuecomment-351599236",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18771",
    "id": 351599236,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTU5OTIzNg==",
    "user": {
      "login": "jstray",
      "id": 1028628,
      "node_id": "MDQ6VXNlcjEwMjg2Mjg=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1028628?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jstray",
      "html_url": "https://github.com/jstray",
      "followers_url": "https://api.github.com/users/jstray/followers",
      "following_url": "https://api.github.com/users/jstray/following{/other_user}",
      "gists_url": "https://api.github.com/users/jstray/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jstray/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jstray/subscriptions",
      "organizations_url": "https://api.github.com/users/jstray/orgs",
      "repos_url": "https://api.github.com/users/jstray/repos",
      "events_url": "https://api.github.com/users/jstray/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jstray/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-14T03:36:45Z",
    "updated_at": "2017-12-14T03:36:45Z",
    "author_association": "NONE",
    "body": "I have to find another way for the moment (string hash on to_csv, probably), but I'm wondering if I could modify hash_pandas_object to do canonicalization using the same strategy as .equals()"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/351682903",
    "html_url": "https://github.com/pandas-dev/pandas/issues/18771#issuecomment-351682903",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/18771",
    "id": 351682903,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1MTY4MjkwMw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-14T11:18:40Z",
    "updated_at": "2017-12-14T11:18:40Z",
    "author_association": "CONTRIBUTOR",
    "body": "strings & python objects are stored as ``object`` dtype. you can do this to differentiate strings and python objects themselves. There is no good way to deeply introspect these though. Working with non-strings is generally not supported.\r\n\r\n```\r\nIn [27]: data =  [{'a': 10, 'b': {'c': 20, 'd': 30}}, {'a': 100, 'b': {'c': 200, 'd': 300}}]\r\n    ...: df = pd.DataFrame(data)\r\n    ...: \r\n\r\nIn [28]: df.apply(pd.api.types.infer_dtype)\r\nOut[28]: \r\na    integer\r\nb      mixed\r\ndtype: object\r\n```"
  }
]
