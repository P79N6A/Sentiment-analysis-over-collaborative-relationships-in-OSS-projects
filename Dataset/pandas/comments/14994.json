[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269249613",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269249613",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269249613,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTI0OTYxMw==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-26T23:45:12Z",
    "updated_at": "2016-12-26T23:45:12Z",
    "author_association": "MEMBER",
    "body": "Good idea! Added check to `fillna` as well. Will ping again on green."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269260621",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269260621",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269260621,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTI2MDYyMQ==",
    "user": {
      "login": "codecov-io",
      "id": 8655789,
      "node_id": "MDQ6VXNlcjg2NTU3ODk=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8655789?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/codecov-io",
      "html_url": "https://github.com/codecov-io",
      "followers_url": "https://api.github.com/users/codecov-io/followers",
      "following_url": "https://api.github.com/users/codecov-io/following{/other_user}",
      "gists_url": "https://api.github.com/users/codecov-io/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/codecov-io/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/codecov-io/subscriptions",
      "organizations_url": "https://api.github.com/users/codecov-io/orgs",
      "repos_url": "https://api.github.com/users/codecov-io/repos",
      "events_url": "https://api.github.com/users/codecov-io/events{/privacy}",
      "received_events_url": "https://api.github.com/users/codecov-io/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-27T02:41:03Z",
    "updated_at": "2017-02-13T03:48:59Z",
    "author_association": "NONE",
    "body": "# [Codecov](https://codecov.io/gh/pandas-dev/pandas/pull/14994?src=pr&el=h1) Report\n> Merging [#14994](https://codecov.io/gh/pandas-dev/pandas/pull/14994?src=pr&el=desc) into [master](https://codecov.io/gh/pandas-dev/pandas/commit/dda3c4292b28d4dbead8bb6ae9927373aea9fe23?src=pr&el=desc) will **increase** coverage by `<.01%`.\n> The diff coverage is `100%`.\n\n\n```diff\n@@            Coverage Diff             @@\n##           master   #14994      +/-   ##\n==========================================\n+ Coverage   90.42%   90.42%   +<.01%     \n==========================================\n  Files         134      134              \n  Lines       49357    49365       +8     \n==========================================\n+ Hits        44632    44640       +8     \n  Misses       4725     4725\n```\n\n\n| [Impacted Files](https://codecov.io/gh/pandas-dev/pandas/pull/14994?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [pandas/core/generic.py](https://codecov.io/gh/pandas-dev/pandas/compare/dda3c4292b28d4dbead8bb6ae9927373aea9fe23...c1790eeb3f5f65f1f40e489a7c2d075eb6cf1dc3?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvZ2VuZXJpYy5weQ==) | `96.33% <ø> (ø)` | :white_check_mark: |\n| [pandas/core/missing.py](https://codecov.io/gh/pandas-dev/pandas/compare/dda3c4292b28d4dbead8bb6ae9927373aea9fe23...c1790eeb3f5f65f1f40e489a7c2d075eb6cf1dc3?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvbWlzc2luZy5weQ==) | `84.95% <100%> (+0.19%)` | :white_check_mark: |\n| [pandas/core/internals.py](https://codecov.io/gh/pandas-dev/pandas/compare/dda3c4292b28d4dbead8bb6ae9927373aea9fe23...c1790eeb3f5f65f1f40e489a7c2d075eb6cf1dc3?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvaW50ZXJuYWxzLnB5) | `94.15% <100%> (ø)` | :white_check_mark: |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/pandas-dev/pandas/pull/14994?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/pandas-dev/pandas/pull/14994?src=pr&el=footer). Last update [dda3c42...c1790ee](https://codecov.io/gh/pandas-dev/pandas/compare/dda3c4292b28d4dbead8bb6ae9927373aea9fe23...c1790eeb3f5f65f1f40e489a7c2d075eb6cf1dc3?el=footer&src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269263072",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269263072",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269263072,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTI2MzA3Mg==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-27T03:12:13Z",
    "updated_at": "2016-12-27T03:12:13Z",
    "author_association": "MEMBER",
    "body": "Ping all green"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269317218",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269317218",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269317218,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTMxNzIxOA==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-27T12:03:25Z",
    "updated_at": "2016-12-27T12:04:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "ok these need to be change here instead: https://github.com/pandas-dev/pandas/blob/master/pandas/src/algos_common_helper.pxi.in#L85 (there are 4 places where this is hit). This is more appropriate as we are already checking the limit and its closer to the actual code path.\r\n\r\nI think you need some more tests for < 0 (which currently should raise), and == 0 (which I think you added)"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269722248",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269722248",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269722248,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTcyMjI0OA==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-30T02:09:17Z",
    "updated_at": "2016-12-30T02:09:17Z",
    "author_association": "MEMBER",
    "body": "Sorry for the delay in response.\r\n\r\nI am not too familiar with the cython portion of the code base. Interestingly in master (0d3ecfa), if negative limits are used in `fillna` or `interpolate`, an error is not thrown. Is the cython code supposed to throw an error here?\r\n\r\n```\r\nIn [2]: s = pd.Series([1,2,3,None])\r\n\r\nIn [3]: s.interpolate(limit=-1)\r\nOut[3]: \r\n0    1.0\r\n1    2.0\r\n2    3.0\r\n3    NaN\r\ndtype: float64\r\n\r\nIn [4]: s.fillna(4, limit=-1)\r\nOut[4]: \r\n0    1.0\r\n1    2.0\r\n2    3.0\r\n3    NaN\r\ndtype: float64\r\n```\r\n\r\nAdded tests on my branch to test the negative limits."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269722866",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269722866",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269722866,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTcyMjg2Ng==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-30T02:17:41Z",
    "updated_at": "2016-12-30T02:17:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "it should but might be trapped somewhere"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269723640",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269723640",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269723640,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTcyMzY0MA==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-30T02:26:01Z",
    "updated_at": "2016-12-30T02:26:01Z",
    "author_association": "MEMBER",
    "body": "Ah, possibly lost in a `try`/`except`?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/269773087",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-269773087",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 269773087,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2OTc3MzA4Nw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-12-30T13:43:55Z",
    "updated_at": "2016-12-30T13:43:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mroeschke somewhere, you will have to trace it."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/270056071",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-270056071",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 270056071,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3MDA1NjA3MQ==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-03T06:03:31Z",
    "updated_at": "2017-01-03T06:03:31Z",
    "author_association": "MEMBER",
    "body": "So I traced `.fillna(4, limit=-1)`:\r\n<details>\r\n\r\n```\r\n--- modulename: series, funcname: fillna\r\nseries.py(2366):         return super(Series, self).fillna(value=value, method=method,\r\nseries.py(2367):                                           axis=axis, inplace=inplace,\r\nseries.py(2368):                                           limit=limit, downcast=downcast,\r\nseries.py(2369):                                           **kwargs)\r\n--- modulename: generic, funcname: fillna\r\ngeneric.py(3260):         if isinstance(value, (list, tuple)):\r\ngeneric.py(3263):         self._consolidate_inplace()\r\n--- modulename: generic, funcname: _consolidate_inplace\r\ngeneric.py(2855):         def f():\r\ngeneric.py(2858):         self._protect_consolidate(f)\r\n--- modulename: generic, funcname: _protect_consolidate\r\ngeneric.py(2846):         blocks_before = len(self._data.blocks)\r\ngeneric.py(2847):         result = f()\r\n--- modulename: generic, funcname: f\r\ngeneric.py(2856):             self._data = self._data.consolidate()\r\n--- modulename: internals, funcname: consolidate\r\ninternals.py(3522):         if self.is_consolidated():\r\n--- modulename: internals, funcname: is_consolidated\r\ninternals.py(4199):         return True\r\ninternals.py(3523):             return self\r\n--- modulename: generic, funcname: __setattr__\r\ngeneric.py(2812):         try:\r\ngeneric.py(2813):             object.__getattribute__(self, name)\r\ngeneric.py(2814):             return object.__setattr__(self, name, value)\r\ngeneric.py(2848):         if len(self._data.blocks) != blocks_before:\r\ngeneric.py(2850):         return result\r\ngeneric.py(3267):         if axis is None:\r\ngeneric.py(3268):             axis = 0\r\ngeneric.py(3269):         axis = self._get_axis_number(axis)\r\n--- modulename: generic, funcname: _get_axis_number\r\ngeneric.py(328):         axis = self._AXIS_ALIASES.get(axis, axis)\r\ngeneric.py(329):         if is_integer(axis):\r\ngeneric.py(330):             if axis in self._AXIS_NAMES:\r\ngeneric.py(331):                 return axis\r\ngeneric.py(3270):         method = missing.clean_fill_method(method)\r\n--- modulename: missing, funcname: clean_fill_method\r\nmissing.py(68):     if method in [None, 'asfreq']:\r\nmissing.py(69):         return None\r\ngeneric.py(3272):         from pandas import DataFrame\r\ngeneric.py(3273):         if value is None:\r\ngeneric.py(3309):             if method is not None:\r\ngeneric.py(3312):             if len(self._get_axis(axis)) == 0:\r\n--- modulename: generic, funcname: _get_axis\r\ngeneric.py(354):         name = self._get_axis_name(axis)\r\n--- modulename: generic, funcname: _get_axis_name\r\ngeneric.py(341):         axis = self._AXIS_ALIASES.get(axis, axis)\r\ngeneric.py(342):         if isinstance(axis, string_types):\r\ngeneric.py(346):             try:\r\ngeneric.py(347):                 return self._AXIS_NAMES[axis]\r\ngeneric.py(355):         return getattr(self, name)\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\ngeneric.py(3315):             if self.ndim == 1:\r\n--- modulename: base, funcname: ndim\r\nbase.py(824):         return 1\r\ngeneric.py(3316):                 if isinstance(value, (dict, ABCSeries)):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\ngeneric.py(3319):                 elif not is_list_like(value):\r\n--- modulename: inference, funcname: is_list_like\r\ninference.py(56):     return (hasattr(arg, '__iter__') and\r\ngeneric.py(3320):                     pass\r\ngeneric.py(3325):                 new_data = self._data.fillna(value=value, limit=limit,\r\ngeneric.py(3326):                                              inplace=inplace,\r\ngeneric.py(3327):                                              downcast=downcast)\r\n--- modulename: internals, funcname: fillna\r\ninternals.py(3184):         return self.apply('fillna', **kwargs)\r\n--- modulename: internals, funcname: apply\r\ninternals.py(3001):         result_blocks = []\r\ninternals.py(3004):         if filter is not None:\r\ninternals.py(3012):         if consolidate:\r\ninternals.py(3013):             self._consolidate_inplace()\r\n--- modulename: internals, funcname: _consolidate_inplace\r\ninternals.py(4205):         pass\r\ninternals.py(3015):         if f == 'where':\r\ninternals.py(3021):         elif f == 'putmask':\r\ninternals.py(3027):         elif f == 'eval':\r\ninternals.py(3030):         elif f == 'fillna':\r\ninternals.py(3033):             align_copy = False\r\ninternals.py(3034):             align_keys = ['value']\r\ninternals.py(3038):         aligned_args = dict((k, kwargs[k])\r\ninternals.py(3039):                             for k in align_keys\r\n--- modulename: internals, funcname: <genexpr>\r\ninternals.py(3038):         aligned_args = dict((k, kwargs[k])\r\ninternals.py(3039):                             for k in align_keys\r\ninternals.py(3040):                             if hasattr(kwargs[k], 'reindex_axis'))\r\ninternals.py(3038):         aligned_args = dict((k, kwargs[k])\r\ninternals.py(3042):         for b in self.blocks:\r\ninternals.py(3043):             if filter is not None:\r\ninternals.py(3048):             if aligned_args:\r\ninternals.py(3056):             kwargs['mgr'] = self\r\ninternals.py(3057):             applied = getattr(b, f)(**kwargs)\r\n--- modulename: internals, funcname: fillna\r\ninternals.py(364):         if not self._can_hold_na:\r\ninternals.py(370):         original_value = value\r\ninternals.py(371):         mask = isnull(self.values)\r\n--- modulename: missing, funcname: isnull\r\nmissing.py(44):     return _isnull(obj)\r\n--- modulename: missing, funcname: _isnull_new\r\nmissing.py(48):     if is_scalar(obj):\r\nmissing.py(51):     elif isinstance(obj, ABCMultiIndex):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(53):     elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(54):         return _isnull_ndarraylike(obj)\r\n--- modulename: missing, funcname: _isnull_ndarraylike\r\nmissing.py(121):     values = getattr(obj, 'values', obj)\r\nmissing.py(122):     dtype = values.dtype\r\nmissing.py(124):     if is_string_dtype(dtype):\r\n--- modulename: common, funcname: is_string_dtype\r\ncommon.py(105):     dtype = _get_dtype(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype\r\ncommon.py(345):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(346):         return arr_or_dtype\r\ncommon.py(106):     return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\r\nmissing.py(142):     elif needs_i8_conversion(obj):\r\n--- modulename: common, funcname: needs_i8_conversion\r\ncommon.py(276):     return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime_or_timedelta_dtype\r\ncommon.py(200):     tipo = _get_dtype_type(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype_type\r\ncommon.py(369):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(371):     elif isinstance(arr_or_dtype, type):\r\ncommon.py(373):     elif isinstance(arr_or_dtype, CategoricalDtype):\r\ncommon.py(375):     elif isinstance(arr_or_dtype, DatetimeTZDtype):\r\ncommon.py(377):     elif isinstance(arr_or_dtype, PeriodDtype):\r\ncommon.py(379):     elif isinstance(arr_or_dtype, string_types):\r\ncommon.py(387):     try:\r\ncommon.py(388):         return arr_or_dtype.dtype.type\r\ncommon.py(201):     return issubclass(tipo, (np.datetime64, np.timedelta64))\r\ncommon.py(277):             is_datetime64tz_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime64tz_dtype\r\ncommon.py(88):     return DatetimeTZDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\ncommon.py(278):             is_period_dtype(arr_or_dtype))\r\n--- modulename: common, funcname: is_period_dtype\r\ncommon.py(97):     return PeriodDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(354):         if isinstance(dtype, compat.string_types):\r\ndtypes.py(367):         return super(PeriodDtype, cls).is_dtype(dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\nmissing.py(146):         result = np.isnan(values)\r\nmissing.py(149):     if isinstance(obj, ABCSeries):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(153):     return result\r\ninternals.py(372):         if limit is not None:\r\ninternals.py(373):             if self.ndim > 2:\r\ninternals.py(376):             mask[mask.cumsum(self.ndim - 1) > limit] = False\r\ninternals.py(379):         try:\r\ninternals.py(380):             values, _, value, _ = self._try_coerce_args(self.values, value)\r\n--- modulename: internals, funcname: _try_coerce_args\r\ninternals.py(576):         return values, False, other, False\r\ninternals.py(381):             blocks = self.putmask(mask, value, inplace=inplace)\r\n--- modulename: internals, funcname: putmask\r\ninternals.py(802):         new_values = self.values if inplace else self.values.copy()\r\ninternals.py(804):         if hasattr(new, 'reindex_axis'):\r\ninternals.py(807):         if hasattr(mask, 'reindex_axis'):\r\ninternals.py(811):         if not is_list_like(new) and isnull(new) and not self.is_object:\r\n--- modulename: inference, funcname: is_list_like\r\ninference.py(56):     return (hasattr(arg, '__iter__') and\r\n--- modulename: missing, funcname: isnull\r\nmissing.py(44):     return _isnull(obj)\r\n--- modulename: missing, funcname: _isnull_new\r\nmissing.py(48):     if is_scalar(obj):\r\nmissing.py(49):         return lib.checknull(obj)\r\ninternals.py(814):         if self._can_hold_element(new):\r\n--- modulename: internals, funcname: _can_hold_element\r\ninternals.py(1555):         if is_list_like(element):\r\n--- modulename: inference, funcname: is_list_like\r\ninference.py(56):     return (hasattr(arg, '__iter__') and\r\ninternals.py(1560):         return (isinstance(element, (float, int, np.float_, np.int_)) and\r\ninternals.py(1561):                 not isinstance(element, (bool, np.bool_, datetime, timedelta,\r\ninternals.py(1562):                                          np.datetime64, np.timedelta64)))\r\ninternals.py(815):             if transpose:\r\ninternals.py(818):             new = self._try_cast(new)\r\n--- modulename: internals, funcname: _try_cast\r\ninternals.py(1565):         try:\r\ninternals.py(1566):             return float(element)\r\ninternals.py(822):             if getattr(new, 'ndim', 0) >= 1:\r\ninternals.py(828):             np.putmask(new_values, mask, new)\r\ninternals.py(882):         if inplace:\r\ninternals.py(885):         if transpose:\r\ninternals.py(888):         return [self.make_block(new_values, fastpath=True)]\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(195):         if placement is None:\r\ninternals.py(196):             placement = self.mgr_locs\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(197):         if ndim is None:\r\ninternals.py(198):             ndim = self.ndim\r\ninternals.py(200):         return make_block(values, placement=placement, ndim=ndim, **kwargs)\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(2652):     if klass is None:\r\ninternals.py(2653):         dtype = dtype or values.dtype\r\ninternals.py(2654):         vtype = dtype.type\r\ninternals.py(2656):         if isinstance(values, SparseArray):\r\ninternals.py(2658):         elif issubclass(vtype, np.floating):\r\ninternals.py(2659):             klass = FloatBlock\r\ninternals.py(2686):     return klass(values, ndim=ndim, fastpath=fastpath, placement=placement)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(97):         if ndim is None:\r\ninternals.py(99):         elif values.ndim != ndim:\r\ninternals.py(101):         self.ndim = ndim\r\ninternals.py(103):         self.mgr_locs = placement\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(218):         if not isinstance(new_mgr_locs, BlockPlacement):\r\ninternals.py(221):         self._mgr_locs = new_mgr_locs\r\ninternals.py(104):         self.values = values\r\ninternals.py(106):         if ndim and len(self.mgr_locs) != len(self.values):\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(382):             blocks = [b.make_block(values=self._try_coerce_result(b.values))\r\ninternals.py(383):                       for b in blocks]\r\n--- modulename: internals, funcname: _try_coerce_result\r\ninternals.py(580):         return result\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(195):         if placement is None:\r\ninternals.py(196):             placement = self.mgr_locs\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(197):         if ndim is None:\r\ninternals.py(198):             ndim = self.ndim\r\ninternals.py(200):         return make_block(values, placement=placement, ndim=ndim, **kwargs)\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(2652):     if klass is None:\r\ninternals.py(2653):         dtype = dtype or values.dtype\r\ninternals.py(2654):         vtype = dtype.type\r\ninternals.py(2656):         if isinstance(values, SparseArray):\r\ninternals.py(2658):         elif issubclass(vtype, np.floating):\r\ninternals.py(2659):             klass = FloatBlock\r\ninternals.py(2686):     return klass(values, ndim=ndim, fastpath=fastpath, placement=placement)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(97):         if ndim is None:\r\ninternals.py(99):         elif values.ndim != ndim:\r\ninternals.py(101):         self.ndim = ndim\r\ninternals.py(103):         self.mgr_locs = placement\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(218):         if not isinstance(new_mgr_locs, BlockPlacement):\r\ninternals.py(221):         self._mgr_locs = new_mgr_locs\r\ninternals.py(104):         self.values = values\r\ninternals.py(106):         if ndim and len(self.mgr_locs) != len(self.values):\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(383):                       for b in blocks]\r\ninternals.py(384):             return self._maybe_downcast(blocks, downcast)\r\n--- modulename: internals, funcname: _maybe_downcast\r\ninternals.py(402):         if downcast is None and self.is_float:\r\ninternals.py(403):             return blocks\r\ninternals.py(3058):             result_blocks = _extend_blocks(applied, result_blocks)\r\n--- modulename: internals, funcname: _extend_blocks\r\ninternals.py(4553):     if blocks is None:\r\ninternals.py(4555):     if isinstance(result, list):\r\ninternals.py(4556):         for r in result:\r\ninternals.py(4557):             if isinstance(r, list):\r\ninternals.py(4560):                 blocks.append(r)\r\ninternals.py(4556):         for r in result:\r\ninternals.py(4565):     return blocks\r\ninternals.py(3042):         for b in self.blocks:\r\ninternals.py(3060):         if len(result_blocks) == 0:\r\ninternals.py(3062):         bm = self.__class__(result_blocks, axes or self.axes,\r\ninternals.py(3063):                             do_integrity_check=do_integrity_check)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(4034):         if isinstance(axis, list):\r\ninternals.py(4035):             if len(axis) != 1:\r\ninternals.py(4038):             axis = axis[0]\r\ninternals.py(4041):         if fastpath:\r\ninternals.py(4053):             self.axes = [_ensure_index(axis)]\r\n--- modulename: base, funcname: _ensure_index\r\nbase.py(3661):     if isinstance(index_like, Index):\r\nbase.py(3662):         if copy:\r\nbase.py(3664):         return index_like\r\ninternals.py(4056):             if isinstance(block, list):\r\ninternals.py(4059):                 if len(block) > 1:\r\ninternals.py(4064):                 if len(block) != 1:\r\ninternals.py(4067):                 block = block[0]\r\ninternals.py(4069):         if not isinstance(block, Block):\r\ninternals.py(4073):         self.blocks = [block]\r\ninternals.py(3064):         bm._consolidate_inplace()\r\n--- modulename: internals, funcname: _consolidate_inplace\r\ninternals.py(4205):         pass\r\ninternals.py(3065):         return bm\r\ngeneric.py(3351):         if inplace:\r\ngeneric.py(3354):             return self._constructor(new_data).__finalize__(self)\r\n--- modulename: series, funcname: _constructor\r\nseries.py(266):         return Series\r\n--- modulename: series, funcname: __init__\r\nseries.py(140):         if fastpath:\r\nseries.py(152):             if index is not None:\r\nseries.py(155):             if data is None:\r\nseries.py(157):             if dtype is not None:\r\nseries.py(160):             if isinstance(data, MultiIndex):\r\nseries.py(163):             elif isinstance(data, Index):\r\nseries.py(170):             elif isinstance(data, np.ndarray):\r\nseries.py(172):             elif isinstance(data, Series):\r\nseries.py(180):             elif isinstance(data, dict):\r\nseries.py(207):             elif isinstance(data, SingleBlockManager):\r\nseries.py(208):                 if index is None:\r\nseries.py(209):                     index = data.index\r\n--- modulename: internals, funcname: index\r\ninternals.py(4141):         return self.axes[0]\r\nseries.py(231):             if index is None:\r\nseries.py(237):             if isinstance(data, SingleBlockManager):\r\nseries.py(238):                 if dtype is not None:\r\nseries.py(240):                 elif copy:\r\nseries.py(248):         generic.NDFrame.__init__(self, data, fastpath=True)\r\n--- modulename: generic, funcname: __init__\r\ngeneric.py(117):         if not fastpath:\r\ngeneric.py(127):         object.__setattr__(self, 'is_copy', None)\r\ngeneric.py(128):         object.__setattr__(self, '_data', data)\r\ngeneric.py(129):         object.__setattr__(self, '_item_cache', {})\r\nseries.py(250):         self.name = name\r\n--- modulename: generic, funcname: __setattr__\r\ngeneric.py(2812):         try:\r\ngeneric.py(2813):             object.__getattribute__(self, name)\r\n--- modulename: series, funcname: name\r\nseries.py(325):         return self._name\r\n--- modulename: generic, funcname: __getattr__\r\ngeneric.py(2795):         if (name in self._internal_names_set or name in self._metadata or\r\ngeneric.py(2797):             return object.__getattribute__(self, name)\r\ngeneric.py(2815):         except AttributeError:\r\ngeneric.py(2816):             pass\r\ngeneric.py(2820):         if name in self._internal_names_set:\r\ngeneric.py(2822):         elif name in self._metadata:\r\ngeneric.py(2823):             object.__setattr__(self, name, value)\r\n--- modulename: series, funcname: name\r\nseries.py(329):         if value is not None and not is_hashable(value):\r\nseries.py(331):         object.__setattr__(self, '_name', value)\r\nseries.py(251):         self._set_axis(0, index, fastpath=True)\r\n--- modulename: series, funcname: _set_axis\r\nseries.py(290):         if not fastpath:\r\nseries.py(293):         is_all_dates = labels.is_all_dates\r\n--- modulename: numeric, funcname: is_all_dates\r\nnumeric.py(136):         return False\r\nseries.py(294):         if is_all_dates:\r\nseries.py(307):         self._set_subtyp(is_all_dates)\r\n--- modulename: series, funcname: _set_subtyp\r\nseries.py(314):         if is_all_dates:\r\nseries.py(317):             object.__setattr__(self, '_subtyp', 'series')\r\nseries.py(309):         object.__setattr__(self, '_index', labels)\r\nseries.py(310):         if not fastpath:\r\n--- modulename: generic, funcname: __finalize__\r\ngeneric.py(2782):         if isinstance(other, NDFrame):\r\ngeneric.py(2783):             for name in self._metadata:\r\ngeneric.py(2784):                 object.__setattr__(self, name, getattr(other, name, None))\r\n--- modulename: series, funcname: name\r\nseries.py(325):         return self._name\r\n--- modulename: series, funcname: name\r\nseries.py(329):         if value is not None and not is_hashable(value):\r\nseries.py(331):         object.__setattr__(self, '_name', value)\r\ngeneric.py(2783):             for name in self._metadata:\r\ngeneric.py(2785):         return self\r\n--- modulename: trace, funcname: _unsettrace\r\ntrace.py(80):         sys.settrace(None)\r\n```\r\n\r\n</details>\r\n\r\nAnd `.interpolate(limit=-1)`:\r\n\r\n<details>\r\n\r\n```\r\n--- modulename: generic, funcname: interpolate\r\ngeneric.py(3708):         if self.ndim > 2:\r\n--- modulename: base, funcname: ndim\r\nbase.py(824):         return 1\r\ngeneric.py(3712):         if axis == 0:\r\ngeneric.py(3713):             ax = self._info_axis_name\r\ngeneric.py(3714):             _maybe_transposed_self = self\r\ngeneric.py(3720):         ax = _maybe_transposed_self._get_axis_number(ax)\r\n--- modulename: generic, funcname: _get_axis_number\r\ngeneric.py(328):         axis = self._AXIS_ALIASES.get(axis, axis)\r\ngeneric.py(329):         if is_integer(axis):\r\ngeneric.py(333):             try:\r\ngeneric.py(334):                 return self._AXIS_NUMBERS[axis]\r\ngeneric.py(3722):         if _maybe_transposed_self.ndim == 2:\r\n--- modulename: base, funcname: ndim\r\nbase.py(824):         return 1\r\ngeneric.py(3725):             alt_ax = ax\r\ngeneric.py(3727):         if (isinstance(_maybe_transposed_self.index, MultiIndex) and\r\ngeneric.py(3732):         if _maybe_transposed_self._data.get_dtype_counts().get(\r\n--- modulename: internals, funcname: get_dtype_counts\r\ninternals.py(4161):         return {self.dtype.name: 1}\r\n--- modulename: internals, funcname: dtype\r\ninternals.py(4150):         return self._block.dtype\r\n--- modulename: internals, funcname: _block\r\ninternals.py(4080):         return self.blocks[0]\r\n--- modulename: internals, funcname: dtype\r\ninternals.py(299):         return self.values.dtype\r\ngeneric.py(3733):                 'object') == len(_maybe_transposed_self.T):\r\n--- modulename: base, funcname: transpose\r\nbase.py(808):         nv.validate_transpose(args, kwargs)\r\n--- modulename: function, funcname: __call__\r\nfunction.py(39):         fname = self.fname if fname is None else fname\r\nfunction.py(41):                                max_fname_arg_count is None\r\nfunction.py(43):         method = self.method if method is None else method\r\nfunction.py(45):         if method == 'args':\r\nfunction.py(47):         elif method == 'kwargs':\r\nfunction.py(49):         elif method == 'both':\r\nfunction.py(50):             validate_args_and_kwargs(fname, args, kwargs,\r\nfunction.py(51):                                      max_fname_arg_count,\r\nfunction.py(52):                                      self.defaults)\r\n--- modulename: validators, funcname: validate_args_and_kwargs\r\nvalidators.py(204):     _check_arg_length(fname, args + tuple(kwargs.values()),\r\nvalidators.py(205):                       max_fname_arg_count, compat_args)\r\n--- modulename: validators, funcname: _check_arg_length\r\nvalidators.py(16):     if max_fname_arg_count < 0:\r\nvalidators.py(19):     if len(args) > len(compat_args):\r\nvalidators.py(209):     args_dict = dict(zip(compat_args, args))\r\nvalidators.py(211):     for key in args_dict:\r\nvalidators.py(216):     kwargs.update(args_dict)\r\nvalidators.py(217):     validate_kwargs(fname, kwargs, compat_args)\r\n--- modulename: validators, funcname: validate_kwargs\r\nvalidators.py(154):     kwds = kwargs.copy()\r\nvalidators.py(155):     _check_for_invalid_keys(fname, kwargs, compat_args)\r\n--- modulename: validators, funcname: _check_for_invalid_keys\r\nvalidators.py(120):     diff = set(kwargs) - set(compat_args)\r\nvalidators.py(122):     if diff:\r\nvalidators.py(156):     _check_for_default_values(fname, kwds, compat_args)\r\n--- modulename: validators, funcname: _check_for_default_values\r\nvalidators.py(40):     for key in arg_val_dict:\r\nbase.py(809):         return self\r\n--- modulename: series, funcname: __len__\r\nseries.py(468):         return len(self._data)\r\n--- modulename: internals, funcname: __len__\r\ninternals.py(2953):         return len(self.items)\r\n--- modulename: internals, funcname: _get_items\r\ninternals.py(2864):         return self.axes[0]\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\ngeneric.py(3737):         if method == 'linear':\r\ngeneric.py(3739):             index = np.arange(len(_maybe_transposed_self._get_axis(alt_ax)))\r\n--- modulename: generic, funcname: _get_axis\r\ngeneric.py(354):         name = self._get_axis_name(axis)\r\n--- modulename: generic, funcname: _get_axis_name\r\ngeneric.py(341):         axis = self._AXIS_ALIASES.get(axis, axis)\r\ngeneric.py(342):         if isinstance(axis, string_types):\r\ngeneric.py(346):             try:\r\ngeneric.py(347):                 return self._AXIS_NAMES[axis]\r\ngeneric.py(355):         return getattr(self, name)\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\ngeneric.py(3743):         if pd.isnull(index).any():\r\n--- modulename: missing, funcname: isnull\r\nmissing.py(44):     return _isnull(obj)\r\n--- modulename: missing, funcname: _isnull_new\r\nmissing.py(48):     if is_scalar(obj):\r\nmissing.py(51):     elif isinstance(obj, ABCMultiIndex):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(53):     elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(54):         return _isnull_ndarraylike(obj)\r\n--- modulename: missing, funcname: _isnull_ndarraylike\r\nmissing.py(121):     values = getattr(obj, 'values', obj)\r\nmissing.py(122):     dtype = values.dtype\r\nmissing.py(124):     if is_string_dtype(dtype):\r\n--- modulename: common, funcname: is_string_dtype\r\ncommon.py(105):     dtype = _get_dtype(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype\r\ncommon.py(345):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(346):         return arr_or_dtype\r\ncommon.py(106):     return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\r\nmissing.py(142):     elif needs_i8_conversion(obj):\r\n--- modulename: common, funcname: needs_i8_conversion\r\ncommon.py(276):     return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime_or_timedelta_dtype\r\ncommon.py(200):     tipo = _get_dtype_type(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype_type\r\ncommon.py(369):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(371):     elif isinstance(arr_or_dtype, type):\r\ncommon.py(373):     elif isinstance(arr_or_dtype, CategoricalDtype):\r\ncommon.py(375):     elif isinstance(arr_or_dtype, DatetimeTZDtype):\r\ncommon.py(377):     elif isinstance(arr_or_dtype, PeriodDtype):\r\ncommon.py(379):     elif isinstance(arr_or_dtype, string_types):\r\ncommon.py(387):     try:\r\ncommon.py(388):         return arr_or_dtype.dtype.type\r\ncommon.py(201):     return issubclass(tipo, (np.datetime64, np.timedelta64))\r\ncommon.py(277):             is_datetime64tz_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime64tz_dtype\r\ncommon.py(88):     return DatetimeTZDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\ncommon.py(278):             is_period_dtype(arr_or_dtype))\r\n--- modulename: common, funcname: is_period_dtype\r\ncommon.py(97):     return PeriodDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(354):         if isinstance(dtype, compat.string_types):\r\ndtypes.py(367):         return super(PeriodDtype, cls).is_dtype(dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\nmissing.py(146):         result = np.isnan(values)\r\nmissing.py(149):     if isinstance(obj, ABCSeries):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(153):     return result\r\n--- modulename: _methods, funcname: _any\r\n_methods.py(38):     return umr_any(a, axis, dtype, out, keepdims)\r\ngeneric.py(3747):         data = _maybe_transposed_self._data\r\ngeneric.py(3748):         new_data = data.interpolate(method=method, axis=ax, index=index,\r\ngeneric.py(3749):                                     values=_maybe_transposed_self, limit=limit,\r\ngeneric.py(3750):                                     limit_direction=limit_direction,\r\ngeneric.py(3751):                                     inplace=inplace, downcast=downcast,\r\ngeneric.py(3752):                                     **kwargs)\r\n--- modulename: internals, funcname: interpolate\r\ninternals.py(3178):         return self.apply('interpolate', **kwargs)\r\n--- modulename: internals, funcname: apply\r\ninternals.py(3001):         result_blocks = []\r\ninternals.py(3004):         if filter is not None:\r\ninternals.py(3012):         if consolidate:\r\ninternals.py(3013):             self._consolidate_inplace()\r\n--- modulename: internals, funcname: _consolidate_inplace\r\ninternals.py(4205):         pass\r\ninternals.py(3015):         if f == 'where':\r\ninternals.py(3021):         elif f == 'putmask':\r\ninternals.py(3027):         elif f == 'eval':\r\ninternals.py(3030):         elif f == 'fillna':\r\ninternals.py(3036):             align_keys = []\r\ninternals.py(3038):         aligned_args = dict((k, kwargs[k])\r\ninternals.py(3039):                             for k in align_keys\r\n--- modulename: internals, funcname: <genexpr>\r\ninternals.py(3038):         aligned_args = dict((k, kwargs[k])\r\ninternals.py(3042):         for b in self.blocks:\r\ninternals.py(3043):             if filter is not None:\r\ninternals.py(3048):             if aligned_args:\r\ninternals.py(3056):             kwargs['mgr'] = self\r\ninternals.py(3057):             applied = getattr(b, f)(**kwargs)\r\n--- modulename: internals, funcname: interpolate\r\ninternals.py(894):         def check_int_bool(self, inplace):\r\ninternals.py(904):         try:\r\ninternals.py(905):             m = missing.clean_fill_method(method)\r\n--- modulename: missing, funcname: clean_fill_method\r\nmissing.py(68):     if method in [None, 'asfreq']:\r\nmissing.py(71):     if isinstance(method, string_types):\r\nmissing.py(72):         method = method.lower()\r\nmissing.py(73):         if method == 'ffill':\r\nmissing.py(75):         elif method == 'bfill':\r\nmissing.py(78):     valid_methods = ['pad', 'backfill']\r\nmissing.py(79):     expecting = 'pad (ffill) or backfill (bfill)'\r\nmissing.py(80):     if allow_nearest:\r\nmissing.py(83):     if method not in valid_methods:\r\nmissing.py(84):         msg = ('Invalid fill method. Expecting %s. Got %s' %\r\nmissing.py(85):                (expecting, method))\r\nmissing.py(86):         raise ValueError(msg)\r\ninternals.py(906):         except:\r\ninternals.py(907):             m = None\r\ninternals.py(909):         if m is not None:\r\ninternals.py(919):         try:\r\ninternals.py(920):             m = missing.clean_interp_method(method, **kwargs)\r\n--- modulename: missing, funcname: clean_interp_method\r\nmissing.py(91):     order = kwargs.get('order')\r\nmissing.py(92):     valid = ['linear', 'time', 'index', 'values', 'nearest', 'zero', 'slinear',\r\nmissing.py(93):              'quadratic', 'cubic', 'barycentric', 'polynomial', 'krogh',\r\nmissing.py(94):              'piecewise_polynomial', 'pchip', 'akima', 'spline',\r\nmissing.py(95):              'from_derivatives']\r\nmissing.py(96):     if method in ('spline', 'polynomial') and order is None:\r\nmissing.py(99):     if method not in valid:\r\nmissing.py(103):     return method\r\ninternals.py(924):         if m is not None:\r\ninternals.py(925):             r = check_int_bool(self, inplace)\r\n--- modulename: internals, funcname: check_int_bool\r\ninternals.py(897):             if (self.is_bool or self.is_integer) and not self.is_timedelta:\r\ninternals.py(926):             if r is not None:\r\ninternals.py(928):             return self._interpolate(method=m, index=index, values=values,\r\ninternals.py(929):                                      axis=axis, limit=limit,\r\ninternals.py(930):                                      limit_direction=limit_direction,\r\ninternals.py(931):                                      fill_value=fill_value, inplace=inplace,\r\ninternals.py(932):                                      downcast=downcast, mgr=mgr, **kwargs)\r\n--- modulename: internals, funcname: _interpolate\r\ninternals.py(967):         data = self.values if inplace else self.values.copy()\r\ninternals.py(970):         if not self.is_float:\r\ninternals.py(975):         if fill_value is None:\r\ninternals.py(976):             fill_value = self.fill_value\r\n--- modulename: internals, funcname: fill_value\r\ninternals.py(177):         return np.nan\r\ninternals.py(978):         if method in ('krogh', 'piecewise_polynomial', 'pchip'):\r\ninternals.py(984):         def func(x):\r\ninternals.py(995):         interp_values = np.apply_along_axis(func, axis, data)\r\n--- modulename: shape_base, funcname: apply_along_axis\r\nshape_base.py(77):     arr = asarray(arr)\r\n--- modulename: numeric, funcname: asarray\r\nnumeric.py(482):     return array(a, dtype, copy=False, order=order)\r\nshape_base.py(78):     nd = arr.ndim\r\nshape_base.py(79):     if axis < 0:\r\nshape_base.py(81):     if (axis >= nd):\r\nshape_base.py(84):     ind = [0]*(nd-1)\r\nshape_base.py(85):     i = zeros(nd, 'O')\r\nshape_base.py(86):     indlist = list(range(nd))\r\nshape_base.py(87):     indlist.remove(axis)\r\nshape_base.py(88):     i[axis] = slice(None, None)\r\nshape_base.py(89):     outshape = asarray(arr.shape).take(indlist)\r\n--- modulename: numeric, funcname: asarray\r\nnumeric.py(482):     return array(a, dtype, copy=False, order=order)\r\nshape_base.py(90):     i.put(indlist, ind)\r\nshape_base.py(91):     res = func1d(arr[tuple(i.tolist())], *args, **kwargs)\r\n--- modulename: internals, funcname: func\r\ninternals.py(989):             return missing.interpolate_1d(index, x, method=method, limit=limit,\r\ninternals.py(990):                                           limit_direction=limit_direction,\r\ninternals.py(991):                                           fill_value=fill_value,\r\ninternals.py(992):                                           bounds_error=False, **kwargs)\r\n--- modulename: missing, funcname: interpolate_1d\r\nmissing.py(118):     invalid = isnull(yvalues)\r\n--- modulename: missing, funcname: isnull\r\nmissing.py(44):     return _isnull(obj)\r\n--- modulename: missing, funcname: _isnull_new\r\nmissing.py(48):     if is_scalar(obj):\r\nmissing.py(51):     elif isinstance(obj, ABCMultiIndex):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(53):     elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(54):         return _isnull_ndarraylike(obj)\r\n--- modulename: missing, funcname: _isnull_ndarraylike\r\nmissing.py(121):     values = getattr(obj, 'values', obj)\r\nmissing.py(122):     dtype = values.dtype\r\nmissing.py(124):     if is_string_dtype(dtype):\r\n--- modulename: common, funcname: is_string_dtype\r\ncommon.py(105):     dtype = _get_dtype(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype\r\ncommon.py(345):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(346):         return arr_or_dtype\r\ncommon.py(106):     return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\r\nmissing.py(142):     elif needs_i8_conversion(obj):\r\n--- modulename: common, funcname: needs_i8_conversion\r\ncommon.py(276):     return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime_or_timedelta_dtype\r\ncommon.py(200):     tipo = _get_dtype_type(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype_type\r\ncommon.py(369):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(371):     elif isinstance(arr_or_dtype, type):\r\ncommon.py(373):     elif isinstance(arr_or_dtype, CategoricalDtype):\r\ncommon.py(375):     elif isinstance(arr_or_dtype, DatetimeTZDtype):\r\ncommon.py(377):     elif isinstance(arr_or_dtype, PeriodDtype):\r\ncommon.py(379):     elif isinstance(arr_or_dtype, string_types):\r\ncommon.py(387):     try:\r\ncommon.py(388):         return arr_or_dtype.dtype.type\r\ncommon.py(201):     return issubclass(tipo, (np.datetime64, np.timedelta64))\r\ncommon.py(277):             is_datetime64tz_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime64tz_dtype\r\ncommon.py(88):     return DatetimeTZDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\ncommon.py(278):             is_period_dtype(arr_or_dtype))\r\n--- modulename: common, funcname: is_period_dtype\r\ncommon.py(97):     return PeriodDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(354):         if isinstance(dtype, compat.string_types):\r\ndtypes.py(367):         return super(PeriodDtype, cls).is_dtype(dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\nmissing.py(146):         result = np.isnan(values)\r\nmissing.py(149):     if isinstance(obj, ABCSeries):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(153):     return result\r\nmissing.py(119):     valid = ~invalid\r\nmissing.py(121):     if not valid.any():\r\n--- modulename: _methods, funcname: _any\r\n_methods.py(38):     return umr_any(a, axis, dtype, out, keepdims)\r\nmissing.py(128):     if valid.all():\r\n--- modulename: _methods, funcname: _all\r\n_methods.py(41):     return umr_all(a, axis, dtype, out, keepdims)\r\nmissing.py(131):     if method == 'time':\r\nmissing.py(139):     def _interp_limit(invalid, fw_limit, bw_limit):\r\nmissing.py(145):     valid_limit_directions = ['forward', 'backward', 'both']\r\nmissing.py(146):     limit_direction = limit_direction.lower()\r\nmissing.py(147):     if limit_direction not in valid_limit_directions:\r\nmissing.py(151):     from pandas import Series\r\nmissing.py(152):     ys = Series(yvalues)\r\n--- modulename: series, funcname: __init__\r\nseries.py(140):         if fastpath:\r\nseries.py(152):             if index is not None:\r\nseries.py(155):             if data is None:\r\nseries.py(157):             if dtype is not None:\r\nseries.py(160):             if isinstance(data, MultiIndex):\r\nseries.py(163):             elif isinstance(data, Index):\r\nseries.py(170):             elif isinstance(data, np.ndarray):\r\nseries.py(171):                 pass\r\nseries.py(231):             if index is None:\r\nseries.py(232):                 if not is_list_like(data):\r\n--- modulename: inference, funcname: is_list_like\r\ninference.py(56):     return (hasattr(arg, '__iter__') and\r\ninference.py(57):             not isinstance(arg, string_and_binary_types))\r\nseries.py(234):                 index = _default_index(len(data))\r\n--- modulename: common, funcname: _default_index\r\ncommon.py(228):     from pandas.core.index import RangeIndex\r\ncommon.py(229):     return RangeIndex(0, n, name=None)\r\n--- modulename: range, funcname: __new__\r\nrange.py(47):         if fastpath:\r\nrange.py(50):         cls._validate_dtype(dtype)\r\n--- modulename: range, funcname: _validate_dtype\r\nrange.py(154):         if not (dtype is None or is_int64_dtype(dtype)):\r\nrange.py(53):         if isinstance(start, RangeIndex):\r\nrange.py(60):         def _ensure_int(value, field):\r\nrange.py(75):         if start is None and stop is None and step is None:\r\nrange.py(78):         elif start is None:\r\nrange.py(81):             start = _ensure_int(start, 'start')\r\n--- modulename: range, funcname: _ensure_int\r\nrange.py(61):             msg = (\"RangeIndex(...) must be called with integers,\"\r\nrange.py(63):             if not is_scalar(value):\r\nrange.py(66):             try:\r\nrange.py(67):                 new_value = int(value)\r\nrange.py(68):                 assert(new_value == value)\r\nrange.py(73):             return new_value\r\nrange.py(82):         if stop is None:\r\nrange.py(86):             stop = _ensure_int(stop, 'stop')\r\n--- modulename: range, funcname: _ensure_int\r\nrange.py(61):             msg = (\"RangeIndex(...) must be called with integers,\"\r\nrange.py(63):             if not is_scalar(value):\r\nrange.py(66):             try:\r\nrange.py(67):                 new_value = int(value)\r\nrange.py(68):                 assert(new_value == value)\r\nrange.py(73):             return new_value\r\nrange.py(87):         if step is None:\r\nrange.py(88):             step = 1\r\nrange.py(94):         return cls._simple_new(start, stop, step, name)\r\n--- modulename: range, funcname: _simple_new\r\nrange.py(127):         result = object.__new__(cls)\r\nrange.py(130):         if start is None and stop is None:\r\nrange.py(134):         if start is None or not is_integer(start):\r\nrange.py(141):         result._start = start\r\nrange.py(142):         result._stop = stop or 0\r\nrange.py(143):         result._step = step or 1\r\nrange.py(144):         result.name = name\r\nrange.py(145):         for k, v in compat.iteritems(kwargs):\r\n--- modulename: __init__, funcname: iteritems\r\n__init__.py(165):         return obj.iteritems(**kw)\r\nrange.py(148):         result._reset_identity()\r\n--- modulename: base, funcname: _reset_identity\r\nbase.py(487):         self._id = _Identity()\r\nbase.py(488):         return self\r\nrange.py(149):         return result\r\nseries.py(237):             if isinstance(data, SingleBlockManager):\r\nseries.py(243):                 data = _sanitize_array(data, index, dtype, copy,\r\nseries.py(244):                                        raise_cast_failure=True)\r\n--- modulename: series, funcname: _sanitize_array\r\nseries.py(2835):     if dtype is not None:\r\nseries.py(2838):     if isinstance(data, ma.MaskedArray):\r\nseries.py(2846):     def _try_cast(arr, take_fast_path):\r\nseries.py(2867):     if isinstance(data, (np.ndarray, Index, Series)):\r\nseries.py(2869):         if dtype is not None:\r\nseries.py(2880):         elif isinstance(data, Index):\r\nseries.py(2887):             subarr = _try_cast(data, True)\r\n--- modulename: series, funcname: _try_cast\r\nseries.py(2849):         if take_fast_path:\r\nseries.py(2850):             if _possibly_castable(arr) and not copy and dtype is None:\r\n--- modulename: cast, funcname: _possibly_castable\r\ncast.py(668):     kind = arr.dtype.kind\r\ncast.py(669):     if kind == 'M' or kind == 'm':\r\ncast.py(672):     return arr.dtype.name not in _POSSIBLY_CAST_DTYPES\r\nseries.py(2851):                 return arr\r\nseries.py(2889):         if copy:\r\nseries.py(2917):     def create_from_value(value, index, dtype):\r\nseries.py(2933):     if getattr(subarr, 'ndim', 0) == 0:\r\nseries.py(2952):     elif subarr.ndim == 1:\r\nseries.py(2953):         if index is not None:\r\nseries.py(2956):             if len(subarr) != len(index) and len(subarr) == 1:\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\nseries.py(2968):     if issubclass(subarr.dtype.type, compat.string_types):\r\nseries.py(2971):     return subarr\r\nseries.py(246):                 data = SingleBlockManager(data, index, fastpath=True)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(4034):         if isinstance(axis, list):\r\ninternals.py(4041):         if fastpath:\r\ninternals.py(4042):             self.axes = [axis]\r\ninternals.py(4043):             if isinstance(block, list):\r\ninternals.py(4069):         if not isinstance(block, Block):\r\ninternals.py(4070):             block = make_block(block, placement=slice(0, len(axis)), ndim=1,\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\ninternals.py(4071):                                fastpath=True)\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(2652):     if klass is None:\r\ninternals.py(2653):         dtype = dtype or values.dtype\r\ninternals.py(2654):         vtype = dtype.type\r\ninternals.py(2656):         if isinstance(values, SparseArray):\r\ninternals.py(2658):         elif issubclass(vtype, np.floating):\r\ninternals.py(2659):             klass = FloatBlock\r\ninternals.py(2686):     return klass(values, ndim=ndim, fastpath=fastpath, placement=placement)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(97):         if ndim is None:\r\ninternals.py(99):         elif values.ndim != ndim:\r\ninternals.py(101):         self.ndim = ndim\r\ninternals.py(103):         self.mgr_locs = placement\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(218):         if not isinstance(new_mgr_locs, BlockPlacement):\r\ninternals.py(219):             new_mgr_locs = BlockPlacement(new_mgr_locs)\r\ninternals.py(221):         self._mgr_locs = new_mgr_locs\r\ninternals.py(104):         self.values = values\r\ninternals.py(106):         if ndim and len(self.mgr_locs) != len(self.values):\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(4073):         self.blocks = [block]\r\nseries.py(248):         generic.NDFrame.__init__(self, data, fastpath=True)\r\n--- modulename: generic, funcname: __init__\r\ngeneric.py(117):         if not fastpath:\r\ngeneric.py(127):         object.__setattr__(self, 'is_copy', None)\r\ngeneric.py(128):         object.__setattr__(self, '_data', data)\r\ngeneric.py(129):         object.__setattr__(self, '_item_cache', {})\r\nseries.py(250):         self.name = name\r\n--- modulename: generic, funcname: __setattr__\r\ngeneric.py(2812):         try:\r\ngeneric.py(2813):             object.__getattribute__(self, name)\r\n--- modulename: series, funcname: name\r\nseries.py(325):         return self._name\r\n--- modulename: generic, funcname: __getattr__\r\ngeneric.py(2795):         if (name in self._internal_names_set or name in self._metadata or\r\ngeneric.py(2797):             return object.__getattribute__(self, name)\r\ngeneric.py(2815):         except AttributeError:\r\ngeneric.py(2816):             pass\r\ngeneric.py(2820):         if name in self._internal_names_set:\r\ngeneric.py(2822):         elif name in self._metadata:\r\ngeneric.py(2823):             object.__setattr__(self, name, value)\r\n--- modulename: series, funcname: name\r\nseries.py(329):         if value is not None and not is_hashable(value):\r\nseries.py(331):         object.__setattr__(self, '_name', value)\r\nseries.py(251):         self._set_axis(0, index, fastpath=True)\r\n--- modulename: series, funcname: _set_axis\r\nseries.py(290):         if not fastpath:\r\nseries.py(293):         is_all_dates = labels.is_all_dates\r\n--- modulename: numeric, funcname: is_all_dates\r\nnumeric.py(136):         return False\r\nseries.py(294):         if is_all_dates:\r\nseries.py(307):         self._set_subtyp(is_all_dates)\r\n--- modulename: series, funcname: _set_subtyp\r\nseries.py(314):         if is_all_dates:\r\nseries.py(317):             object.__setattr__(self, '_subtyp', 'series')\r\nseries.py(309):         object.__setattr__(self, '_index', labels)\r\nseries.py(310):         if not fastpath:\r\nmissing.py(153):     start_nans = set(range(ys.first_valid_index()))\r\n--- modulename: series, funcname: first_valid_index\r\nseries.py(2676):         if len(self) == 0:\r\n--- modulename: series, funcname: __len__\r\nseries.py(468):         return len(self._data)\r\n--- modulename: internals, funcname: __len__\r\ninternals.py(2953):         return len(self.items)\r\n--- modulename: internals, funcname: _get_items\r\ninternals.py(2864):         return self.axes[0]\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\nseries.py(2679):         mask = isnull(self._values)\r\n--- modulename: series, funcname: _values\r\nseries.py(390):         return self._data.internal_values()\r\n--- modulename: internals, funcname: internal_values\r\ninternals.py(4176):         return self._block.internal_values()\r\n--- modulename: internals, funcname: _block\r\ninternals.py(4080):         return self.blocks[0]\r\n--- modulename: internals, funcname: internal_values\r\ninternals.py(152):         return self.values\r\n--- modulename: missing, funcname: isnull\r\nmissing.py(44):     return _isnull(obj)\r\n--- modulename: missing, funcname: _isnull_new\r\nmissing.py(48):     if is_scalar(obj):\r\nmissing.py(51):     elif isinstance(obj, ABCMultiIndex):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(53):     elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(54):         return _isnull_ndarraylike(obj)\r\n--- modulename: missing, funcname: _isnull_ndarraylike\r\nmissing.py(121):     values = getattr(obj, 'values', obj)\r\nmissing.py(122):     dtype = values.dtype\r\nmissing.py(124):     if is_string_dtype(dtype):\r\n--- modulename: common, funcname: is_string_dtype\r\ncommon.py(105):     dtype = _get_dtype(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype\r\ncommon.py(345):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(346):         return arr_or_dtype\r\ncommon.py(106):     return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\r\nmissing.py(142):     elif needs_i8_conversion(obj):\r\n--- modulename: common, funcname: needs_i8_conversion\r\ncommon.py(276):     return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime_or_timedelta_dtype\r\ncommon.py(200):     tipo = _get_dtype_type(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype_type\r\ncommon.py(369):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(371):     elif isinstance(arr_or_dtype, type):\r\ncommon.py(373):     elif isinstance(arr_or_dtype, CategoricalDtype):\r\ncommon.py(375):     elif isinstance(arr_or_dtype, DatetimeTZDtype):\r\ncommon.py(377):     elif isinstance(arr_or_dtype, PeriodDtype):\r\ncommon.py(379):     elif isinstance(arr_or_dtype, string_types):\r\ncommon.py(387):     try:\r\ncommon.py(388):         return arr_or_dtype.dtype.type\r\ncommon.py(201):     return issubclass(tipo, (np.datetime64, np.timedelta64))\r\ncommon.py(277):             is_datetime64tz_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime64tz_dtype\r\ncommon.py(88):     return DatetimeTZDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\ncommon.py(278):             is_period_dtype(arr_or_dtype))\r\n--- modulename: common, funcname: is_period_dtype\r\ncommon.py(97):     return PeriodDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(354):         if isinstance(dtype, compat.string_types):\r\ndtypes.py(367):         return super(PeriodDtype, cls).is_dtype(dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\nmissing.py(146):         result = np.isnan(values)\r\nmissing.py(149):     if isinstance(obj, ABCSeries):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(153):     return result\r\nseries.py(2680):         i = mask.argmin()\r\nseries.py(2681):         if mask[i]:\r\nseries.py(2684):             return self.index[i]\r\n--- modulename: range, funcname: __getitem__\r\nrange.py(472):         super_getitem = super(RangeIndex, self).__getitem__\r\nrange.py(474):         if is_scalar(key):\r\nrange.py(475):             n = int(key)\r\nrange.py(476):             if n != key:\r\nrange.py(478):             if n < 0:\r\nrange.py(480):             if n < 0 or n > len(self) - 1:\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\nrange.py(484):             return self._start + n * self._step\r\nmissing.py(154):     end_nans = set(range(1 + ys.last_valid_index(), len(valid)))\r\n--- modulename: series, funcname: last_valid_index\r\nseries.py(2690):         if len(self) == 0:\r\n--- modulename: series, funcname: __len__\r\nseries.py(468):         return len(self._data)\r\n--- modulename: internals, funcname: __len__\r\ninternals.py(2953):         return len(self.items)\r\n--- modulename: internals, funcname: _get_items\r\ninternals.py(2864):         return self.axes[0]\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\nseries.py(2693):         mask = isnull(self._values[::-1])\r\n--- modulename: series, funcname: _values\r\nseries.py(390):         return self._data.internal_values()\r\n--- modulename: internals, funcname: internal_values\r\ninternals.py(4176):         return self._block.internal_values()\r\n--- modulename: internals, funcname: _block\r\ninternals.py(4080):         return self.blocks[0]\r\n--- modulename: internals, funcname: internal_values\r\ninternals.py(152):         return self.values\r\n--- modulename: missing, funcname: isnull\r\nmissing.py(44):     return _isnull(obj)\r\n--- modulename: missing, funcname: _isnull_new\r\nmissing.py(48):     if is_scalar(obj):\r\nmissing.py(51):     elif isinstance(obj, ABCMultiIndex):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(53):     elif isinstance(obj, (ABCSeries, np.ndarray, ABCIndexClass)):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(54):         return _isnull_ndarraylike(obj)\r\n--- modulename: missing, funcname: _isnull_ndarraylike\r\nmissing.py(121):     values = getattr(obj, 'values', obj)\r\nmissing.py(122):     dtype = values.dtype\r\nmissing.py(124):     if is_string_dtype(dtype):\r\n--- modulename: common, funcname: is_string_dtype\r\ncommon.py(105):     dtype = _get_dtype(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype\r\ncommon.py(345):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(346):         return arr_or_dtype\r\ncommon.py(106):     return dtype.kind in ('O', 'S', 'U') and not is_period_dtype(dtype)\r\nmissing.py(142):     elif needs_i8_conversion(obj):\r\n--- modulename: common, funcname: needs_i8_conversion\r\ncommon.py(276):     return (is_datetime_or_timedelta_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime_or_timedelta_dtype\r\ncommon.py(200):     tipo = _get_dtype_type(arr_or_dtype)\r\n--- modulename: common, funcname: _get_dtype_type\r\ncommon.py(369):     if isinstance(arr_or_dtype, np.dtype):\r\ncommon.py(371):     elif isinstance(arr_or_dtype, type):\r\ncommon.py(373):     elif isinstance(arr_or_dtype, CategoricalDtype):\r\ncommon.py(375):     elif isinstance(arr_or_dtype, DatetimeTZDtype):\r\ncommon.py(377):     elif isinstance(arr_or_dtype, PeriodDtype):\r\ncommon.py(379):     elif isinstance(arr_or_dtype, string_types):\r\ncommon.py(387):     try:\r\ncommon.py(388):         return arr_or_dtype.dtype.type\r\ncommon.py(201):     return issubclass(tipo, (np.datetime64, np.timedelta64))\r\ncommon.py(277):             is_datetime64tz_dtype(arr_or_dtype) or\r\n--- modulename: common, funcname: is_datetime64tz_dtype\r\ncommon.py(88):     return DatetimeTZDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\ncommon.py(278):             is_period_dtype(arr_or_dtype))\r\n--- modulename: common, funcname: is_period_dtype\r\ncommon.py(97):     return PeriodDtype.is_dtype(arr_or_dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(354):         if isinstance(dtype, compat.string_types):\r\ndtypes.py(367):         return super(PeriodDtype, cls).is_dtype(dtype)\r\n--- modulename: dtypes, funcname: is_dtype\r\ndtypes.py(79):         if hasattr(dtype, 'dtype'):\r\ndtypes.py(80):             dtype = dtype.dtype\r\ndtypes.py(81):         if isinstance(dtype, cls):\r\ndtypes.py(83):         elif isinstance(dtype, np.dtype):\r\ndtypes.py(84):             return False\r\nmissing.py(146):         result = np.isnan(values)\r\nmissing.py(149):     if isinstance(obj, ABCSeries):\r\n--- modulename: generic, funcname: _check\r\ngeneric.py(9):         return getattr(inst, attr, '_typ') in comp\r\nmissing.py(153):     return result\r\nseries.py(2694):         i = mask.argmin()\r\nseries.py(2695):         if mask[i]:\r\nseries.py(2698):             return self.index[len(self) - i - 1]\r\n--- modulename: series, funcname: __len__\r\nseries.py(468):         return len(self._data)\r\n--- modulename: internals, funcname: __len__\r\ninternals.py(2953):         return len(self.items)\r\n--- modulename: internals, funcname: _get_items\r\ninternals.py(2864):         return self.axes[0]\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\n--- modulename: range, funcname: __getitem__\r\nrange.py(472):         super_getitem = super(RangeIndex, self).__getitem__\r\nrange.py(474):         if is_scalar(key):\r\nrange.py(475):             n = int(key)\r\nrange.py(476):             if n != key:\r\nrange.py(478):             if n < 0:\r\nrange.py(480):             if n < 0 or n > len(self) - 1:\r\n--- modulename: range, funcname: __len__\r\nrange.py(462):         return max(0, -(-(self._stop - self._start) // self._step))\r\nrange.py(484):             return self._start + n * self._step\r\nmissing.py(170):     violate_limit = sorted(start_nans)\r\nmissing.py(172):     if limit:\r\nmissing.py(173):         if limit_direction == 'forward':\r\nmissing.py(174):             violate_limit = sorted(start_nans | set(_interp_limit(invalid,\r\nmissing.py(175):                                                                   limit, 0)))\r\n--- modulename: missing, funcname: _interp_limit\r\nmissing.py(141):         for x in np.where(invalid)[0]:\r\nmissing.py(142):             if invalid[max(0, x - fw_limit):x + bw_limit + 1].all():\r\n--- modulename: _methods, funcname: _all\r\n_methods.py(41):     return umr_all(a, axis, dtype, out, keepdims)\r\nmissing.py(143):                 yield x\r\n--- modulename: missing, funcname: _interp_limit\r\nmissing.py(141):         for x in np.where(invalid)[0]:\r\nmissing.py(176):         if limit_direction == 'backward':\r\nmissing.py(179):         if limit_direction == 'both':\r\nmissing.py(182):     xvalues = getattr(xvalues, 'values', xvalues)\r\nmissing.py(183):     yvalues = getattr(yvalues, 'values', yvalues)\r\nmissing.py(184):     result = yvalues.copy()\r\nmissing.py(186):     if method in ['linear', 'time', 'index', 'values']:\r\nmissing.py(187):         if method in ('values', 'index'):\r\nmissing.py(195):             inds = xvalues\r\nmissing.py(196):         result[invalid] = np.interp(inds[invalid], inds[valid], yvalues[valid])\r\n--- modulename: function_base, funcname: interp\r\nfunction_base.py(1668):     if period is None:\r\nfunction_base.py(1669):         if isinstance(x, (float, int, number)):\r\nfunction_base.py(1671):         elif isinstance(x, np.ndarray) and x.ndim == 0:\r\nfunction_base.py(1674):             return compiled_interp(x, xp, fp, left, right)\r\nmissing.py(197):         result[violate_limit] = np.nan\r\nmissing.py(198):         return result\r\nshape_base.py(93):     if isscalar(res):\r\n--- modulename: numeric, funcname: isscalar\r\nnumeric.py(2088):     if isinstance(num, generic):\r\nnumeric.py(2091):         return type(num) in ScalarType\r\nshape_base.py(112):         Ntot = product(outshape)\r\n--- modulename: fromnumeric, funcname: product\r\nfromnumeric.py(1860):     kwargs = {}\r\nfromnumeric.py(1861):     if keepdims is not np._NoValue:\r\nfromnumeric.py(1863):     return um.multiply.reduce(a, axis=axis, dtype=dtype, out=out, **kwargs)\r\nshape_base.py(113):         holdshape = outshape\r\nshape_base.py(114):         outshape = list(arr.shape)\r\nshape_base.py(115):         outshape[axis] = len(res)\r\nshape_base.py(116):         outarr = zeros(outshape, asarray(res).dtype)\r\n--- modulename: numeric, funcname: asarray\r\nnumeric.py(482):     return array(a, dtype, copy=False, order=order)\r\nshape_base.py(117):         outarr[tuple(i.tolist())] = res\r\nshape_base.py(118):         k = 1\r\nshape_base.py(119):         while k < Ntot:\r\nshape_base.py(131):         return outarr\r\ninternals.py(997):         blocks = [self.make_block(interp_values, klass=self.__class__,\r\ninternals.py(998):                                   fastpath=True)]\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(195):         if placement is None:\r\ninternals.py(196):             placement = self.mgr_locs\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(197):         if ndim is None:\r\ninternals.py(198):             ndim = self.ndim\r\ninternals.py(200):         return make_block(values, placement=placement, ndim=ndim, **kwargs)\r\n--- modulename: internals, funcname: make_block\r\ninternals.py(2652):     if klass is None:\r\ninternals.py(2682):     elif klass is DatetimeTZBlock and not is_datetimetz(values):\r\ninternals.py(2686):     return klass(values, ndim=ndim, fastpath=fastpath, placement=placement)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(97):         if ndim is None:\r\ninternals.py(99):         elif values.ndim != ndim:\r\ninternals.py(101):         self.ndim = ndim\r\ninternals.py(103):         self.mgr_locs = placement\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(218):         if not isinstance(new_mgr_locs, BlockPlacement):\r\ninternals.py(221):         self._mgr_locs = new_mgr_locs\r\ninternals.py(104):         self.values = values\r\ninternals.py(106):         if ndim and len(self.mgr_locs) != len(self.values):\r\n--- modulename: internals, funcname: mgr_locs\r\ninternals.py(181):         return self._mgr_locs\r\ninternals.py(999):         return self._maybe_downcast(blocks, downcast)\r\n--- modulename: internals, funcname: _maybe_downcast\r\ninternals.py(402):         if downcast is None and self.is_float:\r\ninternals.py(403):             return blocks\r\ninternals.py(3058):             result_blocks = _extend_blocks(applied, result_blocks)\r\n--- modulename: internals, funcname: _extend_blocks\r\ninternals.py(4553):     if blocks is None:\r\ninternals.py(4555):     if isinstance(result, list):\r\ninternals.py(4556):         for r in result:\r\ninternals.py(4557):             if isinstance(r, list):\r\ninternals.py(4560):                 blocks.append(r)\r\ninternals.py(4556):         for r in result:\r\ninternals.py(4565):     return blocks\r\ninternals.py(3042):         for b in self.blocks:\r\ninternals.py(3060):         if len(result_blocks) == 0:\r\ninternals.py(3062):         bm = self.__class__(result_blocks, axes or self.axes,\r\ninternals.py(3063):                             do_integrity_check=do_integrity_check)\r\n--- modulename: internals, funcname: __init__\r\ninternals.py(4034):         if isinstance(axis, list):\r\ninternals.py(4035):             if len(axis) != 1:\r\ninternals.py(4038):             axis = axis[0]\r\ninternals.py(4041):         if fastpath:\r\ninternals.py(4053):             self.axes = [_ensure_index(axis)]\r\n--- modulename: base, funcname: _ensure_index\r\nbase.py(3661):     if isinstance(index_like, Index):\r\nbase.py(3662):         if copy:\r\nbase.py(3664):         return index_like\r\ninternals.py(4056):             if isinstance(block, list):\r\ninternals.py(4059):                 if len(block) > 1:\r\ninternals.py(4064):                 if len(block) != 1:\r\ninternals.py(4067):                 block = block[0]\r\ninternals.py(4069):         if not isinstance(block, Block):\r\ninternals.py(4073):         self.blocks = [block]\r\ninternals.py(3064):         bm._consolidate_inplace()\r\n--- modulename: internals, funcname: _consolidate_inplace\r\ninternals.py(4205):         pass\r\ninternals.py(3065):         return bm\r\ngeneric.py(3754):         if inplace:\r\ngeneric.py(3759):             res = self._constructor(new_data).__finalize__(self)\r\n--- modulename: series, funcname: _constructor\r\nseries.py(266):         return Series\r\n--- modulename: series, funcname: __init__\r\nseries.py(140):         if fastpath:\r\nseries.py(152):             if index is not None:\r\nseries.py(155):             if data is None:\r\nseries.py(157):             if dtype is not None:\r\nseries.py(160):             if isinstance(data, MultiIndex):\r\nseries.py(163):             elif isinstance(data, Index):\r\nseries.py(170):             elif isinstance(data, np.ndarray):\r\nseries.py(172):             elif isinstance(data, Series):\r\nseries.py(180):             elif isinstance(data, dict):\r\nseries.py(207):             elif isinstance(data, SingleBlockManager):\r\nseries.py(208):                 if index is None:\r\nseries.py(209):                     index = data.index\r\n--- modulename: internals, funcname: index\r\ninternals.py(4141):         return self.axes[0]\r\nseries.py(231):             if index is None:\r\nseries.py(237):             if isinstance(data, SingleBlockManager):\r\nseries.py(238):                 if dtype is not None:\r\nseries.py(240):                 elif copy:\r\nseries.py(248):         generic.NDFrame.__init__(self, data, fastpath=True)\r\n--- modulename: generic, funcname: __init__\r\ngeneric.py(117):         if not fastpath:\r\ngeneric.py(127):         object.__setattr__(self, 'is_copy', None)\r\ngeneric.py(128):         object.__setattr__(self, '_data', data)\r\ngeneric.py(129):         object.__setattr__(self, '_item_cache', {})\r\nseries.py(250):         self.name = name\r\n--- modulename: generic, funcname: __setattr__\r\ngeneric.py(2812):         try:\r\ngeneric.py(2813):             object.__getattribute__(self, name)\r\n--- modulename: series, funcname: name\r\nseries.py(325):         return self._name\r\n--- modulename: generic, funcname: __getattr__\r\ngeneric.py(2795):         if (name in self._internal_names_set or name in self._metadata or\r\ngeneric.py(2797):             return object.__getattribute__(self, name)\r\ngeneric.py(2815):         except AttributeError:\r\ngeneric.py(2816):             pass\r\ngeneric.py(2820):         if name in self._internal_names_set:\r\ngeneric.py(2822):         elif name in self._metadata:\r\ngeneric.py(2823):             object.__setattr__(self, name, value)\r\n--- modulename: series, funcname: name\r\nseries.py(329):         if value is not None and not is_hashable(value):\r\nseries.py(331):         object.__setattr__(self, '_name', value)\r\nseries.py(251):         self._set_axis(0, index, fastpath=True)\r\n--- modulename: series, funcname: _set_axis\r\nseries.py(290):         if not fastpath:\r\nseries.py(293):         is_all_dates = labels.is_all_dates\r\n--- modulename: numeric, funcname: is_all_dates\r\nnumeric.py(136):         return False\r\nseries.py(294):         if is_all_dates:\r\nseries.py(307):         self._set_subtyp(is_all_dates)\r\n--- modulename: series, funcname: _set_subtyp\r\nseries.py(314):         if is_all_dates:\r\nseries.py(317):             object.__setattr__(self, '_subtyp', 'series')\r\nseries.py(309):         object.__setattr__(self, '_index', labels)\r\nseries.py(310):         if not fastpath:\r\n--- modulename: generic, funcname: __finalize__\r\ngeneric.py(2782):         if isinstance(other, NDFrame):\r\ngeneric.py(2783):             for name in self._metadata:\r\ngeneric.py(2784):                 object.__setattr__(self, name, getattr(other, name, None))\r\n--- modulename: series, funcname: name\r\nseries.py(325):         return self._name\r\n--- modulename: series, funcname: name\r\nseries.py(329):         if value is not None and not is_hashable(value):\r\nseries.py(331):         object.__setattr__(self, '_name', value)\r\ngeneric.py(2783):             for name in self._metadata:\r\ngeneric.py(2785):         return self\r\ngeneric.py(3760):             if axis == 1:\r\ngeneric.py(3762):             return res\r\n--- modulename: trace, funcname: _unsettrace\r\ntrace.py(80):         sys.settrace(None)\r\n```\r\n\r\n</details>\r\n\r\nFor `interpolate()`, it looks like `limit` is utilized in the `_interp_limit` function: https://github.com/pandas-dev/pandas/blob/f3c5a427cc632e89cc5d2cb0df5b5e875cb6e23b/pandas/core/missing.py#L142\r\n\r\nFor `fillna()`, it looks like `limit` is utilized in `Block`'s `fillna` function: https://github.com/pandas-dev/pandas/blob/master/pandas/core/internals.py#L376\r\n\r\nSo if I've traced correctly, it doesn't appear that limit is passed through any `pad` function  where `limit < 0` should be caught."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/272642714",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-272642714",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 272642714,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3MjY0MjcxNA==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-14T18:22:30Z",
    "updated_at": "2017-01-14T18:22:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "can you rebase / update"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/272672860",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-272672860",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 272672860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3MjY3Mjg2MA==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-15T04:23:57Z",
    "updated_at": "2017-01-15T04:23:57Z",
    "author_association": "MEMBER",
    "body": "Rebasing. \r\n\r\nAs noted in my previous comment, it doesn't appear that `limit` gets passed through the `limit<0` check here: https://github.com/pandas-dev/pandas/blob/master/pandas/src/algos_common_helper.pxi.in#L85\r\n\r\nFor `interpolate`, `limit` passes through this line: https://github.com/pandas-dev/pandas/blob/f3c5a427cc632e89cc5d2cb0df5b5e875cb6e23b/pandas/core/missing.py#L142\r\n\r\nFor `fillna`, `limit` passes through this line: https://github.com/pandas-dev/pandas/blob/master/pandas/core/internals.py#L378"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/272988365",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-272988365",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 272988365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3Mjk4ODM2NQ==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-01-16T23:57:54Z",
    "updated_at": "2017-01-16T23:57:54Z",
    "author_association": "MEMBER",
    "body": "\r\nSo I discovered negative limits are caught by cython if you specifically specify the fill method to be `pad`:\r\n\r\n```\r\nIn [3]: s.interpolate(method='pad', limit=-1)\r\n\r\nValueError: Limit must be non-negative\r\n\r\nIn [4]: s.fillna(method='pad', limit=-1)\r\n\r\nValueError: Limit must be non-negative\r\n```\r\n\r\nI am guessing this is true if the user specifies the `pad` or `backfill` variants.\r\n\r\nOtherwise, `fillna` with a value specified instead of a fill method doesn't go down the cython routine and negative limit won't be caught. Should `fillna` be adjusted to go through the cython routine if a value is specified instead of a fill method (maybe in a new issue)? This could be done similarly with `interpolate` but there plenty more interpolation methods... \r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/276693612",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-276693612",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 276693612,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3NjY5MzYxMg==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-01T15:50:03Z",
    "updated_at": "2017-02-01T15:50:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "can you update?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/276737490",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-276737490",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 276737490,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3NjczNzQ5MA==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-01T18:22:10Z",
    "updated_at": "2017-02-01T18:22:10Z",
    "author_association": "MEMBER",
    "body": "Sure thing. I will also rebase to master as well.\r\n\r\nCircling back to my last comment, I think the `assert limit > 0` is necessary in the beginning if `method` != pad or backfill since the other methods don't appear to go down the cython path where the `limit` check is made. "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/276738889",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-276738889",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 276738889,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3NjczODg4OQ==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-01T18:27:07Z",
    "updated_at": "2017-02-01T18:27:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "@mroeschke ideally I'd like to have these validation on args occur when they are actually used. So might need to add these checks in ``pandas/core/missing.py`` when its not going down the cython route (and then enable the cython route). OR if its easier, remove checks in cython (well maybe leave them as assert statements and put in a comment of what the guarantees), and do the validation (still in pandas.core.missing). I don't want the validation in Series/DataFrame but in the actual implementation."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/276744913",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-276744913",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 276744913,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3Njc0NDkxMw==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-01T18:49:37Z",
    "updated_at": "2017-02-01T18:49:37Z",
    "author_association": "MEMBER",
    "body": "Ah I see, that makes sense. Okay I'll look into migrating the check to `pandas.core.missing`. Thanks!"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/277875534",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-277875534",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 277875534,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3Nzg3NTUzNA==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-07T01:46:35Z",
    "updated_at": "2017-02-07T01:46:35Z",
    "author_association": "MEMBER",
    "body": "Migrated the `limit > 0` check closer to where `limit` was actually used (`interpolate_1d` in `pandas/core/missing` and `fillna` in `pandas/core/internals`)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/278729301",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-278729301",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 278729301,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODcyOTMwMQ==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-09T18:27:14Z",
    "updated_at": "2017-02-09T18:27:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "you need to edit the ``.in`` files, IOW ``algos_common.pxi.in`` (and not the .pxi as it says). These are not commited to the repo but generated from the ``.in`` ones."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/278733213",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-278733213",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 278733213,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3ODczMzIxMw==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-09T18:40:30Z",
    "updated_at": "2017-02-09T18:40:30Z",
    "author_association": "MEMBER",
    "body": "Ah oops, apologies. I tried editing those error messages directly through github. I'll make those changes later tonight. "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/279476961",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-279476961",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 279476961,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTQ3Njk2MQ==",
    "user": {
      "login": "mroeschke",
      "id": 10647082,
      "node_id": "MDQ6VXNlcjEwNjQ3MDgy",
      "avatar_url": "https://avatars0.githubusercontent.com/u/10647082?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/mroeschke",
      "html_url": "https://github.com/mroeschke",
      "followers_url": "https://api.github.com/users/mroeschke/followers",
      "following_url": "https://api.github.com/users/mroeschke/following{/other_user}",
      "gists_url": "https://api.github.com/users/mroeschke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/mroeschke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/mroeschke/subscriptions",
      "organizations_url": "https://api.github.com/users/mroeschke/orgs",
      "repos_url": "https://api.github.com/users/mroeschke/repos",
      "events_url": "https://api.github.com/users/mroeschke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/mroeschke/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-13T18:22:35Z",
    "updated_at": "2017-02-13T18:22:35Z",
    "author_association": "MEMBER",
    "body": "Included `int` check for `limit` argument and added tests where floats should raise a `ValueError`"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/279708043",
    "html_url": "https://github.com/pandas-dev/pandas/pull/14994#issuecomment-279708043",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14994",
    "id": 279708043,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI3OTcwODA0Mw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-02-14T13:34:26Z",
    "updated_at": "2017-02-14T13:34:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "thanks @mroeschke "
  }
]
