[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/438873147",
    "html_url": "https://github.com/pandas-dev/pandas/issues/23710#issuecomment-438873147",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/23710",
    "id": 438873147,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODg3MzE0Nw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-15T00:45:11Z",
    "updated_at": "2018-11-15T00:45:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "showing that a numpy routine is ‘way faster’ is not a great argument as that is often the case that they don’t handle dtypes fully (datetimes and such ( and certainly don’t handle the pandas dtypes)\r\n\r\nso am not really sure your intent here\r\n\r\ncan u elaborate on an actual use case \r\n\r\nwe care way more about things working consistently across he board, having flexibility in the apis and just working "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/438882911",
    "html_url": "https://github.com/pandas-dev/pandas/issues/23710#issuecomment-438882911",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/23710",
    "id": 438882911,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODg4MjkxMQ==",
    "user": {
      "login": "bluesquall",
      "id": 514022,
      "node_id": "MDQ6VXNlcjUxNDAyMg==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/514022?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluesquall",
      "html_url": "https://github.com/bluesquall",
      "followers_url": "https://api.github.com/users/bluesquall/followers",
      "following_url": "https://api.github.com/users/bluesquall/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluesquall/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluesquall/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluesquall/subscriptions",
      "organizations_url": "https://api.github.com/users/bluesquall/orgs",
      "repos_url": "https://api.github.com/users/bluesquall/repos",
      "events_url": "https://api.github.com/users/bluesquall/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluesquall/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-15T01:32:53Z",
    "updated_at": "2018-11-15T01:33:52Z",
    "author_association": "NONE",
    "body": "My intent is to get the histogram counts, without the plot, sorted by index (like a histogram would be).\r\n\r\nI'd prefer to do this using a method to the Series class, without having to remember to set the sorting, and without having to call a chain of functions. I'd imagine other people could use this in their workflows, but perhaps I'm the only one using histograms in intermediate steps of my processing.\r\n\r\nI'm open to implementing this using `pd.cut().value_counts(sort='False')` instead of `np.histogram`, especially if it would allay any concerns about working consistently across data types.\r\n```python\r\n# somewhere in Series...\r\ndef histogram(self, bins=10, ...):\r\n    return pd.cut(self, bins).value_counts(sort='False')\r\n```\r\n\r\nBut my main objections to using `pd.cut().value_counts(sort='False')` are: \r\n- that it returns a categorical index even when the series is continuous and numerical, and \r\n- that it does not allow me to use the auto-binning methods in `np.histogram`\r\n- that it doesn't provide the density keyword\r\n\r\nPerhaps the compromise would be to use `pd.cut().value_counts(sort='False')` unless: the bins arg is one of the auto-binning methods, the density kwarg is true, or some other kwarg is set.\r\n\r\nMy two present use cases involve:\r\n- adding histograms of the same variable from different logs to give me the histogram of the joined logs (instead of having to concatenate all the logs before doing the histogram)\r\n- plotting histograms of several related series stacked together as a pcolor heatmap\r\n\r\nI'll work up some dummy data for illustrative purposes if needed. Another use case pops up when you want to look at the difference between two histograms, for example, or any other time when the histogram counts are an intermediate part of a calculation.\r\n\r\nI can keep going on my own work using a local method or subclassing Series, but it struck me as something that others would find useful if it was there, so I submitted it as #23580."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/438890302",
    "html_url": "https://github.com/pandas-dev/pandas/issues/23710#issuecomment-438890302",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/23710",
    "id": 438890302,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQzODg5MDMwMg==",
    "user": {
      "login": "bluesquall",
      "id": 514022,
      "node_id": "MDQ6VXNlcjUxNDAyMg==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/514022?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluesquall",
      "html_url": "https://github.com/bluesquall",
      "followers_url": "https://api.github.com/users/bluesquall/followers",
      "following_url": "https://api.github.com/users/bluesquall/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluesquall/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluesquall/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluesquall/subscriptions",
      "organizations_url": "https://api.github.com/users/bluesquall/orgs",
      "repos_url": "https://api.github.com/users/bluesquall/repos",
      "events_url": "https://api.github.com/users/bluesquall/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluesquall/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-11-15T02:12:09Z",
    "updated_at": "2018-11-15T02:12:09Z",
    "author_association": "NONE",
    "body": "You could also think of my first use case as an extension of a [stacked bar graph](https://matplotlib.org/gallery/lines_bars_and_markers/bar_stacked.html), if you want, but right now I don't need to differentiate the logs once the histograms are joined together.\r\n\r\nHere's some dummy data, a bit simplified, but hopefully illustrating the point:\r\n```python\r\nminutes = np.floor(np.random.normal(60,20,12)).astype(int)\r\nedges = np.arange(0,1000,100)\r\ncenters = 0.5*(edges[1:] + edges[:-1])\r\nh, b = np.histogram(s[0], edges)\r\nfor _s in s[1:]:\r\n    _h, _b = np.histogram(_s, edges)\r\n    h += _h\r\nplt.bar(centers, h, width=np.diff(edges))\r\n\r\n# and if you want to look at it a slightly different way:\r\nfor _s in s:\r\n    _h, _b = np.histogram(_s, edges)\r\n    plt.bar(centers, _h, width=np.diff(edges), color='g', alpha=0.05)\r\n```\r\n\r\nOne key consideration that I made sure to include in this dummy data is that the lengths of each series are not the same, but the range of the variable `x` is comparable across series."
  }
]
