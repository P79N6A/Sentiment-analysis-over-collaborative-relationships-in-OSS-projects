[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48823964",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48823964",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48823964,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODIzOTY0",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-12T21:02:22Z",
    "updated_at": "2014-07-12T21:02:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "http://pandas.pydata.org/pandas-docs/stable/groupby.html#flexible-apply\n\nsee the warning\nthis is as expected\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48823977",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48823977",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48823977,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODIzOTc3",
    "user": {
      "login": "cpcloud",
      "id": 417981,
      "node_id": "MDQ6VXNlcjQxNzk4MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/417981?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cpcloud",
      "html_url": "https://github.com/cpcloud",
      "followers_url": "https://api.github.com/users/cpcloud/followers",
      "following_url": "https://api.github.com/users/cpcloud/following{/other_user}",
      "gists_url": "https://api.github.com/users/cpcloud/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cpcloud/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cpcloud/subscriptions",
      "organizations_url": "https://api.github.com/users/cpcloud/orgs",
      "repos_url": "https://api.github.com/users/cpcloud/repos",
      "events_url": "https://api.github.com/users/cpcloud/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cpcloud/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-12T21:02:46Z",
    "updated_at": "2014-07-12T21:02:46Z",
    "author_association": "MEMBER",
    "body": "See https://github.com/pydata/pandas/issues/6753 as well\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48826141",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48826141",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48826141,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI2MTQx",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-12T22:47:14Z",
    "updated_at": "2014-07-12T22:47:14Z",
    "author_association": "NONE",
    "body": "My apologies, I guess I was looking at the [dev version](http://pandas.pydata.org/pandas-docs/dev/groupby.html#flexible-apply) of the docs, which lacks the warning?  I'm not really sure how I wound up there, though.\n\nMaybe it is worth documenting what influences the choice to take the \"fast path\" or the \"slow path\".  That sounds important, from an optimization standpoint.  If I have code that could work with the \"fast path\", I'd hate for it to decide to use the \"slow path\" just because I coded it one way when I could have coded it another.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48826492",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48826492",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48826492,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI2NDky",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-12T23:04:25Z",
    "updated_at": "2014-07-12T23:04:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "you were looking at 0.13.1 docs\n0.14.1 is the current\n\ncertainly would take a pr for an update\n\nin a nutshell:\n- fastest by far are the built in cythonized functions (eg mean,sum,min, etc)\n- fast path if u don't mutate the passed in data inside the apply this can be done in cython\n- slow path otherwise (also can happen if an exception is raised in the apply)\n\nso it's not 100% obvious what happens just by examing code, that's why a trial happens \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48827571",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48827571",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48827571,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI3NTcx",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T00:06:39Z",
    "updated_at": "2014-07-13T00:06:39Z",
    "author_association": "NONE",
    "body": "Can I provide hints, or even manually select the path I think applies (risking an exception or even crash if I choose wrong)?\n\nI would really like to avoid the extra invocation of my function, because it is expensive.  At present, the best I can do seems to be to deliberately raise an exception on the first call (e.g. by asking for the group's `name` attribute, which doesn't exist during the trial).  But, it seems this will force it down the slow path, and I'm not sure this is the fastest in my use-case.\n\nTo clarify, I'm performing a relatively expensive computation involving several other columns, and creating a few new columns which I add to the `DataFrame`.  I'm following the method of http://stackoverflow.com/a/12394122/2539647 .  I would guess this forces me down the slow path whether or not an exception is raised, even though I am not mutating the existing columns, just adding a new one(s).  Is there a better way?\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48827840",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48827840",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48827840,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI3ODQw",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T00:22:35Z",
    "updated_at": "2014-07-13T00:22:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "don't use apply instead something like:\n\nconcat([ func(c) for c, col in df.iteritems() ], axis=1) \n\nmight work\n\nw/I showing what you are doing its just guessing\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48828076",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48828076",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48828076,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI4MDc2",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T00:36:50Z",
    "updated_at": "2014-07-13T00:36:50Z",
    "author_association": "NONE",
    "body": "No, that won't work at all.  I will try to be clearer.  I'm actually computing the most-likely state sequence from a hidden markov model, where each group is treated completely independently.  Each row in the `DataFrame` corresponds to one step in the model, so each step in the state sequence can be stored as one row (well, the value of a new column in one row) in the same `DataFrame`.  So, I want to group, then hand each sub-frame to the Viterbi algorithm (implemented with `numba`), then store the resulting state sequence in a way that I can easily compare it (row-wise) with an already-existing column in the DataFrame.\n\nIn another case, I need to do things like compute the group-wise mean of one column, and compare that to the value in another column.\n\nIn both cases, `groupby` with `apply` seems the correct choice.  I can iterate over the group members, but it isn't clear then the best way to stitch the results of the individual groups back together into a new column in the `DataFrame`.  Also, I hate to iterate when I don't care about the order, since you might one day implement a magical concurrent-dispatch for `groupby().apply()` (or whatever I wind up using if something else is more appropriate).\n\nUnless I've misunderstood something, the `DataFrame.iteritems()` you recommend iterates over columns.  That isn't what I need at all.  I need to use several (sometimes all) columns in different ways in a single computation, but that computation is group-specific.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48828389",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48828389",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48828389,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI4Mzg5",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T00:53:42Z",
    "updated_at": "2014-07-13T00:53:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "code is worth a 1000 words here\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48829019",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48829019",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48829019,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODI5MDE5",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T01:31:53Z",
    "updated_at": "2014-07-13T01:31:53Z",
    "author_association": "NONE",
    "body": "OK, this is the one that isn't so expensive, but it doesn't require me to copy my numba implementation of the Viterbi algorithm, which is not really relevant.\n\n```\ndf = pd.DataFrame({'groupNum' : [0, ..., 0, 1, ..., 1, 2, ..., 2, ...],\n                   'EventTime' : [1331001304, 1331001307, 1331001315, ..., 1580225652, 1580225653, 1580225658, ...],\n                   'LiveTime' : [1258, 2380, 737, ..., 139, 4452, 3, ...]})\n\ndef Cuts(group):\n    EvTimes = group.EventTime - amin(group.EventTime)\n    EventTimeHist, EventTimeBins = histogram(EvTimes, bins=arange(0, amax(EvTimes) + 201, 200), weights=ones(len(EvTimes))/200)\n    CutBins1 = EventTimeHist > 3\n    binnumbers = np.digitize(EvTimes, bins=EventTimeBins)\n    group['Cut1'] = CutBins1[binnumbers-1]\n\n    passing1 = EventTimeHist[EventTimeHist < 3]\n    CutBins2 = EventTimeHist > (median(passing1) + 8*sqrt(median(passing1)))\n    group['Cut2'] = CutBins2[binnumbers - 1]\n\n    bursting = group.Cut1 | group.Cut2\n    if sum(bursting) != 0:\n        Nburst = sum(bursting)\n        Nnoburst = sum(~bursting)\n        BurstLive = sum(group.LiveTime[bursting])\n        NoBurstLive = sum(group.LiveTime[~bursting])\n\n        group['Cut3'] = (((Nburst / BurstLive) < 3) | ((Nburst / BurstLive) < 2*(Nnoburst/NoBurstLive)))\n    else:\n        group['Cut3'] = ((len(group) / sum(group.LiveTime)) > 3)\n    return group\n\ndf_with_cuts = df..groupby('groupNum').apply(Cuts)\n```\n\nThen, I have a DataFrame that has three new columns, `Cut1`, `Cut2`, and `Cut3`.\n\nYou can see that I need all the columns at once, and I need to add a column, and I need to handle things on a group-by-group basis.  Is this clearer?\n\nI suppose that, strictly speaking, I don't need to add a column.  I just need a sequence of homogenously-typed data elements that has an exact item-to-row correspondence with the existing data frame.  But, if I had that, then I could trivially add that as a column, so saying \"I need to add a column\" is just shorthand.  I hope that's clear.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48839794",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48839794",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48839794,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODM5Nzk0",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T12:54:31Z",
    "updated_at": "2014-07-13T12:54:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "Your example is not reproducible, try something like this to generate your data. A copy-paste example is a must for a problem like this.\n\n```\nIn [50]: np.random.seed(1234)\n\nIn [51]: pd.set_option('max_rows',10)\n\nIn [52]: df = DataFrame({'groupNum' :np.repeat(np.arange(3),N/3),'EventTime' : np.sort(np.random.choice(np.arange(1331001304,1580225658),N)),'LiveTime':np.random.randint(0,1000,size=N)})\n\nIn [53]: df\nOut[53]: \n       EventTime  LiveTime  groupNum\n0     1331069944       301         0\n1     1331213814       479         0\n2     1331389500       404         0\n3     1331421395       458         0\n4     1331656978       241         0\n...          ...       ...       ...\n2995  1579725319       822         2\n2996  1579843342       685         2\n2997  1579956576       357         2\n2998  1580018358       335         2\n2999  1580051273       217         2\n\n[3000 rows x 3 columns]\n```\n\nMost of the operations can simply be refactored out of the groupby, e.g.\n\nThis is `EvTimes = group.EventTime - amin(group.EventTime)`\n\n```\ng = df.groupby('groupNum')\ndf['EventTime']-g['EventTime'].transform('min')\n```\n\nyou should simply use `pd.cut` rather than using `np.digiitize and np.histogram`. I can't look into your example w/o a repro as above.\n\nTry to do as much as possible outside the groupby, and then use the cythonized ops to make this faster\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48844976",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48844976",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48844976,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODQ0OTc2",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T16:23:37Z",
    "updated_at": "2014-07-13T16:23:37Z",
    "author_association": "NONE",
    "body": "I think we're talking at cross purposes.  I'm asking a general question (and making a general suggestion and/or feature request), not asking for help optimizing my code.  You seemed to fundamentally misunderstand what I was talking about (the `iteritems()` example was not remotely applicable) and you requested my specific code.  I thought you wanted the code to help clarify the general question, but you dove in and tried to tell me how to optimize it.  Not what I was looking for.\n\nHere is some code which illustrates the general problem without providing specifics to get distracted by:\n\n```\ndef func(group):\n    # this must be applied group-wise for reasons beyond my control\n    group['newcol'] = expensive_and_effectful_function(group['col1'], group['col2'], group['col3'])\n    return group\n\n#newdf = df.groupby(foo).apply(func) # don't do this because it is expensive and the side-effects clobber something\n\nnewstuff = [expensive_and_effectful_function(group['col1'], group['col2'], group['col3']) for name, group in df.groupby(foo)]\n# But now what do I do with newstuff to get back a dataframe with the new computed column included?\n\ndef make_alternate_func():\n    first_run = True\n    def alternate_func(group):\n        if first_run:\n            first_run = False\n            raise Exception\n        return func(group)\n    return alternate_func\n\nnewdf = df.groupby(foo).apply(make_alternate_func()) # This one works just fine, but I gather it uses the \"slow path\" because it raises an exception\n```\n\nBy \"effectful\", I mean something like disk writes, not modifications to the preexisting columns of `group`.  All I want to do is to compute a new column, not modify the old columns.  Does that count as \"mutating the passed in data\"?  Is `expensive_and_effectful_function` doomed to follow the \"slow path\" no matter what?  If that's the case, then I'll just raise an exception on the first run and avoid the duplication that way, even though it's an ugly kludge.\n\nTo put it another way, the duplication of the first run is to allow `apply` to figure something out.  If I already know what it is trying to figure out, can I tell it and save it the trouble?\n\nAnd, lest I come off as too annoyed, demanding, or ungrateful, let me take the opportunity to thank all the pandas developers/contributors.  It is really a wonderful tool, and I use it almost daily.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48849585",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48849585",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48849585,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODQ5NTg1",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T19:18:57Z",
    "updated_at": "2014-07-13T19:18:57Z",
    "author_association": "CONTRIBUTOR",
    "body": "generally I see comments about wanting to do something when in fact the user is not approach in the problem in a pandonic / efficient manner. that's why seeing runnable code is useful. you. an take my suggestion am and use them (or not). as I said you should do things outside of the groupby as much as possible\n\nthis may help as well: http://pandas.pydata.org/pandas-docs/stable/groupby.html#iterating-through-groups\nit may make sense not to use apply in your case\n\nas far as generally make an option available to chose which path pandas takes is self defeating and too complicated. it's an implementation detail. you can simply look ok the code if u care or use a groupy iteration if u want to completely avoid side effects ,which it seems u do)\n\nno worries otherwise - trying just to make pandas generally useful with a consistent and simple as possible API (which are of course frequently at cross purposes)\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48850767",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48850767",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48850767,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODUwNzY3",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T20:10:22Z",
    "updated_at": "2014-07-13T20:10:22Z",
    "author_association": "NONE",
    "body": "It's a very slick, high-level API.  But it tries to guess what the user wants, and sometimes this results in very unexpected behavior that is quite difficult to work around without the user including snippets of code that are completely unrelated to what the user wants to do.  Personally, I am not a fan of APIs that try to be too smart.  I know what I want, and I want to tell the computer to do what I want.\n\nSo, feature request: could you please provide a lower-level API that would allow more direct control over the flow of execution?  Just a simple `slow_apply` method would do.  It would even allow a bit of refactoring, because you could take the [`BaseGrouper.apply()` method](https://github.com/pydata/pandas/blob/master/pandas/core/groupby.py#L1213), and turn the lower half of it into a call to `slow_apply`.\n\nCurrently, `apply` does _exactly_ what I want, _except_ that it calls my function an extra time, which at minimum violates least surprise and at worst destroys data.  If I use a `groupby` iteration, then I have to repeat the code (that already exists in the `groupby` module) for taking the result and gluing it back together.  This violates the DRY principle.\n\nI'm working up a minimal working example of my other use-case for `groupby().apply()`; perhaps it will be more useful in this discussion, because it really can't be broken up into in- and out-of `groupby` steps.  I'll post a notebook when I'm done.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48851078",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48851078",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48851078,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODUxMDc4",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T20:24:04Z",
    "updated_at": "2014-07-13T20:24:04Z",
    "author_association": "NONE",
    "body": "I see that there is an [old enhancement request open](https://github.com/pydata/pandas/issues/2936) to add the `slow_apply` method I'm requesting (or something similar).  So let me lend my voice to those calling for such a thing.\n\nAlternatively, in some cases it might be possible to capture the results of `fast_apply` from the first group, and not call the user function again in those cases.\n\nMaybe at some point I'll even take a crack at implementing these things myself.\n\nFWIW, I don't buy the argument that these things are an \"implementation detail\" -- The way in which _my code_ is called is very important to me, and that brings it quite a bit beyond the level of \"implementation detail\".\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48851324",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48851324",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48851324,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODUxMzI0",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T20:37:06Z",
    "updated_at": "2014-07-13T20:37:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "well pull requests are welcome\n\nand it IS an implementation detail\nyou are providing a function for pandas to call\nthe fact that it may be called twice (or in an arbitrary order) is up to the caller\nnot up to the function - hence it's a detail of the implementation\n\nif u abide by the API of the groupby and don't have side effects then their is no issue\npandas is trying to accommodate an arbitrary function here\nit could simply raise of I have side effects which I would call an API design \nbut the fact that it then deals with it in implemtation\n\nif u want to have your function called in a particular way then go ahead and don't use apply \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48851720",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48851720",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48851720,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODUxNzIw",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T20:57:00Z",
    "updated_at": "2014-07-13T20:57:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think the way to do this is to add a parameter\nmaybe: try_fastpath=True to the groupby\n\nthen the user can change that if wanted \n\nusing the already computed group is done in transform iirc\nI think it could be done generally but just wasn't implemented that way (in apply)\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/48852488",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7739#issuecomment-48852488",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7739",
    "id": 48852488,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODUyNDg4",
    "user": {
      "login": "jsw-fnal",
      "id": 1820733,
      "node_id": "MDQ6VXNlcjE4MjA3MzM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1820733?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jsw-fnal",
      "html_url": "https://github.com/jsw-fnal",
      "followers_url": "https://api.github.com/users/jsw-fnal/followers",
      "following_url": "https://api.github.com/users/jsw-fnal/following{/other_user}",
      "gists_url": "https://api.github.com/users/jsw-fnal/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jsw-fnal/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jsw-fnal/subscriptions",
      "organizations_url": "https://api.github.com/users/jsw-fnal/orgs",
      "repos_url": "https://api.github.com/users/jsw-fnal/repos",
      "events_url": "https://api.github.com/users/jsw-fnal/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jsw-fnal/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-07-13T21:32:13Z",
    "updated_at": "2014-07-13T21:32:13Z",
    "author_association": "NONE",
    "body": "This seems like a good possibility to me.  I would really appreciate it.\n\nIt might also help to emit a warning when fastpath is attempted and fails.  IPython has a nice facility for displaying a warning only the first time it appears.  It is quite nice.  I don't know exactly how it works, but it seems to be automatic.\n"
  }
]
