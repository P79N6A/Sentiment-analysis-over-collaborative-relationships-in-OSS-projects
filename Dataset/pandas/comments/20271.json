[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/373199780",
    "html_url": "https://github.com/pandas-dev/pandas/pull/20271#issuecomment-373199780",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/20271",
    "id": 373199780,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MzE5OTc4MA==",
    "user": {
      "login": "math-and-data",
      "id": 10563164,
      "node_id": "MDQ6VXNlcjEwNTYzMTY0",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10563164?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/math-and-data",
      "html_url": "https://github.com/math-and-data",
      "followers_url": "https://api.github.com/users/math-and-data/followers",
      "following_url": "https://api.github.com/users/math-and-data/following{/other_user}",
      "gists_url": "https://api.github.com/users/math-and-data/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/math-and-data/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/math-and-data/subscriptions",
      "organizations_url": "https://api.github.com/users/math-and-data/orgs",
      "repos_url": "https://api.github.com/users/math-and-data/repos",
      "events_url": "https://api.github.com/users/math-and-data/events{/privacy}",
      "received_events_url": "https://api.github.com/users/math-and-data/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-14T22:44:16Z",
    "updated_at": "2018-03-14T22:44:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "- [ ] Docstring validation not passing\r\n\r\n```\r\n################################################################################\r\n##################### Docstring (pandas.DataFrame.replace) #####################\r\n################################################################################\r\n\r\nReplace values given in 'to_replace' with 'value'.\r\n\r\nValues of the DataFrame or a Series are being replaced with\r\nother values in a dynamic way. Instead of replacing values in a\r\nspecific cell (row/column combination), this method allows for more\r\nflexibility with replacements. For instance, values can be replaced\r\nby specifying lists of values and replacements separately or\r\nwith a dynamic set of inputs like dicts.\r\n\r\nParameters\r\n----------\r\nto_replace : str, regex, list, dict, Series, int, float, or None\r\n    * numeric, str or regex:\r\n\r\n        - numeric: numeric values equal to ``to_replace`` will be\r\n          replaced with ``value``\r\n        - str: string exactly matching ``to_replace`` will be replaced\r\n          with ``value``\r\n        - regex: regexs matching ``to_replace`` will be replaced with\r\n          ``value``\r\n\r\n    * list of str, regex, or numeric:\r\n\r\n        - First, if ``to_replace`` and ``value`` are both lists, they\r\n          **must** be the same length.\r\n        - Second, if ``regex=True`` then all of the strings in **both**\r\n          lists will be interpreted as regexs otherwise they will match\r\n          directly. This doesn't matter much for ``value`` since there\r\n          are only a few possible substitution regexes you can use.\r\n        - str, regex and numeric rules apply as above.\r\n\r\n    * dict:\r\n\r\n        - Dicts can be used to specify different replacement values\r\n          for different existing values. For example,\r\n          {'a': 'b', 'y': 'z'} replaces the value 'a' with 'b' and\r\n          'y' with 'z'. To use a dict in this way the ``value``\r\n          parameter should be ``None``.\r\n        - For a DataFrame a dict can specify that different values\r\n          should be replaced in different columns. For example,\r\n          {'a': 1, 'b': 'z'} looks for the value 1 in column 'a' and\r\n          the value 'z' in column 'b' and replaces these values with\r\n          whatever is specified in ``value``. The ``value`` parameter\r\n          should not be ``None`` in this case. You can treat this as a\r\n          special case of passing two lists except that you are\r\n          specifying the column to search in.\r\n        - For a DataFrame nested dictionaries, e.g.,\r\n          {'a': {'b': np.nan}}, are read as follows: look in column\r\n          'a' for the value 'b' and replace it with NaN. The ``value``\r\n          parameter should be ``None`` to use a nested dict in this\r\n          way. You can nest regular expressions as well. Note that\r\n          column names (the top-level dictionary keys in a nested\r\n          dictionary) **cannot** be regular expressions.\r\n\r\n    * None:\r\n\r\n        - This means that the ``regex`` argument must be a string,\r\n          compiled regular expression, or list, dict, ndarray or\r\n          Series of such elements. If ``value`` is also ``None`` then\r\n          this **must** be a nested dictionary or ``Series``.\r\n\r\n    See the examples section for examples of each of these.\r\nvalue : scalar, dict, list, str, regex, default None\r\n    Value to replace any values matching ``to_replace`` with.\r\n    For a DataFrame a dict of values can be used to specify which\r\n    value to use for each column (columns not in the dict will not be\r\n    filled). Regular expressions, strings and lists or dicts of such\r\n    objects are also allowed.\r\ninplace : boolean, default False\r\n    If True, in place. Note: this will modify any\r\n    other views on this object (e.g. a column from a DataFrame).\r\n    Returns the caller if this is True.\r\nlimit : int, default None\r\n    Maximum size gap to forward or backward fill.\r\nregex : bool or same types as ``to_replace``, default False\r\n    Whether to interpret ``to_replace`` and/or ``value`` as regular\r\n    expressions. If this is ``True`` then ``to_replace`` *must* be a\r\n    string. Alternatively, this could be a regular expression or a\r\n    list, dict, or array of regular expressions in which case\r\n    ``to_replace`` must be ``None``.\r\nmethod : {'pad', 'ffill', 'bfill', `None`}\r\n    The method to use when for replacement, when ``to_replace`` is a\r\n    scalar, list or tuple and ``value`` is `None`.\r\n    .. versionchanged:: 0.23.0\r\n        Added to DataFrame.\r\naxis : None\r\n    Deprecated.\r\n\r\nSee Also\r\n--------\r\nDataFrame.fillna : Fill `NaN` values\r\nDataFrame.where : Replace values based on boolean condition\r\n\r\nReturns\r\n-------\r\nDataFrame\r\n    Object after replacement.\r\n\r\nRaises\r\n------\r\nAssertionError\r\n    * If ``regex`` is not a ``bool`` and ``to_replace`` is not\r\n      ``None``.\r\nTypeError\r\n    * If ``to_replace`` is a ``dict`` and ``value`` is not a ``list``,\r\n      ``dict``, ``ndarray``, or ``Series``\r\n    * If ``to_replace`` is ``None`` and ``regex`` is not compilable\r\n      into a regular expression or is a list, dict, ndarray, or\r\n      Series.\r\n    * When replacing multiple ``bool`` or ``datetime64`` objects and\r\n      the arguments to ``to_replace`` does not match the type of the\r\n      value being replaced\r\nValueError\r\n    * If a ``list`` or an ``ndarray`` is passed to ``to_replace`` and\r\n      `value` but they are not the same length.\r\n\r\nNotes\r\n-----\r\n* Regex substitution is performed under the hood with ``re.sub``. The\r\n  rules for substitution for ``re.sub`` are the same.\r\n* Regular expressions will only substitute on strings, meaning you\r\n  cannot provide, for example, a regular expression matching floating\r\n  point numbers and expect the columns in your frame that have a\r\n  numeric dtype to be matched. However, if those floating point\r\n  numbers *are* strings, then you can do this.\r\n* This method has *a lot* of options. You are encouraged to experiment\r\n  and play with this method to gain intuition about how it works.\r\n* When dict is used as the ``to_replace`` value, it is like\r\n  key(s) in the dict are the to_replace part and\r\n  value(s) in the dict are the value parameter.\r\n\r\nExamples\r\n--------\r\n\r\n>>> s = pd.Series([0, 1, 2, 3, 4])\r\n>>> s.replace(0, 5)\r\n0    5\r\n1    1\r\n2    2\r\n3    3\r\n4    4\r\ndtype: int64\r\n>>> df = pd.DataFrame({'A': [0, 1, 2, 3, 4],\r\n...                    'B': [5, 6, 7, 8, 9],\r\n...                    'C': ['a', 'b', 'c', 'd', 'e']})\r\n>>> df.replace(0, 5)\r\n   A  B  C\r\n0  5  5  a\r\n1  1  6  b\r\n2  2  7  c\r\n3  3  8  d\r\n4  4  9  e\r\n\r\n>>> df.replace([0, 1, 2, 3], 4)\r\n   A  B  C\r\n0  4  5  a\r\n1  4  6  b\r\n2  4  7  c\r\n3  4  8  d\r\n4  4  9  e\r\n>>> df.replace([0, 1, 2, 3], [4, 3, 2, 1])\r\n   A  B  C\r\n0  4  5  a\r\n1  3  6  b\r\n2  2  7  c\r\n3  1  8  d\r\n4  4  9  e\r\n>>> s.replace([1, 2], method='bfill')\r\n0    0\r\n1    3\r\n2    3\r\n3    3\r\n4    4\r\ndtype: int64\r\n\r\n>>> df.replace({0: 10, 1: 100})\r\n     A  B  C\r\n0   10  5  a\r\n1  100  6  b\r\n2    2  7  c\r\n3    3  8  d\r\n4    4  9  e\r\n>>> df.replace({'A': 0, 'B': 5}, 100)\r\n     A    B  C\r\n0  100  100  a\r\n1    1    6  b\r\n2    2    7  c\r\n3    3    8  d\r\n4    4    9  e\r\n>>> df.replace({'A': {0: 100, 4: 400}})\r\n     A  B  C\r\n0  100  5  a\r\n1    1  6  b\r\n2    2  7  c\r\n3    3  8  d\r\n4  400  9  e\r\n\r\n>>> df = pd.DataFrame({'A': ['bat', 'foo', 'bait'],\r\n...                    'B': ['abc', 'bar', 'xyz']})\r\n>>> df.replace(to_replace=r'^ba.$', value='new', regex=True)\r\n      A    B\r\n0   new  abc\r\n1   foo  new\r\n2  bait  xyz\r\n>>> df.replace({'A': r'^ba.$'}, {'A': 'new'}, regex=True)\r\n      A    B\r\n0   new  abc\r\n1   foo  bar\r\n2  bait  xyz\r\n>>> df.replace(regex=r'^ba.$', value='new')\r\n      A    B\r\n0   new  abc\r\n1   foo  new\r\n2  bait  xyz\r\n>>> df.replace(regex={r'^ba.$':'new', 'foo':'xyz'})\r\n      A    B\r\n0   new  abc\r\n1   xyz  new\r\n2  bait  xyz\r\n>>> df.replace(regex=[r'^ba.$', 'foo'], value='new')\r\n      A    B\r\n0   new  abc\r\n1   new  new\r\n2  bait  xyz\r\n\r\nNote that when replacing multiple ``bool`` or ``datetime64`` objects,\r\nthe data types in the ``to_replace`` parameter must match the data\r\ntype of the value being replaced:\r\n\r\n>>> df = pd.DataFrame({'A': [True, False, True],\r\n...                    'B': [False, True, False]})\r\n>>> df.replace({'a string': 'new value', True: False})  # raises\r\nTypeError: Cannot compare types 'ndarray(dtype=bool)' and 'str'\r\n\r\nThis raises a ``TypeError`` because one of the ``dict`` keys is not of\r\nthe correct type for replacement.\r\n\r\nCompare the behavior of ``s.replace({'a': None})`` and\r\n``s.replace('a', None)`` to understand the pecularities\r\nof the ``to_replace`` parameter:\r\n\r\n>>> s = pd.Series([10, 'a', 'a', 'b', 'a'])\r\n\r\nWhen one uses a dict as the ``to_replace`` value, it is like the\r\nvalue(s) in the dict are equal to the value parameter.\r\n``s.replace({'a': None})`` is equivalent to\r\n``s.replace(to_replace={'a': None}, value=None, method=None)``:\r\n\r\n>>> s.replace({'a': None})\r\n0      10\r\n1    None\r\n2    None\r\n3       b\r\n4    None\r\ndtype: object\r\n\r\nWhen ``value=None`` and ``to_replace`` are a scalar, list or\r\ntuple, ``replace`` uses the method parameter (default 'pad') to do the\r\nreplacement. So this is why the 'a' values are being replaced by 10\r\nin rows 1 and 2 and 'b' in row 4 in this case.\r\nThe command ``s.replace('a', None)`` is actually equivalent to\r\n``s.replace(to_replace='a', value=None, method='pad')``:\r\n\r\n>>> s.replace('a', None)\r\n0    10\r\n1    10\r\n2    10\r\n3     b\r\n4     b\r\ndtype: object\r\n\r\n################################################################################\r\n################################## Validation ##################################\r\n################################################################################\r\n\r\nErrors found:\r\n        Errors in parameters section\r\n                Parameter \"to_replace\" description should start with capital letter\r\n        Examples do not pass tests\r\n\r\n################################################################################\r\n################################### Doctests ###################################\r\n################################################################################\r\n\r\n**********************************************************************\r\nLine 233, in pandas.DataFrame.replace\r\nFailed example:\r\n    df.replace({'a string': 'new value', True: False})  # raises\r\nException raised:\r\n    Traceback (most recent call last):\r\n      File \"C:\\Users\\thisi\\AppData\\Local\\conda\\conda\\envs\\pandas_dev\\lib\\doctest.py\", line 1330, in __run\r\n        compileflags, 1), test.globs)\r\n      File \"<doctest pandas.DataFrame.replace[17]>\", line 1, in <module>\r\n        df.replace({'a string': 'new value', True: False})  # raises\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\frame.py\", line 3136, in replace\r\n        method=method, axis=axis)\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\generic.py\", line 5205, in replace\r\n        limit=limit, regex=regex)\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\frame.py\", line 3136, in replace\r\n        method=method, axis=axis)\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\generic.py\", line 5254, in replace\r\n        regex=regex)\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\internals.py\", line 3696, in replace_list\r\n        masks = [comp(s) for i, s in enumerate(src_list)]\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\internals.py\", line 3696, in <listcomp>\r\n        masks = [comp(s) for i, s in enumerate(src_list)]\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\internals.py\", line 3694, in comp\r\n        return _maybe_compare(values, getattr(s, 'asm8', s), operator.eq)\r\n      File \"C:\\Users\\thisi\\Documents\\GitHub\\pandas\\pandas\\core\\internals.py\", line 5122, in _maybe_compare\r\n        b=type_names[1]))\r\n    TypeError: Cannot compare types 'ndarray(dtype=bool)' and 'str'\r\n```\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/373404254",
    "html_url": "https://github.com/pandas-dev/pandas/pull/20271#issuecomment-373404254",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/20271",
    "id": 373404254,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MzQwNDI1NA==",
    "user": {
      "login": "codecov[bot]",
      "id": 22429695,
      "node_id": "MDM6Qm90MjI0Mjk2OTU=",
      "avatar_url": "https://avatars2.githubusercontent.com/in/254?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/codecov%5Bbot%5D",
      "html_url": "https://github.com/apps/codecov",
      "followers_url": "https://api.github.com/users/codecov%5Bbot%5D/followers",
      "following_url": "https://api.github.com/users/codecov%5Bbot%5D/following{/other_user}",
      "gists_url": "https://api.github.com/users/codecov%5Bbot%5D/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/codecov%5Bbot%5D/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/codecov%5Bbot%5D/subscriptions",
      "organizations_url": "https://api.github.com/users/codecov%5Bbot%5D/orgs",
      "repos_url": "https://api.github.com/users/codecov%5Bbot%5D/repos",
      "events_url": "https://api.github.com/users/codecov%5Bbot%5D/events{/privacy}",
      "received_events_url": "https://api.github.com/users/codecov%5Bbot%5D/received_events",
      "type": "Bot",
      "site_admin": false
    },
    "created_at": "2018-03-15T14:54:58Z",
    "updated_at": "2018-04-22T00:56:07Z",
    "author_association": "NONE",
    "body": "# [Codecov](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=h1) Report\n> Merging [#20271](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=desc) into [master](https://codecov.io/gh/pandas-dev/pandas/commit/cdfce2b0ad99f7faad57cc5247cf33aab5725bed?src=pr&el=desc) will **increase** coverage by `0.02%`.\n> The diff coverage is `100%`.\n\n[![Impacted file tree graph](https://codecov.io/gh/pandas-dev/pandas/pull/20271/graphs/tree.svg?width=650&height=150&src=pr&token=eZ4WkYLtcO)](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=tree)\n\n```diff\n@@            Coverage Diff             @@\n##           master   #20271      +/-   ##\n==========================================\n+ Coverage   91.82%   91.84%   +0.02%     \n==========================================\n  Files         152      153       +1     \n  Lines       49248    49305      +57     \n==========================================\n+ Hits        45222    45286      +64     \n+ Misses       4026     4019       -7\n```\n\n| Flag | Coverage Δ | |\n|---|---|---|\n| #multiple | `90.24% <100%> (+0.02%)` | :arrow_up: |\n| #single | `41.89% <53.84%> (ø)` | :arrow_up: |\n\n| [Impacted Files](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=tree) | Coverage Δ | |\n|---|---|---|\n| [pandas/core/generic.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvZ2VuZXJpYy5weQ==) | `95.94% <100%> (+0.08%)` | :arrow_up: |\n| [pandas/io/clipboard/clipboards.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2lvL2NsaXBib2FyZC9jbGlwYm9hcmRzLnB5) | `30.58% <0%> (-1.6%)` | :arrow_down: |\n| [pandas/core/config\\_init.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvY29uZmlnX2luaXQucHk=) | `99.24% <0%> (-0.76%)` | :arrow_down: |\n| [pandas/core/arrays/categorical.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvYXJyYXlzL2NhdGVnb3JpY2FsLnB5) | `95.78% <0%> (-0.41%)` | :arrow_down: |\n| [pandas/core/nanops.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvbmFub3BzLnB5) | `96.3% <0%> (-0.4%)` | :arrow_down: |\n| [pandas/util/\\_decorators.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL3V0aWwvX2RlY29yYXRvcnMucHk=) | `82.25% <0%> (-0.15%)` | :arrow_down: |\n| [pandas/plotting/\\_core.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL3Bsb3R0aW5nL19jb3JlLnB5) | `82.39% <0%> (-0.12%)` | :arrow_down: |\n| [pandas/io/pytables.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2lvL3B5dGFibGVzLnB5) | `92.41% <0%> (-0.05%)` | :arrow_down: |\n| [pandas/core/frame.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL2NvcmUvZnJhbWUucHk=) | `97.16% <0%> (-0.02%)` | :arrow_down: |\n| [pandas/tseries/offsets.py](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree#diff-cGFuZGFzL3RzZXJpZXMvb2Zmc2V0cy5weQ==) | `97% <0%> (-0.01%)` | :arrow_down: |\n| ... and [27 more](https://codecov.io/gh/pandas-dev/pandas/pull/20271/diff?src=pr&el=tree-more) | |\n\n------\n\n[Continue to review full report at Codecov](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=continue).\n> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`\n> Powered by [Codecov](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=footer). Last update [cdfce2b...58f6531](https://codecov.io/gh/pandas-dev/pandas/pull/20271?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/373404868",
    "html_url": "https://github.com/pandas-dev/pandas/pull/20271#issuecomment-373404868",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/20271",
    "id": 373404868,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MzQwNDg2OA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-15T14:56:44Z",
    "updated_at": "2018-03-15T14:56:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "Updated\r\n\r\n<details>\r\n\r\n```\r\n################################################################################\r\n##################### Docstring (pandas.DataFrame.replace) #####################\r\n################################################################################\r\n\r\nReplace values given in `to_replace` with `value`.\r\n\r\nValues of the DataFrame are replaced with other values dynamically.\r\nThis differs from updating with ``.loc`` or ``.iloc``, which require\r\nyou to specify a location to update with some value.\r\n\r\nParameters\r\n----------\r\nto_replace : str, regex, list, dict, Series, int, float, or None\r\n    How to find the values that will be replaced.\r\n\r\n    * numeric, str or regex:\r\n\r\n        - numeric: numeric values equal to `to_replace` will be\r\n          replaced with `value`\r\n        - str: string exactly matching `to_replace` will be replaced\r\n          with `value`\r\n        - regex: regexs matching `to_replace` will be replaced with\r\n          `value`\r\n\r\n    * list of str, regex, or numeric:\r\n\r\n        - First, if `to_replace` and `value` are both lists, they\r\n          **must** be the same length.\r\n        - Second, if ``regex=True`` then all of the strings in **both**\r\n          lists will be interpreted as regexs otherwise they will match\r\n          directly. This doesn't matter much for `value` since there\r\n          are only a few possible substitution regexes you can use.\r\n        - str, regex and numeric rules apply as above.\r\n\r\n    * dict:\r\n\r\n        - Dicts can be used to specify different replacement values\r\n          for different existing values. For example,\r\n          ``{'a': 'b', 'y': 'z'}`` replaces the value 'a' with 'b' and\r\n          'y' with 'z'. To use a dict in this way the `value`\r\n          parameter should be `None`.\r\n        - For a DataFrame a dict can specify that different values\r\n          should be replaced in different columns. For example,\r\n          ``{'a': 1, 'b': 'z'}`` looks for the value 1 in column 'a'\r\n          and the value 'z' in column 'b' and replaces these values\r\n          with whatever is specified in `value`. The `value` parameter\r\n          should not be ``None`` in this case. You can treat this as a\r\n          special case of passing two lists except that you are\r\n          specifying the column to search in.\r\n        - For a DataFrame nested dictionaries, e.g.,\r\n          ``{'a': {'b': np.nan}}``, are read as follows: look in column\r\n          'a' for the value 'b' and replace it with NaN. The `value`\r\n          parameter should be ``None`` to use a nested dict in this\r\n          way. You can nest regular expressions as well. Note that\r\n          column names (the top-level dictionary keys in a nested\r\n          dictionary) **cannot** be regular expressions.\r\n\r\n    * None:\r\n\r\n        - This means that the `regex` argument must be a string,\r\n          compiled regular expression, or list, dict, ndarray or\r\n          Series of such elements. If `value` is also ``None`` then\r\n          this **must** be a nested dictionary or Series.\r\n\r\n    See the examples section for examples of each of these.\r\nvalue : scalar, dict, list, str, regex, default None\r\n    Value to replace any values matching `to_replace` with.\r\n    For a DataFrame a dict of values can be used to specify which\r\n    value to use for each column (columns not in the dict will not be\r\n    filled). Regular expressions, strings and lists or dicts of such\r\n    objects are also allowed.\r\ninplace : boolean, default False\r\n    If True, in place. Note: this will modify any\r\n    other views on this object (e.g. a column from a DataFrame).\r\n    Returns the caller if this is True.\r\nlimit : int, default None\r\n    Maximum size gap to forward or backward fill.\r\nregex : bool or same types as `to_replace`, default False\r\n    Whether to interpret `to_replace` and/or `value` as regular\r\n    expressions. If this is ``True`` then `to_replace` *must* be a\r\n    string. Alternatively, this could be a regular expression or a\r\n    list, dict, or array of regular expressions in which case\r\n    `to_replace` must be ``None``.\r\nmethod : {'pad', 'ffill', 'bfill', `None`}\r\n    The method to use when for replacement, when `to_replace` is a\r\n    scalar, list or tuple and `value` is ``None``.\r\n\r\n    .. versionchanged:: 0.23.0\r\n        Added to DataFrame.\r\naxis : None\r\n    Deprecated.\r\n\r\nSee Also\r\n--------\r\nDataFrame.fillna : Fill `NaN` values\r\nDataFrame.where : Replace values based on boolean condition\r\nSeries.str.replace : Simple string replacement.\r\n\r\nReturns\r\n-------\r\nDataFrame\r\n    Object after replacement.\r\n\r\nRaises\r\n------\r\nAssertionError\r\n    * If `regex` is not a ``bool`` and `to_replace` is not\r\n      ``None``.\r\nTypeError\r\n    * If `to_replace` is a ``dict`` and `value` is not a ``list``,\r\n      ``dict``, ``ndarray``, or ``Series``\r\n    * If `to_replace` is ``None`` and `regex` is not compilable\r\n      into a regular expression or is a list, dict, ndarray, or\r\n      Series.\r\n    * When replacing multiple ``bool`` or ``datetime64`` objects and\r\n      the arguments to `to_replace` does not match the type of the\r\n      value being replaced\r\nValueError\r\n    * If a ``list`` or an ``ndarray`` is passed to `to_replace` and\r\n      `value` but they are not the same length.\r\n\r\nNotes\r\n-----\r\n* Regex substitution is performed under the hood with ``re.sub``. The\r\n  rules for substitution for ``re.sub`` are the same.\r\n* Regular expressions will only substitute on strings, meaning you\r\n  cannot provide, for example, a regular expression matching floating\r\n  point numbers and expect the columns in your frame that have a\r\n  numeric dtype to be matched. However, if those floating point\r\n  numbers *are* strings, then you can do this.\r\n* This method has *a lot* of options. You are encouraged to experiment\r\n  and play with this method to gain intuition about how it works.\r\n* When dict is used as the `to_replace` value, it is like\r\n  key(s) in the dict are the to_replace part and\r\n  value(s) in the dict are the value parameter.\r\n\r\nExamples\r\n--------\r\n\r\n**Scalar `to_replace` and `value`**\r\n\r\n>>> s = pd.Series([0, 1, 2, 3, 4])\r\n>>> s.replace(0, 5)\r\n0    5\r\n1    1\r\n2    2\r\n3    3\r\n4    4\r\ndtype: int64\r\n\r\n>>> df = pd.DataFrame({'A': [0, 1, 2, 3, 4],\r\n...                    'B': [5, 6, 7, 8, 9],\r\n...                    'C': ['a', 'b', 'c', 'd', 'e']})\r\n>>> df.replace(0, 5)\r\n   A  B  C\r\n0  5  5  a\r\n1  1  6  b\r\n2  2  7  c\r\n3  3  8  d\r\n4  4  9  e\r\n\r\n**List-like `to_replace`**\r\n\r\n>>> df.replace([0, 1, 2, 3], 4)\r\n   A  B  C\r\n0  4  5  a\r\n1  4  6  b\r\n2  4  7  c\r\n3  4  8  d\r\n4  4  9  e\r\n\r\n>>> df.replace([0, 1, 2, 3], [4, 3, 2, 1])\r\n   A  B  C\r\n0  4  5  a\r\n1  3  6  b\r\n2  2  7  c\r\n3  1  8  d\r\n4  4  9  e\r\n\r\n>>> s.replace([1, 2], method='bfill')\r\n0    0\r\n1    3\r\n2    3\r\n3    3\r\n4    4\r\ndtype: int64\r\n\r\n**dict-like `to_replace`**\r\n\r\n>>> df.replace({0: 10, 1: 100})\r\n     A  B  C\r\n0   10  5  a\r\n1  100  6  b\r\n2    2  7  c\r\n3    3  8  d\r\n4    4  9  e\r\n\r\n>>> df.replace({'A': 0, 'B': 5}, 100)\r\n     A    B  C\r\n0  100  100  a\r\n1    1    6  b\r\n2    2    7  c\r\n3    3    8  d\r\n4    4    9  e\r\n\r\n>>> df.replace({'A': {0: 100, 4: 400}})\r\n     A  B  C\r\n0  100  5  a\r\n1    1  6  b\r\n2    2  7  c\r\n3    3  8  d\r\n4  400  9  e\r\n\r\n**Regular expression `to_replace`**\r\n\r\n>>> df = pd.DataFrame({'A': ['bat', 'foo', 'bait'],\r\n...                    'B': ['abc', 'bar', 'xyz']})\r\n>>> df.replace(to_replace=r'^ba.$', value='new', regex=True)\r\n      A    B\r\n0   new  abc\r\n1   foo  new\r\n2  bait  xyz\r\n\r\n>>> df.replace({'A': r'^ba.$'}, {'A': 'new'}, regex=True)\r\n      A    B\r\n0   new  abc\r\n1   foo  bar\r\n2  bait  xyz\r\n\r\n>>> df.replace(regex=r'^ba.$', value='new')\r\n      A    B\r\n0   new  abc\r\n1   foo  new\r\n2  bait  xyz\r\n\r\n>>> df.replace(regex={r'^ba.$':'new', 'foo':'xyz'})\r\n      A    B\r\n0   new  abc\r\n1   xyz  new\r\n2  bait  xyz\r\n\r\n>>> df.replace(regex=[r'^ba.$', 'foo'], value='new')\r\n      A    B\r\n0   new  abc\r\n1   new  new\r\n2  bait  xyz\r\n\r\nNote that when replacing multiple ``bool`` or ``datetime64`` objects,\r\nthe data types in the `to_replace` parameter must match the data\r\ntype of the value being replaced:\r\n\r\n>>> df = pd.DataFrame({'A': [True, False, True],\r\n...                    'B': [False, True, False]})\r\n>>> df.replace({'a string': 'new value', True: False})  # raises\r\nTraceback (most recent call last):\r\n    ...\r\nTypeError: Cannot compare types 'ndarray(dtype=bool)' and 'str'\r\n\r\nThis raises a ``TypeError`` because one of the ``dict`` keys is not of\r\nthe correct type for replacement.\r\n\r\nCompare the behavior of ``s.replace({'a': None})`` and\r\n``s.replace('a', None)`` to understand the pecularities\r\nof the `to_replace` parameter:\r\n\r\n>>> s = pd.Series([10, 'a', 'a', 'b', 'a'])\r\n\r\nWhen one uses a dict as the `to_replace` value, it is like the\r\nvalue(s) in the dict are equal to the `value` parameter.\r\n``s.replace({'a': None})`` is equivalent to\r\n``s.replace(to_replace={'a': None}, value=None, method=None)``:\r\n\r\n>>> s.replace({'a': None})\r\n0      10\r\n1    None\r\n2    None\r\n3       b\r\n4    None\r\ndtype: object\r\n\r\nWhen ``value=None`` and `to_replace` is a scalar, list or\r\ntuple, `replace` uses the method parameter (default 'pad') to do the\r\nreplacement. So this is why the 'a' values are being replaced by 10\r\nin rows 1 and 2 and 'b' in row 4 in this case.\r\nThe command ``s.replace('a', None)`` is actually equivalent to\r\n``s.replace(to_replace='a', value=None, method='pad')``:\r\n\r\n>>> s.replace('a', None)\r\n0    10\r\n1    10\r\n2    10\r\n3     b\r\n4     b\r\ndtype: object\r\n\r\n################################################################################\r\n################################## Validation ##################################\r\n################################################################################\r\n\r\nDocstring for \"pandas.DataFrame.replace\" correct. :)\r\n\r\n```\r\n﻿</details>\r\n\r\n![fireshot capture 003 - pandas dataframe replace pandas 0 2_ - file____users_taugspurger_sandbox_](https://user-images.githubusercontent.com/1312546/37471185-29211ea8-2837-11e8-8521-e1a89f7eb375.png)\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/373404892",
    "html_url": "https://github.com/pandas-dev/pandas/pull/20271#issuecomment-373404892",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/20271",
    "id": 373404892,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM3MzQwNDg5Mg==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-03-15T14:56:49Z",
    "updated_at": "2018-03-15T14:56:49Z",
    "author_association": "MEMBER",
    "body": "I would personally split this docstring in separate ones for series and dataframe, it's becoming quite a monster :)"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/383385075",
    "html_url": "https://github.com/pandas-dev/pandas/pull/20271#issuecomment-383385075",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/20271",
    "id": 383385075,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM4MzM4NTA3NQ==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-04-22T14:22:29Z",
    "updated_at": "2018-04-22T14:22:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks @math-and-data!"
  }
]
