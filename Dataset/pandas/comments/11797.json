[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/163006930",
    "html_url": "https://github.com/pandas-dev/pandas/issues/11797#issuecomment-163006930",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/11797",
    "id": 163006930,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzAwNjkzMA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-08T20:25:22Z",
    "updated_at": "2015-12-08T20:25:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "What's the pandas issue here? Your iterating over a DataFrame but I don't see anything wrong with that.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/163009805",
    "html_url": "https://github.com/pandas-dev/pandas/issues/11797#issuecomment-163009805",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/11797",
    "id": 163009805,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzAwOTgwNQ==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-08T20:34:34Z",
    "updated_at": "2015-12-08T20:34:34Z",
    "author_association": "CONTRIBUTOR",
    "body": "I'm going to say this is working as intended (although maybe not as expected! working with NaN is trick). It's the same behavior as the standard library\n\n``` python\nIn [1]: d = {}\n\nIn [2]: d[(float('nan'),)] = 1\n\nIn [3]: d[(float('nan'),)] = 2\n\nIn [4]: d\nOut[4]: {(nan,): 1, (nan,): 2}\n```\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/163018731",
    "html_url": "https://github.com/pandas-dev/pandas/issues/11797#issuecomment-163018731",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/11797",
    "id": 163018731,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzAxODczMQ==",
    "user": {
      "login": "kawochen",
      "id": 10709573,
      "node_id": "MDQ6VXNlcjEwNzA5NTcz",
      "avatar_url": "https://avatars2.githubusercontent.com/u/10709573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kawochen",
      "html_url": "https://github.com/kawochen",
      "followers_url": "https://api.github.com/users/kawochen/followers",
      "following_url": "https://api.github.com/users/kawochen/following{/other_user}",
      "gists_url": "https://api.github.com/users/kawochen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kawochen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kawochen/subscriptions",
      "organizations_url": "https://api.github.com/users/kawochen/orgs",
      "repos_url": "https://api.github.com/users/kawochen/repos",
      "events_url": "https://api.github.com/users/kawochen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kawochen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-08T21:09:59Z",
    "updated_at": "2015-12-08T21:10:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "what's happening is that you don't get a `numpy.nan` out of a `DataFrame` -- you get `numpy.float64('nan')`, which doesn't behave like `numpy.nan`.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/163037408",
    "html_url": "https://github.com/pandas-dev/pandas/issues/11797#issuecomment-163037408",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/11797",
    "id": 163037408,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzAzNzQwOA==",
    "user": {
      "login": "Tux1",
      "id": 6661307,
      "node_id": "MDQ6VXNlcjY2NjEzMDc=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/6661307?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Tux1",
      "html_url": "https://github.com/Tux1",
      "followers_url": "https://api.github.com/users/Tux1/followers",
      "following_url": "https://api.github.com/users/Tux1/following{/other_user}",
      "gists_url": "https://api.github.com/users/Tux1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Tux1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Tux1/subscriptions",
      "organizations_url": "https://api.github.com/users/Tux1/orgs",
      "repos_url": "https://api.github.com/users/Tux1/repos",
      "events_url": "https://api.github.com/users/Tux1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Tux1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-08T22:25:10Z",
    "updated_at": "2015-12-08T22:25:10Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thank you @kawochen for your bright explanation. Do you know where I can get documentation about that ? and about RichCompare implementation in numpy especially\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/163115468",
    "html_url": "https://github.com/pandas-dev/pandas/issues/11797#issuecomment-163115468",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/11797",
    "id": 163115468,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzExNTQ2OA==",
    "user": {
      "login": "kawochen",
      "id": 10709573,
      "node_id": "MDQ6VXNlcjEwNzA5NTcz",
      "avatar_url": "https://avatars2.githubusercontent.com/u/10709573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kawochen",
      "html_url": "https://github.com/kawochen",
      "followers_url": "https://api.github.com/users/kawochen/followers",
      "following_url": "https://api.github.com/users/kawochen/following{/other_user}",
      "gists_url": "https://api.github.com/users/kawochen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kawochen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kawochen/subscriptions",
      "organizations_url": "https://api.github.com/users/kawochen/orgs",
      "repos_url": "https://api.github.com/users/kawochen/repos",
      "events_url": "https://api.github.com/users/kawochen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kawochen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-09T05:30:35Z",
    "updated_at": "2015-12-09T05:31:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "@Tux1 numpy/numpy/core/src/umath/umathmodule.c\nI don't think it has much to do with how `numpy` implements rich comparison for anything, tho.  You only need to know that `float64('nan') != float64('nan')`, which as @TomAugspurger said works just like the standard library `float('nan')`.  The reason `np.nan` seems to behave differently in dict is because it is the same object inside `numpy` that is being referred to, just like the global singletons (`None`, `...`, etc.) in python.  If you do `yourmodule.nan = float64('nan')` and use `yourmodule.nan` whenever you need a `nan`, then you get the behavior (in dictionary lookup) of `numpy`'s `nan`.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/163120153",
    "html_url": "https://github.com/pandas-dev/pandas/issues/11797#issuecomment-163120153",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/11797",
    "id": 163120153,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MzEyMDE1Mw==",
    "user": {
      "login": "Tux1",
      "id": 6661307,
      "node_id": "MDQ6VXNlcjY2NjEzMDc=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/6661307?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Tux1",
      "html_url": "https://github.com/Tux1",
      "followers_url": "https://api.github.com/users/Tux1/followers",
      "following_url": "https://api.github.com/users/Tux1/following{/other_user}",
      "gists_url": "https://api.github.com/users/Tux1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Tux1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Tux1/subscriptions",
      "organizations_url": "https://api.github.com/users/Tux1/orgs",
      "repos_url": "https://api.github.com/users/Tux1/repos",
      "events_url": "https://api.github.com/users/Tux1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Tux1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-09T06:04:08Z",
    "updated_at": "2015-12-09T06:04:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes of course, I understand better. Thank you\n\nOn mer., déc. 9, 2015 at 6:30 AM, pydata/pandas\nreply@reply.github.com\nwrote:\n@Tux1 [https://github.com/Tux1] numpy/numpy/core/src/umath/umathmodule.c\nI don't think it has much to do with how numpy implements rich comparison for anything, tho. You only need to know that float64('nan') != float64('nan') , which as @TomAugspurger [https://github.com/TomAugspurger] said works just like the standard library float('nan') . The reason np.nan seems to behave differently in dict is because it is the same object inside numpy that is being referred to, just like the global singletons ( None , ... , etc.) in python. If you do yourmodule.nan = float64('nan') and use yourmodule.nan whenever you need a nan , then you get the behavior of numpy 's nan .\n\n—\nReply to this email directly or view it on GitHub\n[https://github.com/pydata/pandas/issues/11797#issuecomment-163115468] .[https://github.com/notifications/beacon/AGWku8LcPCt7hGbsamL6igH_v_mh6a92ks5pN7QLgaJpZM4GxUVg.gif]\n"
  }
]
