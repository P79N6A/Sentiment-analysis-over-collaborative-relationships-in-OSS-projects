[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300457798",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300457798",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300457798,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDQ1Nzc5OA==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-10T11:47:28Z",
    "updated_at": "2017-05-10T11:47:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "can't u change the post to show code that constructs a minimal example\r\npictures are not very useful "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300544957",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300544957",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300544957,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDU0NDk1Nw==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-10T16:52:54Z",
    "updated_at": "2017-05-10T16:57:30Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback \r\n\r\n### Make your dataframe\r\n\r\n\r\n```\r\nx = pd.DataFrame(['a'], columns=['col'], index=pd.IntervalIndex.from_tuples([(1, 5)], closed='both'))\r\n```\r\n### Test all these:\r\n\r\n```\r\nx.loc[pd.Interval(1,5)]\r\nx.loc[pd.Interval(-10,10)]\r\nx.loc[pd.Interval(3,5)]\r\nx.loc[pd.Interval(3,4)]\r\nx.loc[pd.Interval(2,4)]\r\nx.loc[pd.Interval(1,4)]\r\n```\r\n\r\nI think that documentation as to what the behavior should be might be helpful. I can't make heads nor tails of what `loc` thinks it should do in this case, so I can't even tell if this is a bug. \r\n\r\nP.S. Still curious as to how you would address my meta-question about `find_intersections`...\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300943063",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300943063",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300943063,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDk0MzA2Mw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-11T23:24:47Z",
    "updated_at": "2017-05-11T23:24:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "well docs are here: http://pandas.pydata.org/pandas-docs/stable/advanced.html#intervalindex\r\n\r\nWell we treat indexing *with* an ``Interval`` as an exact match, if its there exactly it matches, otherwise you get a ``KeyError``. Its a a point it can be contained in an interval. Some of this is probably buggy because we didn't have any real examples\r\n\r\nwhat would be helpful is using this example:\r\n\r\n```\r\nIn [26]: df = pd.DataFrame(['a', 'b'], columns=['col'], index=pd.IntervalIndex.from_tuples([(1, 5), (7, 8)]))\r\n\r\nIn [27]: df\r\nOut[27]: \r\n       col\r\n(1, 5]   a\r\n(7, 8]   b\r\n```\r\nis to enumerate what those cases about should do semantically. Further having selections like ``df.loc[3]``. And further still what\r\n``df.loc[pd.Interval(4,7.5)]`` would do.\r\n\r\nwould be really helpful."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300943203",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300943203",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300943203,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDk0MzIwMw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-11T23:25:54Z",
    "updated_at": "2017-05-11T23:25:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "further I still don't understand what you need from ``find_intersection`` a complete example would be helpful. IOW, you have 2 frames as input (show the code) and what you think the output should be."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300945092",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300945092",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300945092,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDk0NTA5Mg==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-11T23:39:15Z",
    "updated_at": "2017-05-11T23:40:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback \r\n\r\nSorry, let me include the output from those `.loc`s and explain why I think they might be buggy, to help clarify. \r\n```\r\nx = pd.DataFrame(['a'], columns=['col'], index=pd.IntervalIndex.from_tuples([(1, 5)], closed='both'))\r\n```\r\nIntuitively, I want to say that 'a' is from 1 to 5, closed interval. All good here. \r\n```\r\nx.loc[pd.Interval(1,5)]\r\n```\r\n\"Do I have any intervals from 1 to 5?\" Yes. No surprise\r\n```\r\nx.loc[pd.Interval(-10,10)]\r\n```\r\nDo I have any intervals from -10 to 10? Yes. Oh, okay, so it's not exact matches. Okay. \r\n```\r\nx.loc[pd.Interval(3,5)]\r\n```\r\nDo I have any intervals from 3 to 5? Yes. Okay, that makes sense, it's a partial overlap with [1,5].\r\n```\r\nx.loc[pd.Interval(3,4)]\r\n```\r\nDo I have any intervals from 3 to 4? `KeyError` Wait what? \r\n```\r\nx.loc[pd.Interval(2,4)]   # KeyError\r\nx.loc[pd.Interval(1,4)]   # KeyError\r\n```\r\n\r\nI think this qualifies as \"Confusing (possibly buggy) IntervalIndex behavior\" but it might not -- I might just be thinking about this incorrectly. I'm happy to supplement the docs to clarify for people like me if that's the case. \r\n\r\nThanks!\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300949407",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300949407",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300949407,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDk0OTQwNw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T00:10:04Z",
    "updated_at": "2017-05-12T00:10:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "was looking for more discussion of whether an Interval needs to be an exact match, or matches if other intervals are fully contained\r\n\r\nwhat happens if it partially overlaps?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300950601",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300950601",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300950601,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDk1MDYwMQ==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T00:19:09Z",
    "updated_at": "2017-05-12T00:19:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback  I think I might see the footprint of the bug. New dataframe: (same as before, just from 10 to 15)\r\n\r\n```\r\nx = pd.DataFrame(['a'], columns=['col'], index=pd.IntervalIndex.from_tuples([(10, 15)], closed='both'))\r\n\r\nx.loc[pd.Interval(9,15)]  # works. \r\n\r\nx.loc[pd.Interval(10,15)]  # works. \r\n\r\nx.loc[pd.Interval(11,15)]  # works. \r\n\r\nx.loc[pd.Interval(9,16)]  # works. \r\n\r\nx.loc[pd.Interval(10,16)]  # works. \r\n\r\nx.loc[pd.Interval(11,16)]  # works.\r\n\r\nx.loc[pd.Interval(9,14)]  # fails. \r\n\r\nx.loc[pd.Interval(10,14)]  # fails. \r\n\r\nx.loc[pd.Interval(11,14)]  # fails.\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/300950970",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-300950970",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 300950970,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMDk1MDk3MA==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T00:21:53Z",
    "updated_at": "2017-05-12T00:21:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "So: \r\n\r\n|   |   |   |\r\n|---|---|---|\r\n| x.loc[pd.Interval(9,14)]  # fails. | x.loc[pd.Interval(10,14)]  # fails.  | x.loc[pd.Interval(11,14)]  # fails.  |\r\n| x.loc[pd.Interval(9,15)]  # works. | x.loc[pd.Interval(10,15)]  # true interval.  | x.loc[pd.Interval(11,15)]  # works.  |\r\n| x.loc[pd.Interval(9,16)]  # works. | x.loc[pd.Interval(10,16)]  # works.  | x.loc[pd.Interval(11,16)]  # works.  |"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301040456",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301040456",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301040456,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTA0MDQ1Ng==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T10:19:26Z",
    "updated_at": "2017-05-12T10:21:15Z",
    "author_association": "CONTRIBUTOR",
    "body": "@zfrenchee I have enough examples, what I want to know is *why* you think this should work at all.\r\n\r\n```\r\nIn [27]: df = pd.DataFrame(['a'], columns=['col'], \r\n          index=pd.IntervalIndex.from_tuples([(10, 15)], closed='both'))\r\n\r\nIn [28]: df\r\nOut[28]: \r\n         col\r\n[10, 15]   a\r\n```\r\n\r\nIOW, take cases and comment on if they should work or raise (KeyError or other)\r\n- ``df.loc[pd.Interval(10,15, closed='both')]`` \r\n- ``df.loc[pd.Interval(10, 15, closed='right')]``\r\n- ``df.loc[pd.Interval(11, 14)]``\r\n- ``df.loc[pd.Interval(11, 16)]``\r\n- ``df.loc[[pd.Interval(11, 13):pd.Interval(14, 15)]]``\r\n- ``df.loc[[pd.Interval(11, 13), pd.Interval(14, 15)]]``\r\n- ``df.loc[12]``\r\n- ``df.loc[9]``\r\n- ``df.loc[9, 12]``\r\n- ``df.loc[11:13]``\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301137309",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301137309",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301137309,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTEzNzMwOQ==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T17:27:25Z",
    "updated_at": "2017-05-12T17:30:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think there are two behaviors for `loc` which I think would make sense: exact match, or any overlap.\r\n\r\nSo reasonable behavior 1 is: \r\n\r\n```\r\ndf = pd.DataFrame(['a'], columns=['col'], \r\n          index=pd.IntervalIndex.from_tuples([(10, 15)], closed='both'))\r\n\r\ndf.loc[pd.Interval(10,15, closed='both')]      # the only one that succeeds\r\ndf.loc[pd.Interval(10, 15, closed='right')]     # KeyError\r\ndf.loc[pd.Interval(11, 14)]     # KeyError\r\ndf.loc[pd.Interval(11, 16)]     # KeyError\r\ndf.loc[[pd.Interval(11, 13):pd.Interval(14, 15)]]     # KeyError\r\ndf.loc[[pd.Interval(11, 13), pd.Interval(14, 15)]]     # KeyError\r\ndf.loc[12]     # KeyError\r\ndf.loc[9]     # KeyError\r\ndf.loc[9, 12]     # KeyError\r\ndf.loc[11:13]     # KeyError\r\n```\r\n\r\nAs a non-pandas expert, I *believe* this is most in keeping with what loc currently does on other index types, but I think this also obliterates the reason for having intervals, since you've essentially reduced the interval down to a token which you're selecting for. \r\n\r\nThe other possible behavior is that loc returns all overlaps: \r\n\r\n```\r\ndf = pd.DataFrame(['a'], columns=['col'], \r\n          index=pd.IntervalIndex.from_tuples([(10, 15)], closed='both'))\r\n\r\ndf.loc[pd.Interval(10,15, closed='both')]      # a\r\ndf.loc[pd.Interval(10, 15, closed='right')]      # a\r\ndf.loc[pd.Interval(11, 14)]      # a\r\ndf.loc[pd.Interval(11, 16)]      # a\r\ndf.loc[[pd.Interval(11, 13):pd.Interval(14, 15)]]      # a, though I'm not totally sure what the semantics of this query are. \r\ndf.loc[[pd.Interval(11, 13), pd.Interval(14, 15)]]      # a\r\ndf.loc[12]      # a\r\ndf.loc[9]     # None, because if this returned a KeyError the next case would be really hard.\r\ndf.loc[9, 12]      # a\r\ndf.loc[11:13]      # a\r\n```\r\n\r\nI *think* what makes most sense is to use loc for the first of these, and define a new special `overlap` function to implement the second of these, which would have a signature like so: \r\n\r\n```\r\npd.IntervalIndex().overlaps(other_intervalindex_or_dataframe_with_intervalIndex)\r\n```\r\nor more likely:\r\n```\r\ndataframe_with_intervalindex.index.overlaps(other_intervalindex_or_dataframe_with_intervalIndex)\r\n```\r\n\r\nThis would return something sensible, like the indices from `dataframe_with_intervalindex` which overlap intervals in `other_intervalindex_or_dataframe_with_intervalIndex`. Actually returning the values from both should be left to `merge(left_index=True, right_index=True)`\r\n\r\nMaybe it would be easier to define overlaps like so: \r\n```\r\npd.overlaps(intervalIndex1, intervalindex2)\r\n```\r\nIn that case it's a little harder to decide what to return, since you would want it to return the same thing as: \r\n```\r\npd.overlaps(intervalIndex2, intervalindex1)\r\n```\r\nWhat do you think? @jreback \r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301152498",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301152498",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301152498,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTE1MjQ5OA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T18:31:16Z",
    "updated_at": "2017-05-12T18:33:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "> As a non-pandas expert, I believe this is most in keeping with what loc currently does on other index types\r\n\r\nThe closest analogy here is probably partial string indexing into Datetimes. We accept `.loc['2017']` rather than `.loc[pd.Timestamp(2017, ...)]`. Stretching the analogy a bit further then, `.loc` should be \"exact\" when passed `Intervals`, and \"non-exact\" when passed the elements making up the Intervals (ints, strs, whatever). So these both return the same (which is what happens currently)\r\n\r\n```python\r\n\r\nIn [83]: df = pd.DataFrame(['a', 'b'], columns=['col'], index=pd.IntervalIndex.from_tuples([(1, 5), (7, 8)]))\r\n    ...: df\r\n    ...:\r\nOut[83]:\r\n       col\r\n(1, 5]   a\r\n(7, 8]   b\r\n\r\nIn [61]: df.loc[pd.Interval(1, 5)]\r\nOut[61]:\r\ncol    a\r\nName: (1, 5], dtype: object\r\n\r\nIn [62]: df.loc[3]\r\nOut[62]:\r\ncol    a\r\nName: (1, 5], dtype: object```\r\n```\r\n\r\nbut, then\r\n\r\n```python\r\nIn [50]: df.loc[pd.Interval(1, 4)]\r\n```\r\n\r\nwould raise a KeyError, since it doesn't match exactly.\r\n\r\nUsers wishing to do indexing by passing an `IntervalIndex` should use boolean indexing, and use some methods on `Intervalndex` to assist\r\n\r\nFor more flexible indexing with iterables of `Intervals`, I propose we enhance `IntervalIndex.contains` (or maybe a new method) to accept an Iterable `other` and return an Iterable[bool] of the same length.\r\n\r\n```python\r\n\r\ndef IntervalIndex.covers(self, other: Iterable) -> Array[bool]:\r\n    \"\"\"Boolean mask for whether items of `other` overlap with anything `self`.\r\n    Output is the same same shape as `other`\"\"\"\r\n    # maybe enhance `.contains` to do this?\r\n\r\ndef IntervalIndex.covered_by(self, other: Iterable) -> Array[Bool]:\r\n    \"\"\"Boolean mask for whether items in self overlap with anything in `other`.\r\n    Output is the same shape as `self`\"\"\"\r\n    # maybe modify `.isin` to do this?\r\n```\r\n\r\n---\r\n\r\nSo to summarize:\r\n\r\n- `df.loc` with scalars or lists of *non*Intervals we match wherever it's covered by `df.index`\r\n- `df.loc` with scalar Intervals a list / IntervalIndex of Intervals will match only *exactly*\r\n- Users should use `df[df.index.covers(values)]` for non-strict matching with iterables of Intervals"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301156239",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301156239",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301156239,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTE1NjIzOQ==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-12T18:47:46Z",
    "updated_at": "2017-05-12T18:47:46Z",
    "author_association": "MEMBER",
    "body": "> So to summarize:\r\n> df.loc with scalars or lists of nonIntervals we match wherever it's covered by df.index\r\n> df.loc with scalar Intervals a list / IntervalIndex of Intervals will match only exactly\r\n> Users should use df[df.index.covers(values)] for non-strict matching with iterables of Intervals\r\n\r\nThis sounds good to me!\r\n\r\nI think the original intent was to match fully contained intervals only, but clearly that logic is not working right. In any case it's certainly better (simpler / more explicit) to switch to requiring specific methods for this functionality. It seems like we need may need at least three methods for handling `IntervalIndex`/`IntervalIndex` matches, e.g., `IntervalIndex.covers`, `IntervalIndex.covered_by` and `IntervalIndex.overlaps`. Possibly worth adding these methods to `Interval`, too (at least `Interval.overlaps()`."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301252444",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301252444",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301252444,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI1MjQ0NA==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T14:40:17Z",
    "updated_at": "2017-05-13T14:40:17Z",
    "author_association": "CONTRIBUTOR",
    "body": "@TomAugspurger \r\n\r\nI think your ideas represent a good compromise. A couple concerns though:\r\n\r\n>  (which is what happens currently)\r\n\r\n- The current behavior is definitely wrong with respect to what you suggest it should be, so this isn't quite right. Do you agree? \r\n\r\n- I'm not sure whether we need both `covers` and `covered_by` given that they seem to be perfect opposites? `a.covers(b) == b.covered_by(a)` right? In which case you can just flip the expression and don't need both. Let me know if I'm misreading this. "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301254372",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301254372",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301254372,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI1NDM3Mg==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T15:13:22Z",
    "updated_at": "2017-05-13T15:13:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "I could have been wrong about the current behavior. I didn't test that much.\n\nFor the second point, we might want both methods as a convenience for if you have a list of Intervals, rather than an IntervalIndex. I think your right that they are perfect opposites (and we could implement it that way)\n\n> On May 13, 2017, at 9:40 AM, Alexander Lenail <notifications@github.com> wrote:\n> \n> @TomAugspurger\n> \n> I think your ideas represent a good compromise. A couple concerns though:\n> \n> (which is what happens currently)\n> \n> The current behavior is definitely wrong with respect to what you suggest it should be, so this isn't quite right. Do you agree?\n> \n> I'm not sure whether we need both covers and covered_by given that they seem to be perfect opposites? a.covers(b) == b.covered_by(a) right? In which case you can just flip the expression and don't need both. Let me know if I'm misreading this.\n> \n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or mute the thread.\n> \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301259860",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301259860",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301259860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI1OTg2MA==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T16:45:58Z",
    "updated_at": "2017-05-13T16:45:58Z",
    "author_association": "MEMBER",
    "body": "> I'm not sure whether we need both covers and covered_by given that they seem to be perfect opposites? a.covers(b) == b.covered_by(a) right? In which case you can just flip the expression and don't need both. Let me know if I'm misreading this.\r\n\r\nThis depends on how we represent the results of `covers`. If we represent it as a list of tuples (equivalently a MultiIndex with two levels) giving indices of \"all matches\" of intervals, we can return all matching intervals in a symmetric way, e.g.,\r\n```\r\n[[0, 2), [2, 3)].covers([[0, 1), [1, 2), [2, 3)])\r\n-> [(0, 0), (0, 1), (1, 2)]\r\n```\r\nIn this model, `len(a.covers(b)) == len([ai.covers(bi) for ai in a for bi in a]) <= len(a) * len(b)`.\r\n\r\nI think the full \"all matches\" methods could be useful, but for large lists of intervals these will get very long, so there is also something to be said for \"any match\" methods. These would return at most one result for each element in the first IntervalIndex, i.e.,\r\n```\r\n[[0, 2), [2, 3)].covers([[0, 1), [1, 2), [2, 3)])\r\n-> [(0, 0), (1, 2)]\r\n```\r\nOr possibly just 1D integer arrays of indices or a boolean array (giving matches in the first argument), but either way `len(a.covers(b)) <= len(a)`. In this model, we need separate methods.\r\n\r\nSo I guess this leaves us with up to 5 potential interval indexing methods, which we might call:\r\n- `covers_matches()` and `overlap_matches()`: these return a pair of integer arrays.\r\n- `covers_any()`, `covered_by_any()` and `overlaps_any()`: these return 1D boolean arrays.\r\n\r\nIf we do indeed add all of the second type of methods, we might do `covered_by_matches()` for symmetry, even though it's the same as `covers_matches()` with the arguments flipped."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301265137",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301265137",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301265137,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI2NTEzNw==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T18:14:35Z",
    "updated_at": "2017-05-13T18:18:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "@shoyer I have a hard time seeing why you would design the `covers` function in your first example the way you do -- when would someone not want the data at those indices (i.e. the overlapping data)? I think users will almost invariably want to \"dereference\" those indices right away, which seems like it might be a little tricky given the return format of tuples. I can't think of a use case, but if you can, I'm open to this idea. If such a use case exists where you would want the indices but not the data at those indices, perhaps it makes sense to include another function which does the \"dereferencing\" which depends on this function you've proposed (or at least post a recipe in the docs of this function)...\r\n\r\nI'm also not sure who would need \"any match\" who wouldn't want \"all match\" but I'm more open to this idea. I can't think of utility to it, but it seems very plausible there's some use case I'm not thinking of.\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301269724",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301269724",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301269724,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI2OTcyNA==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T19:28:07Z",
    "updated_at": "2017-05-13T19:28:07Z",
    "author_association": "MEMBER",
    "body": "> I have a hard time seeing why you would design the covers function in your first example the way you do -- when would someone not want the data at those indices (i.e. the overlapping data)?\r\n\r\nThis needs to be an `IntervalIndex` method, so it doesn't have access to the data. That said, I agree that returning a pair of integer arrays giving indices is a better return format than a list of tuples (which is why I suggested it above for `covers_matches()` and `covers_by_matches()`)."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301270935",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301270935",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301270935,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI3MDkzNQ==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T19:51:49Z",
    "updated_at": "2017-05-13T20:14:04Z",
    "author_association": "MEMBER",
    "body": "> I'm also not sure who would need \"any match\" who wouldn't want \"all match\" but I'm more open to this idea.\r\n\r\nI'm also not sure if this would actually be useful to anyone -- I was merely restating  @TomAugspurger's proposal. If we can't think of a real use-case, then we certainly shouldn't bother.\r\n\r\nIt sounds like we want two methods `covers` and `overlaps`, for both `Interval` and `IntervalIndex`. We could potentially update `IntervalIndex.contains` as well, but frankly I'm not sure why that method even exists given that it's currently an exact alias of `IntervalIndex.__contains__`.\r\n\r\nThese would have type signatures (slightly abusing standard typing notation):\r\n```\r\nclass Interval:\r\n    def covers(self, other: Interval) -> bool\r\n    def covers(self, other: IntervalIndex) -> IntegerArray1D\r\n    def overlaps(self, other: Interval) -> bool\r\n    def overlaps(self, other: IntervalIndex) -> IntegerArray1D\r\n\r\nclass IntervalIndex:\r\n    def covers(self, other: Interval) -> IntegerArray1D\r\n    def covers(self, other: IntervalIndex) -> Tuple[IntegerArray1D, IntegerArray1D]\r\n    def overlaps(self, other: Interval) -> IntegerArray1D\r\n    def overlaps(self, other: IntervalIndex) -> Tuple[IntegerArray1D, IntegerArray1D]\r\n```"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301274843",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301274843",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301274843,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTI3NDg0Mw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-13T21:06:59Z",
    "updated_at": "2017-05-13T21:06:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "@shoyer \r\n\r\n> We could potentially update IntervalIndex.contains as well, but frankly I'm not sure why that method even exists given that it's currently an exact alias of IntervalIndex.__contains__.\r\n\r\nIIRC you suggested this actually. And the are *not* duplicates of each other. ``.contains()`` allows integers, which ``__contains__`` is an exact method (meant to implent ``pd.Interval(...) in interval_index``\r\n\r\n``.contains()`` is called in ``.loc`` indexing, so it pretty convenient.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301325576",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301325576",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301325576,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTMyNTU3Ng==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-14T17:02:44Z",
    "updated_at": "2017-05-14T17:02:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "@shoyer sorry I might have lost track -- could you re-disambiguate what `covers` and `overlaps` each do in the proposed function signatures you posted above? `overlaps` is \"all overlaps\" and `covers` is \"any overlaps\"? "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/301352130",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-301352130",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 301352130,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMTM1MjEzMA==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-15T00:48:38Z",
    "updated_at": "2017-05-15T00:48:38Z",
    "author_association": "MEMBER",
    "body": "> could you re-disambiguate what covers and overlaps each do in the proposed function signatures you posted above? overlaps is \"all overlaps\" and covers is \"any overlaps\"?\r\n\r\nAn interval covers another interval if all points in the second interval are found in the first interval.\r\n\r\nAn interval overlaps another interval if there exist any points found in both intervals.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302290463",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302290463",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302290463,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjI5MDQ2Mw==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T03:27:16Z",
    "updated_at": "2017-05-18T03:27:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback @shoyer What would be the timeline for implementing something like this? How would this come about? "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302363048",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302363048",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302363048,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjM2MzA0OA==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T10:17:14Z",
    "updated_at": "2017-05-18T10:17:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "@zfrenchee the way to make this happen MUCH faster would be to write tests, that xfail. meaning that we except them to work when the feature is fixed. Many many tests would help here, covering the bases, and edge cases. This would cover the user facing results, e.g. what you expect for a certain operation. Much of the raw input is in this issue. This would also help refine the exact API.\r\n\r\n\r\n```\r\ndiff --git a/pandas/tests/indexing/test_interval.py b/pandas/tests/indexing/test_interval.py\r\nindex 2552fc0..5c0922c 100644\r\n--- a/pandas/tests/indexing/test_interval.py\r\n+++ b/pandas/tests/indexing/test_interval.py\r\n@@ -11,6 +11,18 @@ class TestIntervalIndex(object):\r\n     def setup_method(self, method):\r\n         self.s = Series(np.arange(5), IntervalIndex.from_breaks(np.arange(6)))\r\n \r\n+    @pytest.mark.xfail(reason=\"new indexing tests for issue 16316\")\r\n+    def test_add_cool_new_things(self):\r\n+\r\n+        s = Series(np.arange(2), IntervalIndex.from_tuples([(0, 1), (2, 3)]))\r\n+        result = s.loc[0.5]\r\n+        expected = 0\r\n+        assert result == expected\r\n+\r\n+        result = s.loc[2.5]\r\n+        expected = 1\r\n+        assert result == expected\r\n+\r\n     def test_loc_with_scalar(self):\r\n \r\n         s = self.s\r\n```"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302476924",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302476924",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302476924,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjQ3NjkyNA==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T17:10:43Z",
    "updated_at": "2017-05-18T17:10:43Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback Sounds good, I'm happy to write the tests. One question though: We've discussed both enhancements on this issue, as well as ways the current implementation is \"broken\". I'll add xfail tests for the enhancements, but should I alter current tests to bring them into line with what we've discussed here. If so, should I also mark them as xfail? "
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302477692",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302477692",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302477692,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjQ3NzY5Mg==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T17:12:38Z",
    "updated_at": "2017-05-18T17:12:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "yes\r\nbest to move 'wrong' test to another function and xfail them"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302481673",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302481673",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302481673,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjQ4MTY3Mw==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T17:22:25Z",
    "updated_at": "2017-05-18T17:22:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback would you mind chatting about this over email? I have a couple more questions which don't necessarily make sense to put on this issue. If that's alright, shoot me an email at lenail@mit.edu. =)"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302499018",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302499018",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302499018,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjQ5OTAxOA==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T18:19:52Z",
    "updated_at": "2017-05-18T18:19:52Z",
    "author_association": "MEMBER",
    "body": "If you have developer workflow questions, GitHub is still a good place for\nthem -- we can answer questions or point you to existing primers. It's okay\nif issues go slightly off topic.\nOn Thu, May 18, 2017 at 1:22 PM Alexander Lenail <notifications@github.com>\nwrote:\n\n> @jreback <https://github.com/jreback> would you mind chatting about this\n> over email? I have a couple more questions which don't necessarily make\n> sense to put on this issue. If that's alright, shoot me an email at\n> lenail@mit.edu. =)\n>\n> —\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302481673>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABKS1gT81WLgNG5yDTiFGdnqwmNUn_1Zks5r7H5VgaJpZM4NWGbI>\n> .\n>\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302521980",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302521980",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302521980,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjUyMTk4MA==",
    "user": {
      "login": "zfrenchee",
      "id": 2761597,
      "node_id": "MDQ6VXNlcjI3NjE1OTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2761597?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/zfrenchee",
      "html_url": "https://github.com/zfrenchee",
      "followers_url": "https://api.github.com/users/zfrenchee/followers",
      "following_url": "https://api.github.com/users/zfrenchee/following{/other_user}",
      "gists_url": "https://api.github.com/users/zfrenchee/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/zfrenchee/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/zfrenchee/subscriptions",
      "organizations_url": "https://api.github.com/users/zfrenchee/orgs",
      "repos_url": "https://api.github.com/users/zfrenchee/repos",
      "events_url": "https://api.github.com/users/zfrenchee/events{/privacy}",
      "received_events_url": "https://api.github.com/users/zfrenchee/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T19:49:19Z",
    "updated_at": "2017-05-18T19:49:19Z",
    "author_association": "CONTRIBUTOR",
    "body": "Alright. \r\n\r\n1. In `pandas/pandas/tests/indexing/test_interval.py` -- will we need to change `test_contains` ?\r\n\r\n2. There are still a bunch of references to Panel in http://pandas.pydata.org/pandas-docs/stable/indexing.html. Should those be removed? \r\n\r\n3. https://github.com/pandas-dev/pandas/pull/16386"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302529561",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302529561",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302529561,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjUyOTU2MQ==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T20:19:08Z",
    "updated_at": "2017-05-18T20:19:08Z",
    "author_association": "CONTRIBUTOR",
    "body": "> In pandas/pandas/tests/indexing/test_interval.py -- will we need to change test_contains ?\r\n\r\nI don't think so, you can certain put what you think if its different\r\n\r\n> There are still a bunch of references to Panel in http://pandas.pydata.org/pandas-docs/stable/indexing.html. Should those be removed?\r\n\r\nno, things stay in the docs until things are actually removed for Panel, though would prob take a PR to remove them for 0.21.0\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/302565709",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16316#issuecomment-302565709",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16316",
    "id": 302565709,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwMjU2NTcwOQ==",
    "user": {
      "login": "buyology",
      "id": 5368302,
      "node_id": "MDQ6VXNlcjUzNjgzMDI=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/5368302?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/buyology",
      "html_url": "https://github.com/buyology",
      "followers_url": "https://api.github.com/users/buyology/followers",
      "following_url": "https://api.github.com/users/buyology/following{/other_user}",
      "gists_url": "https://api.github.com/users/buyology/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/buyology/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/buyology/subscriptions",
      "organizations_url": "https://api.github.com/users/buyology/orgs",
      "repos_url": "https://api.github.com/users/buyology/repos",
      "events_url": "https://api.github.com/users/buyology/events{/privacy}",
      "received_events_url": "https://api.github.com/users/buyology/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-05-18T23:10:02Z",
    "updated_at": "2017-05-18T23:10:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "chiming in on this, as we are heavy users of `postgres` [`range` types](https://www.postgresql.org/docs/9.6/static/rangetypes.html) and [`range` operators](https://www.postgresql.org/docs/9.6/static/functions-range.html) as a powerful abstraction for  time series data\r\n\r\nas already been mentioned, the key verbs are `contains` and `overlaps` both on element and range level and in both directions:\r\n\r\nexamples from the [postgres docs](https://www.postgresql.org/docs/9.6/static/functions-range.html):\r\n\r\n| Operator  | Description | Example | Result |\r\n| ------------- | ------------- | ------------- | ------------- |\r\n| @>  | contains range  | `int4range(2,4) @> int4range(2,3)` | t |\r\n| @>   | contains element  | `'[2011-01-01,2011-03-01)'::tsrange @> '2011-01-10'::timestamp` | t |\r\n| <@  | range is contained by  | `int4range(2,4) <@ int4range(1,7)` | t |\r\n| <@  | element is contained by  | `42 <@ int4range(1,7)` | f |\r\n| &&  | overlap (have points in common)  | `int8range(3,7) && int8range(4,12)` | t |\r\n| <<  | strictly left of  | `int8range(1,10) << int8range(100,110)` | t |\r\n| -\\|-  | is adjacent to | `numrange(1.1,2.2) -\\|- numrange(2.2,3.3)` | t |\r\n\r\nnow that we have `Interval`s in `pandas` (very grateful for bringing that feature @jreback!) I have already tinkered around with some mappers for going between `Postgres` and `pandas` — maybe that is too `db`-specific but def have a great interest in seeing more `Interval` type functionality in Pandas and helping out with this"
  }
]
