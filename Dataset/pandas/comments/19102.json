[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/355762490",
    "html_url": "https://github.com/pandas-dev/pandas/issues/19102#issuecomment-355762490",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/19102",
    "id": 355762490,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTc2MjQ5MA==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-06T17:38:02Z",
    "updated_at": "2018-01-06T17:38:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "I am not sure how you think the above would work. If you are filtering, then adding columns you need to copy. You can avoid the memory penalty by reassigning to the original variable which will have the original garbage collected. I actually doubt this is an issue in practice unless you are very nearly at memory limits in any event.\r\n```\r\nIn [2]: df = pd.DataFrame({'A':[1,2,3]})\r\n   ...: df = df[df.A>2].copy()\r\n   ...: df['B'] = 2\r\n```\r\n\r\nWe won't have copy-on-write in the current version of pandas, so this is an intractable problem. defensive copying is the solution, and to be honest its not a big deal to do this. Virtually every pandas operation copies anyhow."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/355769535",
    "html_url": "https://github.com/pandas-dev/pandas/issues/19102#issuecomment-355769535",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/19102",
    "id": 355769535,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTc2OTUzNQ==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-06T19:26:22Z",
    "updated_at": "2018-01-06T19:26:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "@has2k1  can you explain what this line is supposed to do?\r\n\r\n```python\r\ndf2 = df[df.A>2].as_copy()               # New method, as_copy\r\n```\r\n\r\nIs that supposed to copy if and only if the underlying data is a view, and not otherwise?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/355775807",
    "html_url": "https://github.com/pandas-dev/pandas/issues/19102#issuecomment-355775807",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/19102",
    "id": 355775807,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTc3NTgwNw==",
    "user": {
      "login": "has2k1",
      "id": 780341,
      "node_id": "MDQ6VXNlcjc4MDM0MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/780341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/has2k1",
      "html_url": "https://github.com/has2k1",
      "followers_url": "https://api.github.com/users/has2k1/followers",
      "following_url": "https://api.github.com/users/has2k1/following{/other_user}",
      "gists_url": "https://api.github.com/users/has2k1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/has2k1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/has2k1/subscriptions",
      "organizations_url": "https://api.github.com/users/has2k1/orgs",
      "repos_url": "https://api.github.com/users/has2k1/repos",
      "events_url": "https://api.github.com/users/has2k1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/has2k1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-06T20:53:47Z",
    "updated_at": "2018-01-06T20:53:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Is that supposed to copy if and only if the underlying data is a view, and not otherwise?\r\n\r\nYes"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/355779552",
    "html_url": "https://github.com/pandas-dev/pandas/issues/19102#issuecomment-355779552",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/19102",
    "id": 355779552,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTc3OTU1Mg==",
    "user": {
      "login": "has2k1",
      "id": 780341,
      "node_id": "MDQ6VXNlcjc4MDM0MQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/780341?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/has2k1",
      "html_url": "https://github.com/has2k1",
      "followers_url": "https://api.github.com/users/has2k1/followers",
      "following_url": "https://api.github.com/users/has2k1/following{/other_user}",
      "gists_url": "https://api.github.com/users/has2k1/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/has2k1/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/has2k1/subscriptions",
      "organizations_url": "https://api.github.com/users/has2k1/orgs",
      "repos_url": "https://api.github.com/users/has2k1/repos",
      "events_url": "https://api.github.com/users/has2k1/events{/privacy}",
      "received_events_url": "https://api.github.com/users/has2k1/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-06T21:36:55Z",
    "updated_at": "2018-01-06T21:36:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I actually doubt this is an issue in practice unless you are very nearly at memory limits in any event.\r\n\r\n> Virtually every pandas operation copies anyhow.\r\n\r\n@jreback , when there are 100s of operations that involve copying the penalty of an extra copy becomes significant. It even worthwhile to tease out the operations where the `inplace` argument actually avoids a copy e.g `reset_index`.\r\n\r\nAs the issue does not be a wider concern, I'll reevaluate the use patterns and maybe switch over to `_is_copy` until copy-on-write saves the day."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/355781964",
    "html_url": "https://github.com/pandas-dev/pandas/issues/19102#issuecomment-355781964",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/19102",
    "id": 355781964,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1NTc4MTk2NA==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-06T22:14:41Z",
    "updated_at": "2018-01-06T22:14:41Z",
    "author_association": "CONTRIBUTOR",
    "body": "@has2k1 I find it hard to believe that a plotting library is actually affected by copy operations. good luck."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/359356165",
    "html_url": "https://github.com/pandas-dev/pandas/issues/19102#issuecomment-359356165",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/19102",
    "id": 359356165,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1OTM1NjE2NQ==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-01-22T08:35:11Z",
    "updated_at": "2018-01-22T08:35:11Z",
    "author_association": "MEMBER",
    "body": "I don't think we should be so dismissive to the needs of other projects. A plotting library can certainly care about memory usage (plotnine *can* work with a lot of data, because it does not necessarily plot it all, but calculate statistics (eg hist, boxplot) for different factors. I can imagine in those operations you regularly need to subset a dataframe)\r\n\r\nWe have seen reports of IMO valid usecases in both plotnine and sklearn. IMO we should need to think about *some* way to give such power users a means to deal with this. "
  }
]
