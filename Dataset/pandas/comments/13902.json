[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/237580526",
    "html_url": "https://github.com/pandas-dev/pandas/issues/13902#issuecomment-237580526",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/13902",
    "id": 237580526,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNzU4MDUyNg==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-04T15:01:28Z",
    "updated_at": "2016-08-04T15:01:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "so you don't actually need tempita here. you factorize things, and so only need to deal with int64's.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/237581675",
    "html_url": "https://github.com/pandas-dev/pandas/issues/13902#issuecomment-237581675",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/13902",
    "id": 237581675,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNzU4MTY3NQ==",
    "user": {
      "login": "chrisaycock",
      "id": 453745,
      "node_id": "MDQ6VXNlcjQ1Mzc0NQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/453745?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chrisaycock",
      "html_url": "https://github.com/chrisaycock",
      "followers_url": "https://api.github.com/users/chrisaycock/followers",
      "following_url": "https://api.github.com/users/chrisaycock/following{/other_user}",
      "gists_url": "https://api.github.com/users/chrisaycock/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chrisaycock/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chrisaycock/subscriptions",
      "organizations_url": "https://api.github.com/users/chrisaycock/orgs",
      "repos_url": "https://api.github.com/users/chrisaycock/repos",
      "events_url": "https://api.github.com/users/chrisaycock/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chrisaycock/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-04T15:05:07Z",
    "updated_at": "2016-08-04T15:08:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jreback The single-pass nature of this is that I'm not doing the factorizing anymore. I'm comparing the values in the \"on\" column directly, which is fine since timestamps are stored as integers anyway. But if I ever want to compare floats, then I assume I'll need proper type differentiation.\n\nI've issued a PR for the sample code to show how I did it. As I describe at the top of message there, do not merge in its current state...\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/237590573",
    "html_url": "https://github.com/pandas-dev/pandas/issues/13902#issuecomment-237590573",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/13902",
    "id": 237590573,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNzU5MDU3Mw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-04T15:32:59Z",
    "updated_at": "2016-08-04T15:32:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "@chrisaycock you can use the groupby factorization (its quite cheap to do this)\n\n```\nIn [5]: df = pd.DataFrame({'A' : pd.date_range('20130101',periods=3), 'B' : list('aab'), 'C' : range(3)})\n\nIn [6]: g = df.groupby(['A', 'B'])\n\nIn [7]: g.grouper.group_info\nOut[7]: (array([0, 1, 2], dtype=int64), array([0, 2, 5], dtype=int64), 3)\n```\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/237612299",
    "html_url": "https://github.com/pandas-dev/pandas/issues/13902#issuecomment-237612299",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/13902",
    "id": 237612299,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIzNzYxMjI5OQ==",
    "user": {
      "login": "chrisaycock",
      "id": 453745,
      "node_id": "MDQ6VXNlcjQ1Mzc0NQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/453745?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/chrisaycock",
      "html_url": "https://github.com/chrisaycock",
      "followers_url": "https://api.github.com/users/chrisaycock/followers",
      "following_url": "https://api.github.com/users/chrisaycock/following{/other_user}",
      "gists_url": "https://api.github.com/users/chrisaycock/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/chrisaycock/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/chrisaycock/subscriptions",
      "organizations_url": "https://api.github.com/users/chrisaycock/orgs",
      "repos_url": "https://api.github.com/users/chrisaycock/repos",
      "events_url": "https://api.github.com/users/chrisaycock/events{/privacy}",
      "received_events_url": "https://api.github.com/users/chrisaycock/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-08-04T16:46:24Z",
    "updated_at": "2016-08-04T16:46:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "Using the setup from the `join_merge.merge_asof_by` benchmark:\n\n```\nIn [39]: %timeit pd.merge_asof(df1, df2, on='time', by='key')\n10 loops, best of 3: 41.4 ms per loop\n```\n\nBut the factorization takes way longer than that and we haven't even gotten to the actual joining logic:\n\n```\nIn [40]: %timeit df1.groupby(['key', 'time']).grouper.group_info\n10 loops, best of 3: 28.2 ms per loop\n\nIn [41]: %timeit df2.groupby(['key', 'time']).grouper.group_info\n10 loops, best of 3: 177 ms per loop\n```\n\nThe fastest possible approach is a single-pass algorithm. (And if we want this function to be remotely competitive with q/kdb+'s `aj[]`, then we need to pay attention to performance.)\n"
  }
]
