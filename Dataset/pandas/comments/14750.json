[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263158380",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263158380",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263158380,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzE1ODM4MA==",
    "user": {
      "login": "sinhrks",
      "id": 1696302,
      "node_id": "MDQ6VXNlcjE2OTYzMDI=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1696302?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sinhrks",
      "html_url": "https://github.com/sinhrks",
      "followers_url": "https://api.github.com/users/sinhrks/followers",
      "following_url": "https://api.github.com/users/sinhrks/following{/other_user}",
      "gists_url": "https://api.github.com/users/sinhrks/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sinhrks/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sinhrks/subscriptions",
      "organizations_url": "https://api.github.com/users/sinhrks/orgs",
      "repos_url": "https://api.github.com/users/sinhrks/repos",
      "events_url": "https://api.github.com/users/sinhrks/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sinhrks/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T00:11:30Z",
    "updated_at": "2016-11-28T00:11:30Z",
    "author_association": "MEMBER",
    "body": "Yeah, needs a logic to handle tuple contains boolean array-likes.\r\n\r\n```\r\ndf.loc[(['foo'], slice(None)), :]\r\n#                      0         1\r\n# first second\r\n# foo   a      -0.168657 -0.495094\r\n#       b       0.396207 -1.310770\r\n\r\ndf.loc[([True, False], slice(None)), :]\r\n# ValueError: cannot index with a boolean indexer that is not the same length as t\r\nhe index\r\n```"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263216074",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263216074",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263216074,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzIxNjA3NA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T08:58:05Z",
    "updated_at": "2016-11-28T08:58:05Z",
    "author_association": "MEMBER",
    "body": "@sinhrks Note that in the original example a *Series* was used, not a plain list. As for a boolean list, the above is correct: it should have the same length. It is only when having a boolean Series, that the Series is aligned before indexing."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263259946",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263259946",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263259946,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzI1OTk0Ng==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T12:32:26Z",
    "updated_at": "2016-11-28T12:32:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "This would be a major API change, and I don't even think this is possible, meaning that this could lead to ambiguous circumstances. Further this is not all all convenient; constructing a boolean index that is exactly equal to the length of THAT particular level is obvious. The use case generally is this:\r\n\r\n```\r\nIn [17]: df.loc[(df[0]>0, slice(None)), :]\r\nOut[17]:\r\n                     0         1\r\nfirst second\r\nbar   a       0.357749  1.191444\r\nfoo   a       0.334568  0.979802\r\n      b       0.188320  0.085018\r\n```\r\n\r\n@lightcatcher can you show a usecase where this is actually useful? (pre-constructing a boolean index the same lenght as THAT level).\r\n\r\nI keep emphasizing THAT level, because in this case the levels are the same length (2) and easy enough. But most multi-indexes are not like that. The levels are different and usually bigger."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263294090",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263294090",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263294090,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzI5NDA5MA==",
    "user": {
      "login": "eamartin",
      "id": 287200,
      "node_id": "MDQ6VXNlcjI4NzIwMA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/287200?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eamartin",
      "html_url": "https://github.com/eamartin",
      "followers_url": "https://api.github.com/users/eamartin/followers",
      "following_url": "https://api.github.com/users/eamartin/following{/other_user}",
      "gists_url": "https://api.github.com/users/eamartin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eamartin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eamartin/subscriptions",
      "organizations_url": "https://api.github.com/users/eamartin/orgs",
      "repos_url": "https://api.github.com/users/eamartin/repos",
      "events_url": "https://api.github.com/users/eamartin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eamartin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T15:05:27Z",
    "updated_at": "2016-11-28T16:46:40Z",
    "author_association": "NONE",
    "body": "I was attempting to do this type of indexing instead of a join. I had no reason to choose this over a join, it just came to mind first. A join seems like the more idiomatic way to go, but the support for single Index but not MultiIndex made me think it was worth opening an issue.\r\n\r\nExample usecase:\r\nI have dataframes ``foo``, ``bar``, and ``foobar``. ``foo`` has index ``foo_id``, ``bar`` has index ``bar_id``, and ``foobar`` has index ``(foo_id, bar_id)``.\r\nI want to select the rows of ``foobar`` that have a ``foo_id`` such that ``foo.loc[foo_id][col] > 0`` for a ``col`` that's stored on ``foo`` but not on ``foobar``.\r\nI attempted to do this with ``result = foobar.loc[(foo[col] > 0, slice(None)), :]``, and this lead to the error message. Notably, this would work if ``foobar``'s index was just ``foo_id`` rather than ``(foo_id, bar_id)``.\r\n\r\nI think the more standard way to do this computation is:\r\n```python\r\njoined = foobar.join(foo)\r\nresult = joined[joined[col] > 0][foobar.columns]\r\n```\r\n\r\nAlgorithmically (at least in this case), the unequal length series index lookup is equivalent to a join. Maybe the boolean indexing this issue is about can be viewed as sugar on top of a join with a boolean series?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263297118",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263297118",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263297118,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzI5NzExOA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T15:16:16Z",
    "updated_at": "2016-11-28T15:16:16Z",
    "author_association": "MEMBER",
    "body": "@lightcatcher trying to translate your indexing-approach to code that already works now:\r\n\r\n```\r\nIn [21]: bool_idx\r\nOut[21]: \r\nfoo     True\r\nbar    False\r\ndtype: bool\r\n\r\nIn [22]: bool_idx_aligned = bool_idx.reindex(df.index.get_level_values(0))\r\n\r\nIn [23]: bool_idx_aligned\r\nOut[23]: \r\nfirst\r\nbar    False\r\nbar    False\r\nfoo     True\r\nfoo     True\r\ndtype: bool\r\n\r\nIn [24]: df.loc[(bool_idx_aligned, slice(None)), :]\r\nOut[24]: \r\n                     0         1\r\nfirst second                    \r\nfoo   a       1.420829  0.464567\r\n      b      -0.393165 -0.166931\r\n```\r\n\r\nSo here I do the 'alignment' manually, so the passed indexer has the correct length and order. \r\nAnd I think your question is then if `df.loc[(bool_idx, slice(None), :]` should do such reindexing on the indexer automatically."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263300773",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263300773",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263300773,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzMwMDc3Mw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T15:29:09Z",
    "updated_at": "2016-11-28T15:29:09Z",
    "author_association": "CONTRIBUTOR",
    "body": "@jorisvandenbossche \r\n\r\nI was making the point of its harder to actually create the ``bool_idx`` in the first place. E.g. its *much* easier simply to use ``.isin()`` (or directly user the indexers, meaning what you want to select).\r\n\r\nI was trying to get *why* @lightcatcher created the ``bool_idx`` (other than to try things out). In the real world, you almost always programatically create a boolean indexer.\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263324827",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263324827",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263324827,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzMyNDgyNw==",
    "user": {
      "login": "eamartin",
      "id": 287200,
      "node_id": "MDQ6VXNlcjI4NzIwMA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/287200?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eamartin",
      "html_url": "https://github.com/eamartin",
      "followers_url": "https://api.github.com/users/eamartin/followers",
      "following_url": "https://api.github.com/users/eamartin/following{/other_user}",
      "gists_url": "https://api.github.com/users/eamartin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eamartin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eamartin/subscriptions",
      "organizations_url": "https://api.github.com/users/eamartin/orgs",
      "repos_url": "https://api.github.com/users/eamartin/repos",
      "events_url": "https://api.github.com/users/eamartin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eamartin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T16:50:05Z",
    "updated_at": "2016-11-28T16:50:05Z",
    "author_association": "NONE",
    "body": "@jorisvandenbossche \r\nThanks for the reindex example. \r\nThis issue is to decide \r\n(1) should ``df.loc[(bool_idx, slice(None), :]`` be supported when ``len(bool_idx) != len(df.index)`` and\r\n(2) if so how to implement it. It appears ``reindex`` is an option for (2).\r\n\r\n@jreback \r\nDo you understand where my initial example (with ``df`` and ``bool_idx``) came from? I submitted this as a reduced test case for the ``foo, bar, foobar`` dataframes problem I later described.\r\nIs using ``join`` the idiomatic way to do the ``foo, bar, foobar`` example?\r\nYou mentioned you think this is a major API change that could lead to ambiguities. Do these concerns apply if there's just a new step to reindex the boolean indexer to the appropriate multiindex level if needed?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263329238",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263329238",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263329238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzMyOTIzOA==",
    "user": {
      "login": "jorisvandenbossche",
      "id": 1020496,
      "node_id": "MDQ6VXNlcjEwMjA0OTY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1020496?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jorisvandenbossche",
      "html_url": "https://github.com/jorisvandenbossche",
      "followers_url": "https://api.github.com/users/jorisvandenbossche/followers",
      "following_url": "https://api.github.com/users/jorisvandenbossche/following{/other_user}",
      "gists_url": "https://api.github.com/users/jorisvandenbossche/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jorisvandenbossche/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jorisvandenbossche/subscriptions",
      "organizations_url": "https://api.github.com/users/jorisvandenbossche/orgs",
      "repos_url": "https://api.github.com/users/jorisvandenbossche/repos",
      "events_url": "https://api.github.com/users/jorisvandenbossche/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jorisvandenbossche/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T17:04:59Z",
    "updated_at": "2016-11-28T17:04:59Z",
    "author_association": "MEMBER",
    "body": "@jreback yes, I get that, and @lightcatcher explained why he has such a strange `bool_idx`, and I think it is a valid use case (which does not necessarily mean that I think enabling such automatic behaviour is a good idea, IMO it is too much magic).\r\n\r\nSo I am just looking for ways to do this indexing approach without running into the original reported error. Reindexing the indexer is one possibility (as show above), `isin` can indeed be another:\r\n\r\n```\r\nIn [32]: df.loc[df.index.get_level_values(0).isin(bool_idx.index[bool_idx])]\r\nOut[32]: \r\n                     0         1\r\nfirst second                    \r\nfoo   a       1.420829  0.464567\r\n      b      -0.393165 -0.166931\r\n```\r\n\r\n(the `bool_idx.index[bool_idx]` can of course be simplified if you have the underlying dataframe based on which this `bool_idx` is created)\r\n\r\n@lightcatcher I understand your expectation of something that is working on a single indexed also working on a multi-indexed frame. However, the alignment is something rather magical, and it is not clear that is should necessarily only align to the current index level, and not to the full multi-index. Therefore, I am not sure I am a fan of adding this functionality.\r\n\r\nIn any case, those situations where your boolean indexer is a Series with index deviating from the dataframe's index is rather underspecified and not documented well (also for a single level index). So this area can certainly be improved."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263336407",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263336407",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263336407,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzMzNjQwNw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T17:29:55Z",
    "updated_at": "2016-11-28T17:29:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "@lightcatcher I understand what you are trying to do.\r\n\r\nAs @jorisvandenbossche indicated, indexing is already quite complicated. This does not seem like a natural extension as its really very different that boolean slicing as it already exists.\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263338721",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263338721",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263338721,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzMzODcyMQ==",
    "user": {
      "login": "shoyer",
      "id": 1217238,
      "node_id": "MDQ6VXNlcjEyMTcyMzg=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1217238?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/shoyer",
      "html_url": "https://github.com/shoyer",
      "followers_url": "https://api.github.com/users/shoyer/followers",
      "following_url": "https://api.github.com/users/shoyer/following{/other_user}",
      "gists_url": "https://api.github.com/users/shoyer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/shoyer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/shoyer/subscriptions",
      "organizations_url": "https://api.github.com/users/shoyer/orgs",
      "repos_url": "https://api.github.com/users/shoyer/repos",
      "events_url": "https://api.github.com/users/shoyer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/shoyer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T17:38:14Z",
    "updated_at": "2016-11-28T17:38:14Z",
    "author_association": "MEMBER",
    "body": "@jreback writes:\r\n\r\n> The use case generally is this:\r\n```\r\nIn [17]: df.loc[(df[0]>0, slice(None)), :]\r\nOut[17]:\r\n                     0         1\r\nfirst second\r\nbar   a       0.357749  1.191444\r\nfoo   a       0.334568  0.979802\r\n      b       0.188320  0.085018\r\n```\r\n\r\nI am actually a surprised that even this works -- it is not at all obvious to me what it means to index a level of a MultiIndex with a boolean with length equal to the entire index. A less ambiguous way to write this would be `df.loc[df[0]>0, :]`.\r\n\r\nIn fact, if I had to guess at how `df.loc[(bool_array, slice(None)), :]` works, it seems at least as natural to use `bool_array` to index along `df.index.levels[0]`. Of course, this would still be confusing to many users (especially when not all levels are used in the actual index), so I don't really recommend it either.\r\n\r\nGiven the importance of preserving backwards compatibility, we shouldn't change this. But for pandas 2, I would consider making *all* attempts to index a level of a MultiIndex with a boolean raise an error."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263355923",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263355923",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263355923,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzM1NTkyMw==",
    "user": {
      "login": "eamartin",
      "id": 287200,
      "node_id": "MDQ6VXNlcjI4NzIwMA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/287200?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eamartin",
      "html_url": "https://github.com/eamartin",
      "followers_url": "https://api.github.com/users/eamartin/followers",
      "following_url": "https://api.github.com/users/eamartin/following{/other_user}",
      "gists_url": "https://api.github.com/users/eamartin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eamartin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eamartin/subscriptions",
      "organizations_url": "https://api.github.com/users/eamartin/orgs",
      "repos_url": "https://api.github.com/users/eamartin/repos",
      "events_url": "https://api.github.com/users/eamartin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eamartin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T18:42:16Z",
    "updated_at": "2016-11-28T18:42:16Z",
    "author_association": "NONE",
    "body": "@jorisvandenbossche Thanks for the explanation.\r\nYou said:\r\n> However, the alignment is something rather magical, and it is not clear that is should necessarily only align to the current index level, and not to the full multi-index.\r\n\r\nThis seems clear with the [slicer syntax](http://pandas.pydata.org/pandas-docs/stable/advanced.html#using-slicers) I'm using. The slicer syntax is ``df[ (level_0_indexer, level_1_indexer, ...), :]``, where ``:`` could be replaced by another tuple of slices for the column levels. My (very uneducated) guess is that the ``level_i_indexer`` could be reindexed against ``df.index.get_level_values(i)`` safely. \r\nIs this not the case?\r\n\r\n@shoyer I'm also surprised ``A = df.loc[(df[0]>0, slice(None)), :]`` works, as either ``B = df.loc[df[0]>0, :]`` or ``C = df.loc[(df.loc[df[0] > 0, :].index.get_level_values(0), :), :]`` makes more sense to me. From evaluating, it appears ``A == B`` and ``A != C``. Personally, I would expect that ``A == C``, because otherwise what's the point of using boolean series with per-level indexers?\r\nHowever, this is tangential to the initial issue I opened."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263357816",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263357816",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263357816,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzM1NzgxNg==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-28T18:49:31Z",
    "updated_at": "2016-11-28T18:50:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "The slicing syntax per-level is meant to support a non-chained version that allows things like this:\r\nfrom the docs: http://pandas-docs.github.io/pandas-docs-travis/advanced.html#using-slicers\r\n\r\n```\r\nIn [56]: mask = dfmi[('a','foo')]>200\r\n\r\nIn [57]: dfmi.loc[idx[mask,:,['C1','C3']],idx[:,'foo']]\r\nOut[57]: \r\nlvl0           a    b\r\nlvl1         foo  foo\r\nA3 B0 C1 D1  204  206\r\n      C3 D0  216  218\r\n         D1  220  222\r\n   B1 C1 D0  232  234\r\n         D1  236  238\r\n      C3 D0  248  250\r\n         D1  252  254\r\n```\r\n\r\nthere is no other way to *set* things w/o a chained indexing when simultaneous multi-level label selection & a column boolean.\r\n\r\nFurthermore it is syntactically hard to even specify this, e.g. what if you wanted to simultaneously index *all* of the levels in some way AND use a boolean mask. \r\n\r\nIts probably not used very much or this would have come up earlier."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263640208",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263640208",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263640208,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzY0MDIwOA==",
    "user": {
      "login": "eamartin",
      "id": 287200,
      "node_id": "MDQ6VXNlcjI4NzIwMA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/287200?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/eamartin",
      "html_url": "https://github.com/eamartin",
      "followers_url": "https://api.github.com/users/eamartin/followers",
      "following_url": "https://api.github.com/users/eamartin/following{/other_user}",
      "gists_url": "https://api.github.com/users/eamartin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/eamartin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/eamartin/subscriptions",
      "organizations_url": "https://api.github.com/users/eamartin/orgs",
      "repos_url": "https://api.github.com/users/eamartin/repos",
      "events_url": "https://api.github.com/users/eamartin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/eamartin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-29T17:34:18Z",
    "updated_at": "2016-11-29T17:34:18Z",
    "author_association": "NONE",
    "body": "@jreback If I understand the example from docs + your explanation correctly, then ``dfmi.loc[idx[mask,:,['C1','C3']],idx[:,'foo']]`` is the same as ``dfmi.loc[idx[:, mask, ['C1','C3']], idx[:, 'foo']]``. Is that correct?\r\n\r\nThis syntax exists because the alternative would be to do ``dfmi.loc[mask].loc[idx[:,: ['C1', C3']], idx[:, :]]`` and this can't be used as an lval for assignment because of chaining?\r\n\r\nIf avoiding chaining is the issue, could that dereference be written as\r\n```python\r\nmask = (dfmi[('a', 'foo')] > 200).loc[idx[:, :, ['C1','C3']], idx[:, :]]\r\ndfmi.loc[mask, :] = ...\r\n```\r\nRegardless, I guess it doesn't matter because changing the behavior of `` dfmi.loc[idx[mask,:,['C1','C3']],idx[:,'foo']]`` would break existing code, which presumable you'd like to avoid.\r\n\r\nTo summarize my understanding of this issue:\r\n* indexing one level of a multilevel with a boolean indexer series shorter than the level does not work\r\n* the easiest way to fix this is to reindex the boolean indexer with the level to be indexed\r\n* this reindex call cannot easily be added to the codepath because of support for things like ``dfmi.loc[idx[mask,:,['C1','C3']],idx[:,'foo']]`` which is using a multiindex as the indexer for a single level."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/263740251",
    "html_url": "https://github.com/pandas-dev/pandas/issues/14750#issuecomment-263740251",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/14750",
    "id": 263740251,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2Mzc0MDI1MQ==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-11-30T00:02:04Z",
    "updated_at": "2016-11-30T00:02:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "@lightcatcher yes this syntax is not the best, but I don't think we can / should change anything ATM.\r\n\r\nif you have ideas on how to express something like:\r\n\r\n```\r\nmask = (dfmi[('a', 'foo')] > 200).loc[idx[:, :, ['C1','C3']], idx[:, :]]\r\ndfmi.loc[mask, :] = ...\r\n```\r\n\r\nthen pls open / add to issues https://github.com/pandas-dev/pandas2/issues\r\n"
  }
]
