[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/73447559",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9446#issuecomment-73447559",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9446",
    "id": 73447559,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNDQ3NTU5",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-09T02:02:35Z",
    "updated_at": "2015-02-09T02:02:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "you should have a look here: http://pandas.pydata.org/pandas-docs/stable/io.html#performance-considerations\n\nas to your first point - this is a known limitation of row oriented tables and explicit in the PyTables docs - If it's not in the caveats section you could certainly add it \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/73759941",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9446#issuecomment-73759941",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9446",
    "id": 73759941,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzU5OTQx",
    "user": {
      "login": "rnelsonchem",
      "id": 3750670,
      "node_id": "MDQ6VXNlcjM3NTA2NzA=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3750670?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rnelsonchem",
      "html_url": "https://github.com/rnelsonchem",
      "followers_url": "https://api.github.com/users/rnelsonchem/followers",
      "following_url": "https://api.github.com/users/rnelsonchem/following{/other_user}",
      "gists_url": "https://api.github.com/users/rnelsonchem/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rnelsonchem/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rnelsonchem/subscriptions",
      "organizations_url": "https://api.github.com/users/rnelsonchem/orgs",
      "repos_url": "https://api.github.com/users/rnelsonchem/repos",
      "events_url": "https://api.github.com/users/rnelsonchem/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rnelsonchem/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T18:58:07Z",
    "updated_at": "2015-02-10T18:58:07Z",
    "author_association": "NONE",
    "body": "@jreback I will look into adding something about this limitation in the caveats section and a couple of notes in other sections. However, I looked around in the PyTables documentation, and I couldn't find an explicit reference to this issue with HDF files. It would be nice to include a link if you know of one.\n\nRegarding the comparisons issue... I had looked at that performance results page. However, the difference is not so striking if you only need to select a small subset of rows from a larger-than-memory data set. For example, on my machine I found that HDF outperforms SQL by a factor of ~3 when selecting a subset of rows from a large table:\nhttp://nbviewer.ipython.org/gist/rnelsonchem/e6fa80e71365a0981c59\nAlso, the SQL selection example is pretty straight forward, but I had to do a bit of tinkering to get the HDF example to work without overloading my memory. Still, a factor of three is a factor of three.\n\nI guess I wasn't thinking of read/write timing performance comparison, exactly, but I thought there might be use cases where one solution has advantages over the other. Pandas has nice support for both options, but from the docs/performance results, I get the impression that HDF is preferred in every case. I haven't worked with SQL much, so I wasn't sure if there were cases that this wasn't true. (For example, it seems like things like merging/joining require a bit of extra work with HDF.) If so, it might be useful for new users to have some guidance on successful use cases for the two solutions. Perhaps as another section in the cookbook alongside the HDF/SQL performance comparison or even a link to a preexisting page. I did see this discussion, which is a start:\nhttps://groups.google.com/forum/#!topic/pydata/S3kLxyrizkI\n\nJust a thought.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/73780285",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9446#issuecomment-73780285",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9446",
    "id": 73780285,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzgwMjg1",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T20:46:39Z",
    "updated_at": "2015-02-10T20:46:39Z",
    "author_association": "CONTRIBUTOR",
    "body": "see the `read` method here: http://pytables.github.io/usersguide/libref/structured_storage.html#table-methods-reading\n\nYou are dealing with a row-oriented structure so by definition it will read in all columns (exception for a single column using the special method).\n\nYou may want to look at using [bcolz](https://github.com/Blosc/bcolz) a columnar store. [blaze](http://blaze.pydata.org/docs/dev/index.html) and [into](https://github.com/ContinuumIO/into) provide easy access to these types of structures (as well as conversion between many other types).\n\nGenerally HDF5 is vastly superior to anything SQL-ike when modify/update is not a concern and data is mostly read/append only. You have to be careful about the limitations inherent in the data storage formats though. Pandas provides access to these features, but users are in charge of the data arangements.\n\nSo, additional docs are always helpful, as an update to the SQL comparison. However, pandas can't try (or should) provide guidance in all but the common cases.\n"
  }
]
