[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45260466",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7361#issuecomment-45260466",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7361",
    "id": 45260466,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1MjYwNDY2",
    "user": {
      "login": "davidljung",
      "id": 417058,
      "node_id": "MDQ6VXNlcjQxNzA1OA==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/417058?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidljung",
      "html_url": "https://github.com/davidljung",
      "followers_url": "https://api.github.com/users/davidljung/followers",
      "following_url": "https://api.github.com/users/davidljung/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidljung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidljung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidljung/subscriptions",
      "organizations_url": "https://api.github.com/users/davidljung/orgs",
      "repos_url": "https://api.github.com/users/davidljung/repos",
      "events_url": "https://api.github.com/users/davidljung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidljung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-05T19:02:35Z",
    "updated_at": "2014-06-05T19:02:35Z",
    "author_association": "CONTRIBUTOR",
    "body": "PS: The reason the title says 'assigns NaN' despite the fact that df already contains NaNs, is that my original reproduction had `df['value'] = ''` and the result was that the sliced rows of df contained NaNs after the assignment.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45268217",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7361#issuecomment-45268217",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7361",
    "id": 45268217,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1MjY4MjE3",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-05T20:13:20Z",
    "updated_at": "2014-06-05T20:13:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "You are setting 2 different ways. The first, with a rhs of an ndarray CANNOT ALIGN, while the 2nd with a rhs of a pandas object, ALWAYS aligns.\n\n```\n[15]: df = DataFrame(dict(A = np.arange(5), B = np.nan))\n\nIn [16]: df2 = DataFrame(dict(A = np.arange(3)))\n\nIn [17]: df\nOut[17]: \n   A   B\n0  0 NaN\n1  1 NaN\n2  2 NaN\n3  3 NaN\n4  4 NaN\n\nIn [18]: df2\nOut[18]: \n   A\n0  0\n1  1\n2  2\n```\n\nThe rhs is a Series, so it will align.\n\n```\nIn [19]: df.loc[df.A.isin(df2.A),'B'] = df2['A']\n\nIn [20]: df\nOut[20]: \n   A   B\n0  0   0\n1  1   1\n2  2   2\n3  3 NaN\n4  4 NaN\n```\n\nYou get the same result because the values HAPPEN to be in the same order\n\n```\nIn [21]: df.loc[df.A.isin(df2.A),'B'] = df2['A'].values\n\nIn [22]: df\nOut[22]: \n   A   B\n0  0   0\n1  1   1\n2  2   2\n3  3 NaN\n4  4 NaN\n```\n\nIf the fhs is NOT a pandas object, then you will get an error\nIt makes no sense to try to assign 3 lhs items with 2 on the rhs\n\n```\nIn [23]: df.loc[df.A.isin(df2.A),'B'] = [0,1]\nValueError: Must have equal len keys and value when setting with an iterable\n```\n\n```\nIn [26]: df2.loc[[2,1,0],'A']\nOut[26]: \n2    2\n1    1\n0    0\nName: A, dtype: int64\n```\n\nThis is aligning in action\n\n```\nIn [24]: df.loc[df.A.isin(df2.A),'B'] = df2.loc[[2,1,0],'A']\n\nIn [25]: df\nOut[25]: \n   A   B\n0  0   0\n1  1   1\n2  2   2\n3  3 NaN\n4  4 NaN\n```\n\nThis is why using a rhs of an ndarray you MUST ALIGN YOURSELF!.\n\n```\nIn [27]: df.loc[df.A.isin(df2.A),'B'] = df2.loc[[2,1,0],'A'].values\n\nIn [28]: df\nOut[28]: \n   A   B\n0  0   2\n1  1   1\n2  2   0\n3  3 NaN\n4  4 NaN\n```\n\nThis is not a bug at all, just how it works, and why this makes sense.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45271535",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7361#issuecomment-45271535",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7361",
    "id": 45271535,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1MjcxNTM1",
    "user": {
      "login": "davidljung",
      "id": 417058,
      "node_id": "MDQ6VXNlcjQxNzA1OA==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/417058?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidljung",
      "html_url": "https://github.com/davidljung",
      "followers_url": "https://api.github.com/users/davidljung/followers",
      "following_url": "https://api.github.com/users/davidljung/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidljung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidljung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidljung/subscriptions",
      "organizations_url": "https://api.github.com/users/davidljung/orgs",
      "repos_url": "https://api.github.com/users/davidljung/repos",
      "events_url": "https://api.github.com/users/davidljung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidljung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-05T20:39:53Z",
    "updated_at": "2014-06-05T20:39:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "I did say it could be my lack of understanding :)  Appreciate the time for your clarification.\n\nI'm still a little confused though.  Above you say \"_The first, with a rhs of an ndarray_\", but the first statement is the `=common.value` one, which seems to yield a Series.  This is the approach that fails and just assigns NaNs.  \n\nNext, you say, \"_the 2nd with a rhs of a pandas object_\", but the 2nd statement reads `=common.loc[:,'value'].values`, which an ndarray (I know now).  This works (presumably since, as you said, the order was prearranged to align).  Unsure if you switched the 1st/2nd order in your reply or if I've misunderstood.  \n\nI'm still missing why assigning a Pandas Series (`common.value`), which has been prearranged to be in the correct order and length, doesn't work.  Perhaps because the slice retains the index labels of `df`, rather than matching the 0..len of `common`?  Maybe I should set key as the DataFrame index.\nOf course, I'm not sure exactly what 'align' means - I understand it to mean the order (and length) of the indices match.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45271989",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7361#issuecomment-45271989",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7361",
    "id": 45271989,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1MjcxOTg5",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-05T20:43:42Z",
    "updated_at": "2014-06-05T20:43:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "(I miswrote....s/1st/2nd/.....in my comment)\n\nhow does having a rhs of `common.values` (a Series) not work? (it seems to in your example). That will align as well (it happens to be in the correct order). `aligning==reindexing` essentially.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45274421",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7361#issuecomment-45274421",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7361",
    "id": 45274421,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1Mjc0NDIx",
    "user": {
      "login": "davidljung",
      "id": 417058,
      "node_id": "MDQ6VXNlcjQxNzA1OA==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/417058?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidljung",
      "html_url": "https://github.com/davidljung",
      "followers_url": "https://api.github.com/users/davidljung/followers",
      "following_url": "https://api.github.com/users/davidljung/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidljung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidljung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidljung/subscriptions",
      "organizations_url": "https://api.github.com/users/davidljung/orgs",
      "repos_url": "https://api.github.com/users/davidljung/repos",
      "events_url": "https://api.github.com/users/davidljung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidljung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-05T21:02:45Z",
    "updated_at": "2014-06-05T21:04:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "ok, that makes more sense now.\n\nWhen I say \"not work\", since this isn't a bug, a better phrase would be \"didn't do what I expected\" :)\n\nThat is, I expected assigning common.values - Series - to the slice of df to actually assign some of the values from common into df, but all it does is modify the sliced entries of df to be NaN from whatever they were.  That is why the statement `all(pd.isnull(df.value))` is True after the assignment.  If I initially set `df.value=''` instead, then after the assignment `df.value` has empty strings everywhere except the selected/sliced rows (those with key in `common.key`), which have NaN.\n\nIf I understand it, what you're saying is that when I slice df, the rows of the resulting slice are referencing the index labels originally in df (- it is like a view on the original DataFrame), so those original 'row numbers' (if you like) aren't necessarily going to match the sequential row numbers from the smaller `common` DataFrame.  In effect, since `common` doesn't have rows with those indices, it assigns NaN.\n\nSeems like it would be more elegant to have the key column as a DataFrame index, then the assignment's alignment procedure would automatically match-up (align) the rows from common.value to those in the df slice, by key (which, oddly enough, is how I started out trying to implement it).  I assume this would work with either `common.value` or `common.loc[:,'value']`, since in the former case the Series would receive the same index labels.\n\nDo I have it?\n\n(trying to implement a partially disk-based left join from huge HDF file containing the right table)\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/45276128",
    "html_url": "https://github.com/pandas-dev/pandas/issues/7361#issuecomment-45276128",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/7361",
    "id": 45276128,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ1Mjc2MTI4",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-06-05T21:17:02Z",
    "updated_at": "2014-06-05T21:17:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "you soln is correct, that is the point of the indexes. That said, you _can_ assign a straight list/ndarray, its just that you are in charge of the ordering.\n"
  }
]
