[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/177527127",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-177527127",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 177527127,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3NzUyNzEyNw==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-01-31T15:32:33Z",
    "updated_at": "2016-01-31T15:32:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "you can do something this. Not sure how useful this is generally as IIRC this is first request about this type of filling\n\n```\nIn [79]: s = Series([0]+[np.nan]*2+[3,4,5]+[np.nan]*4+[10],index=pd.date_range('20130101',periods=11,freq='T'))\n\nIn [80]: s\nOut[80]: \n2013-01-01 00:00:00     0\n2013-01-01 00:01:00   NaN\n2013-01-01 00:02:00   NaN\n2013-01-01 00:03:00     3\n2013-01-01 00:04:00     4\n2013-01-01 00:05:00     5\n2013-01-01 00:06:00   NaN\n2013-01-01 00:07:00   NaN\n2013-01-01 00:08:00   NaN\n2013-01-01 00:09:00   NaN\n2013-01-01 00:10:00    10\nFreq: T, dtype: float64\n\nIn [81]: indexer = s.groupby(pd.Grouper(freq='3T')).filter(lambda x: x.isnull().sum()==len(x))\n\nIn [82]: indexer\nOut[82]: \n2013-01-01 00:06:00   NaN\n2013-01-01 00:07:00   NaN\n2013-01-01 00:08:00   NaN\nFreq: T, dtype: float64\n\nIn [83]: s2 = s.interpolate()                   \n\nIn [84]: s.interpolate().loc[indexer.index]\nOut[84]: \n2013-01-01 00:06:00    6\n2013-01-01 00:07:00    7\n2013-01-01 00:08:00    8\nFreq: T, dtype: float64\n\nIn [86]: s2 = s.copy()\n\nIn [87]: s2.loc[indexer.index] = s.interpolate()\n\nIn [88]: s2\nOut[88]: \n2013-01-01 00:00:00     0\n2013-01-01 00:01:00   NaN\n2013-01-01 00:02:00   NaN\n2013-01-01 00:03:00     3\n2013-01-01 00:04:00     4\n2013-01-01 00:05:00     5\n2013-01-01 00:06:00     6\n2013-01-01 00:07:00     7\n2013-01-01 00:08:00     8\n2013-01-01 00:09:00   NaN\n2013-01-01 00:10:00    10\nFreq: T, dtype: float64\n\nIn [89]: s.resample('3T',how='sum')\nOut[89]: \n2013-01-01 00:00:00     0\n2013-01-01 00:03:00    12\n2013-01-01 00:06:00   NaN\n2013-01-01 00:09:00    10\nFreq: 3T, dtype: float64\n\nIn [90]: s2.resample('3T',how='sum')\nOut[90]: \n2013-01-01 00:00:00     0\n2013-01-01 00:03:00    12\n2013-01-01 00:06:00    21\n2013-01-01 00:09:00    10\nFreq: 3T, dtype: float64\n```\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/177731391",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-177731391",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 177731391,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3NzczMTM5MQ==",
    "user": {
      "login": "delie0512",
      "id": 16981006,
      "node_id": "MDQ6VXNlcjE2OTgxMDA2",
      "avatar_url": "https://avatars0.githubusercontent.com/u/16981006?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/delie0512",
      "html_url": "https://github.com/delie0512",
      "followers_url": "https://api.github.com/users/delie0512/followers",
      "following_url": "https://api.github.com/users/delie0512/following{/other_user}",
      "gists_url": "https://api.github.com/users/delie0512/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/delie0512/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/delie0512/subscriptions",
      "organizations_url": "https://api.github.com/users/delie0512/orgs",
      "repos_url": "https://api.github.com/users/delie0512/repos",
      "events_url": "https://api.github.com/users/delie0512/events{/privacy}",
      "received_events_url": "https://api.github.com/users/delie0512/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-01T03:06:17Z",
    "updated_at": "2016-02-01T03:06:43Z",
    "author_association": "NONE",
    "body": "Based on the original values of \"s\" above, the results that I looking for \"interpolating gaps up to 3 hours\" in a hourly time-series would be as follows. The first gap (2 values) is interpolated, but for the second gap ( 4 values) no interpolation is performed at all. I could write code to do what I want, but I would prefer using an existing tool for which the user can specific the maximum gap to interpolate (maxgap).\n\n```\n2013-01-01 00:00:00     0\n2013-01-01 00:01:00     1 interpolated, since gap = =2 <=maxgap\n2013-01-01 00:02:00     2 interpolated, since gap = =2 <=maxgap\n2013-01-01 00:03:00     3\n2013-01-01 00:04:00     4\n2013-01-01 00:05:00     5\n2013-01-01 00:06:00   NaN   not interpolated, since gap = 4 > maxgap\n2013-01-01 00:07:00   NaN   not interpolated, since gap = 4 > maxgap\n2013-01-01 00:08:00   NaN   not interpolated, since gap = 4 > maxgap\n2013-01-01 00:09:00   NaN   not interpolated, since gap = 4 > maxgap\n2013-01-01 00:10:00    10\nFreq: T, dtype: float64\n```\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/177781120",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-177781120",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 177781120,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE3Nzc4MTEyMA==",
    "user": {
      "login": "kawochen",
      "id": 10709573,
      "node_id": "MDQ6VXNlcjEwNzA5NTcz",
      "avatar_url": "https://avatars2.githubusercontent.com/u/10709573?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kawochen",
      "html_url": "https://github.com/kawochen",
      "followers_url": "https://api.github.com/users/kawochen/followers",
      "following_url": "https://api.github.com/users/kawochen/following{/other_user}",
      "gists_url": "https://api.github.com/users/kawochen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kawochen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kawochen/subscriptions",
      "organizations_url": "https://api.github.com/users/kawochen/orgs",
      "repos_url": "https://api.github.com/users/kawochen/repos",
      "events_url": "https://api.github.com/users/kawochen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kawochen/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-02-01T05:49:11Z",
    "updated_at": "2016-02-01T05:49:11Z",
    "author_association": "CONTRIBUTOR",
    "body": "this is a bit like consolidating `fillna` and `interpolate`\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/221310645",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-221310645",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 221310645,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTMxMDY0NQ==",
    "user": {
      "login": "tomchor",
      "id": 13205162,
      "node_id": "MDQ6VXNlcjEzMjA1MTYy",
      "avatar_url": "https://avatars2.githubusercontent.com/u/13205162?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tomchor",
      "html_url": "https://github.com/tomchor",
      "followers_url": "https://api.github.com/users/tomchor/followers",
      "following_url": "https://api.github.com/users/tomchor/following{/other_user}",
      "gists_url": "https://api.github.com/users/tomchor/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tomchor/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tomchor/subscriptions",
      "organizations_url": "https://api.github.com/users/tomchor/orgs",
      "repos_url": "https://api.github.com/users/tomchor/repos",
      "events_url": "https://api.github.com/users/tomchor/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tomchor/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-24T15:35:04Z",
    "updated_at": "2016-05-24T15:36:51Z",
    "author_association": "NONE",
    "body": "I've actually had to do something like this before. See [this answer](http://stackoverflow.com/questions/32850185/change-value-if-consecutive-number-of-certain-condition-is-achieved-in-pandas) to check out how it was achieved.\n\nI can actually say this is pretty useful. I know a number of quality-control techniques that use this kind of reasoning: if gap < maxgap do nothing, do something else otherwise (or vice-versa).\n\nI would recommend something like passing an extra `maxgap` and `mingap` keywords to interpolate, that control maximum number of consecutive gaps to consider when interpolating and the minimum. The OP's original example would become something like\n\n```\ninterpolated = df.interpolate(maxgap=3, mingap=None)\n```\n\n@delie0512 @jreback \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/221379702",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-221379702",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 221379702,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIyMTM3OTcwMg==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-24T19:39:28Z",
    "updated_at": "2016-05-24T19:39:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "yeah iterative grouping is usefule, see the last example here: http://pandas.pydata.org/pandas-docs/stable/cookbook.html#grouping\n\nI suppose if someone wanted to contribute a `maxgaps` would take it.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/402964616",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-402964616",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 402964616,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMjk2NDYxNg==",
    "user": {
      "login": "arjdk",
      "id": 39184289,
      "node_id": "MDQ6VXNlcjM5MTg0Mjg5",
      "avatar_url": "https://avatars0.githubusercontent.com/u/39184289?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/arjdk",
      "html_url": "https://github.com/arjdk",
      "followers_url": "https://api.github.com/users/arjdk/followers",
      "following_url": "https://api.github.com/users/arjdk/following{/other_user}",
      "gists_url": "https://api.github.com/users/arjdk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/arjdk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/arjdk/subscriptions",
      "organizations_url": "https://api.github.com/users/arjdk/orgs",
      "repos_url": "https://api.github.com/users/arjdk/repos",
      "events_url": "https://api.github.com/users/arjdk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/arjdk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-06T08:26:23Z",
    "updated_at": "2018-07-06T13:50:36Z",
    "author_association": "NONE",
    "body": "This seems like a very real issue, as from my perspective the whole point of having the \"limit\" argument is to avoid filling spaces which are too large, i.e. the assumption for filling does not hold.\r\n\r\nIs anyone still looking at this issue?\r\n\r\nAnother very similar issue is #16457 and on stackoverflow: https://stackoverflow.com/questions/43077166/interpolate-only-if-single-nan/43079055#43079055\r\nhttps://stackoverflow.com/questions/43082316/mask-only-where-consecutive-nans-exceeds-x#"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/409887390",
    "html_url": "https://github.com/pandas-dev/pandas/issues/12187#issuecomment-409887390",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/12187",
    "id": 409887390,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwOTg4NzM5MA==",
    "user": {
      "login": "notuntoward",
      "id": 3851891,
      "node_id": "MDQ6VXNlcjM4NTE4OTE=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3851891?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/notuntoward",
      "html_url": "https://github.com/notuntoward",
      "followers_url": "https://api.github.com/users/notuntoward/followers",
      "following_url": "https://api.github.com/users/notuntoward/following{/other_user}",
      "gists_url": "https://api.github.com/users/notuntoward/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/notuntoward/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/notuntoward/subscriptions",
      "organizations_url": "https://api.github.com/users/notuntoward/orgs",
      "repos_url": "https://api.github.com/users/notuntoward/repos",
      "events_url": "https://api.github.com/users/notuntoward/events{/privacy}",
      "received_events_url": "https://api.github.com/users/notuntoward/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-02T10:54:03Z",
    "updated_at": "2018-08-02T10:55:20Z",
    "author_association": "NONE",
    "body": "I've had to do this many, many times, and adding this capability would be a good improvement.\r\n\r\nThe most common use case is when you can justify interpolating short missing data gaps within a signal's temporal autcorrelation range, but cannot justify interpolating long gaps.  \r\n\r\nAnother use case is when data is being upsampled using pd.resample(), which inserts NaNs for timestamps to be interpolated.  Say you're upsampling by a factor of three.  In this case, you can do the upsample by interpolating across at most 2 consecutive NaNs.  Three or more consecutive NaNs indicate the presence of missing data in the original time series; you don't want to interpolate across that."
  }
]
