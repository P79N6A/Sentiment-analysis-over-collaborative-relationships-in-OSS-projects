[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69282415",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69282415",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69282415,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MjgyNDE1",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T01:52:36Z",
    "updated_at": "2015-01-09T01:52:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "you can simply create an empty frame with an index and columns\nthen assign ndarrays - these won't copy of you assign all of a particular dtype at once\n\nyou could create these with np.empty if you wish\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69283462",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69283462",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69283462,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MjgzNDYy",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T02:07:27Z",
    "updated_at": "2015-01-09T02:08:31Z",
    "author_association": "NONE",
    "body": "```\ndf = pd.DataFrame(index=range(2), columns=[\"dude\", \"wheres\"])\n\ndf\nOut[12]:\n  dude wheres\n0  NaN    NaN\n1  NaN    NaN\n\nx = np.empty(2, np.int32)\n\nx\nOut[14]: array([6, 0], dtype=int32)\n\ndf.dude = x\n\ndf\nOut[16]:\n   dude wheres\n0     6    NaN\n1     0    NaN\n\nx[0] = 0\n\nx\nOut[18]: array([0, 0], dtype=int32)\n\ndf\nOut[19]:\n   dude wheres\n0     6    NaN\n1     0    NaN\n```\n\nLooks like it's copying to me. Unless the code I wrote isn't what you meant, or the copying that occurred is not the copy you thought I was trying to elide.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69283963",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69283963",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69283963,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MjgzOTYz",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T02:15:18Z",
    "updated_at": "2015-01-09T02:15:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "you changed the dtype\nthat's why it copied try with a float \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69284414",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69284414",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69284414,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mjg0NDE0",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T02:22:08Z",
    "updated_at": "2015-01-09T02:22:08Z",
    "author_association": "NONE",
    "body": "```\ny = np.empty(2, np.float64)\n\ndf\nOut[21]:\n   dude wheres\n0     6    NaN\n1     0    NaN\n\ndf.wheres = y\n\ny\nOut[23]: array([  2.96439388e-323,   2.96439388e-323])\n\ny[0] = 0\n\ndf\nOut[25]:\n   dude         wheres\n0     6  2.964394e-323\n1     0  2.964394e-323\n\ndf = pd.DataFrame(index=range(2), columns=[\"dude\", \"wheres\"])\n\ndf.dtypes\nOut[27]:\ndude      object\nwheres    object\ndtype: object\n```\n\nThe dtype is object, so its changed regardless of whether I use a float or an int. \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69285290",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69285290",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69285290,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mjg1Mjkw",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T02:35:06Z",
    "updated_at": "2015-01-09T02:35:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "```\nIn [25]: arr = np.ones((2,3))\n\nIn [26]: df = DataFrame(arr,columns=['a','b','c'])\n\nIn [27]: arr[0,1] = 5\n\nIn [28]: df\nOut[28]: \n   a  b  c\n0  1  5  1\n1  1  1  1\n```\n\nConstructing w/o a copy on mixed type could be done but is quite tricky. The problem is some types require a copy (e.g. object to avoid memory contention issues). And the internal structure consolidates different types, so adding a new type will necessitatte a copy. Avoiding a copy is pretty difficult in most cases.\n\nYou should just create what you need, get pointers to the data and then overwrite it. Why is that a problem?\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69287238",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69287238",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69287238,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mjg3MjM4",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T03:05:44Z",
    "updated_at": "2015-01-09T03:05:44Z",
    "author_association": "NONE",
    "body": "The problem is that in order to create what I need, I have to copy in stuff of the correct dtype, the data of which I have no intention of using. Even assuming that your suggestion of creating an empty DataFrame uses no significant RAM, this doesn't alleviate the cost of copying. If I want to create a 1 gigabyte DataFrame and populate it somewhere else, I'll have to pay the cost of copying a gigabyte of garbage around in memory, which is completely needless. Do you not see this as a problem?\n\nYes, I understand that the internal structure consolidates different types. I'm not sure exactly what you mean by memory contention issues, but in any case objects are not really what's of interest here. \n\nActually, while avoiding copies in general is a hard problem, avoiding them in the way I suggested is fairly easy because I'm supplying all the necessary information from the get-go. It's identical to constructing from data, except that instead of inferring the dtypes and the # of rows from data and copying the data, you specify the dtypes and # of rows directly, and do everything else exactly as you would have done minus the copy.\n\nYou need an \"empty\" constructor for every supported column type. For numpy numeric types this is obvious, it needs non-zero work for Categorical, unsure about DatetimeIndex.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69297226",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69297226",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69297226,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mjk3MjI2",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T06:07:01Z",
    "updated_at": "2015-01-09T06:07:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "passing a dict to the constructor and copy=False should work \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69325802",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69325802",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69325802,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzI1ODAy",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T11:59:03Z",
    "updated_at": "2015-01-09T11:59:03Z",
    "author_association": "CONTRIBUTOR",
    "body": "So this will work. But you have to be SURE that the arrays that you are passing are distinct dtypes. And once you do anything to this it could copy the underlying data. So YMMV. you can of course pass in `np.empty` instead of the ones/zeros that I am.\n\n```\nIn [75]: arr = np.ones((2,3))\n\nIn [76]: arr2 = np.zeros((2,2),dtype='int32')\n\nIn [77]: df = DataFrame(arr,columns=list('abc'))\n\nIn [78]: df2 = DataFrame(arr2,columns=list('de'))\n\nIn [79]: result = pd.concat([df,df2],axis=1,copy=False)\n\nIn [80]: arr2[0,1] = 20\n\nIn [81]: arr[0,1] = 10\n\nIn [82]: result\nOut[82]: \n   a   b  c  d   e\n0  1  10  1  0  20\n1  1   1  1  0   0\n\nIn [83]: result._data\nOut[83]: \nBlockManager\nItems: Index([u'a', u'b', u'c', u'd', u'e'], dtype='object')\nAxis 1: Int64Index([0, 1], dtype='int64')\nFloatBlock: slice(0, 3, 1), 3 x 2, dtype: float64\nIntBlock: slice(3, 5, 1), 2 x 2, dtype: int32\n\nIn [84]: result._data.blocks[0].values.base\nOut[84]: \narray([[  1.,  10.,   1.],\n       [  1.,   1.,   1.]])\n\nIn [85]: result._data.blocks[1].values.base\nOut[85]: \narray([[ 0, 20],\n       [ 0,  0]], dtype=int32)\n```\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69352050",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69352050",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69352050,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzUyMDUw",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T15:48:58Z",
    "updated_at": "2015-01-09T15:53:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "_Iniital attempt deleted since does not work since `reindex` forces casting, which is a strange \"feature\"._\n\nHave to use 'method', which make this attempt a little less satisfactory:\n\n``` python\narr = np.empty(1, dtype=[('x', np.float), ('y', np.int)])\ndf = pd.DataFrame.from_records(arr).reindex(np.arange(100))\n```\n\nIf you are really worried about performance, I'm not sure why one wouldn't just use numpy as much as possible since it is conceptually much simpler.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69380923",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69380923",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69380923,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MzgwOTIz",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T18:58:18Z",
    "updated_at": "2015-01-09T18:58:18Z",
    "author_association": "NONE",
    "body": "jreback, thank you for your solution. This seems to work, even for Categoricals (which surprised me). If I encounter issues I'll let you know. I'm not sure what you mean by: if you do anything to this, it could copy. What do you mean by anything? Unless there are COW semantics I would think what you see is what you get with regards to deep vs shallow copies, at construction time. \n\nI still think a from_empty constructor should be implemented, and I don't think it would be that difficult, while this technique works, it does involve a lot of code overhead. In principle this could be done by specifying a single composite dtype and a number of rows.\n\nbashtage, these solutions still write into the entire DataFrame. Since writing is generally slower than reading, this means at best it saves less than half the overhead in question.\n\nObviously if I haven't gone and used numpy, its because pandas has many awesome features and capabilities that I love, and I don't want to give those up. Were you really asking, or just implying that I should use numpy if I don't want to take this performance hit?\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69387718",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69387718",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69387718,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mzg3NzE4",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T19:44:31Z",
    "updated_at": "2015-01-09T19:54:23Z",
    "author_association": "NONE",
    "body": "Scratch this, please, user error, and my apologies. reindex_axis with copy=False worked perfectly.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69389073",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69389073",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69389073,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mzg5MDcz",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T19:53:50Z",
    "updated_at": "2015-01-09T19:53:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "> bashtage, these solutions still write into the entire DataFrame. Since writing is generally slower than reading, this means at best it saves less than half the overhead in question.\n\nTrue, but all that you need to a new `method` for `reindex` that will not fill with anything and then you can allocate a typed array with arbitrary column types without writing/copying. \n\n> Obviously if I haven't gone and used numpy, its because pandas has many awesome features and capabilities that I love, and I don't want to give those up. Were you really asking, or just implying that I should use numpy if I don't want to take this performance hit?\n\nIt was a bit rhetorical - although also a serious suggestion from a performance point of view since numpy makes it much easier to get close to the data-as-a-blob-of-memory access that is important if you are trying to write very high performance code. You can always convert from numpy to pandas when code simplicity is more important than performance.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69396075",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69396075",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69396075,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5Mzk2MDc1",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T20:44:42Z",
    "updated_at": "2015-01-09T20:44:42Z",
    "author_association": "NONE",
    "body": "I see what you are saying. I still think it should more cleanly be part of the interface rather than a workaround, but as workarounds go it is a good one and easy to implement.\n\nPandas still emphasizes performance as one if its main objectives. Obviously it has higher level features compared to numpy, and those have to be paid for. What we're talking about has nothing to do with those higher level features, and there's no reason why one should be paying for massive copies in places where you don't need them. Your suggestion would be appropriate if someone was making a stink about the cost of setting up the columns, index, etc, which is completely different from this discussion.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69401094",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69401094",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69401094,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDAxMDk0",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T21:22:55Z",
    "updated_at": "2015-01-09T21:22:55Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think you are overestimating the cost of writing vs. the code of alloating memory in Python -- the expensive part is the memory allocation.  The object creation is also expensive.\n\nBoth allocate 1GB of memory, one empty and one zeros.\n\n``` python\n%timeit np.empty(1, dtype=[('x', float), ('y', int), ('z', float)])\n100000 loops, best of 3: 2.44 µs per loop\n\n%timeit np.zeros(1, dtype=[('x', float), ('y', int), ('z', float)])\n100000 loops, best of 3: 2.47 µs per loop\n\n%timeit np.zeros(50000000, dtype=[('x', float), ('y', int), ('z', float)])\n100000 loops, best of 3: 11.7 µs per loop\n\n%timeit np.empty(50000000, dtype=[('x', float), ('y', int), ('z', float)])\n100000 loops, best of 3: 11.4 µs per loop\n```\n\n3µs for zeroing 150,000,000 values.\n\nNow compare these for a trivial DataFrame.\n\n``` python\n%timeit pd.DataFrame([[0]])\n1000 loops, best of 3: 426 µs per loop\n```\n\nAround 200 times slower for trivial.  But it is far worse for larger arrays.\n\n``` python\n%timeit pd.DataFrame(np.empty((50000000, 3)),copy=False)\n1 loops, best of 3: 275 ms per loop\n```\n\nNow it takes 275**m**s -- note that this is not copying anything.  The cost is in setting up the index, etc which is clearly very slow when the array is nontrivially big.\n\nThis feels a like a premature optimization to me since the other overheads in pandas are so large that the malloc + filliing component is near 0 cost. \n\nIt seems that if you want to allocate anything in a tight loop that is must be a numpy array for performance reasons.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69402568",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69402568",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69402568,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDAyNTY4",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T21:32:49Z",
    "updated_at": "2015-01-09T21:32:49Z",
    "author_association": "CONTRIBUTOR",
    "body": "ok, here's what I think we should do, @quicknir if you'd like to make some improvements. 2 issues.\n- #4464 - this is essentially allowing a compound dtype in the `DataFrame` constructor and then turning around and calling `from_records()`, which can also be called if the passed in array is a rec/structured array - this would basically make `from_records` the rec/structued array processing path\n- pass thru the `copy=` keyword to `from_records`\n- `from_records` can then use the `concat` soln that I show above, rather than splitting the rec-array up, sanitizing them (as series) and then putting them back together (into dtype blocks; this part is done internally).\n\nThis is slightly non-trivial but would then allow one to pass in an already created ndarray (could be empty) with mixed types pretty easily. Note that this would likely (in a first pass implementation) handle only (int/float/string). as datetime/timedelta need special sanitizing and would make this slighlty more complicated.\n\nso @bashtage is right from a perf perspective. It makes a lot of sense to simply construct the frame as you want then modify the ndarrays (but you MUST do this by grabbing the blocks, otherwise you will get copies).\n\nWhat I meant above is this. Pandas groups any like-dtype (e.g. int64,int32 are different) into a 'block' (2-d in a frame). These are a contiguous memory ndarray (that is newly allocated, unless it is simply passed in which only currently works for a single dtype). If you then do a setitem, e.g. `df['new_columns'] = 5` and you already have a int64 block, then this new column will ultimatly be concatetated to it (resulting in a new memory allocation for that dtype). If you were using a reference as a view on this it will no longer be valid. That's why this is not a strategy you can employ w/o peering at the DataFrame internals.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69402870",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69402870",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69402870,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDAyODcw",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T21:34:53Z",
    "updated_at": "2015-01-09T21:34:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "@bashtage yeh the big cost is the index as you have noted. a `RangeIndex` (see #939) would solve this problem completely. (it is actually almost done in a side branch, just needs some dusting off).\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69410618",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69410618",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69410618,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDEwNjE4",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T22:29:01Z",
    "updated_at": "2015-01-09T22:29:24Z",
    "author_association": "CONTRIBUTOR",
    "body": "Even with an optimized `RangeIndex` it will still be 2 orders of magnitude slower than constructing a NumPy array, which is fair enough given the much heavier weight nature and additional capabilities of a `DataFrame`.\n\nI think this can only be considered a convenience function, and not a performance issue.It could be useful to initialize a mixed type `DataFrame` or `Panel` like.\n\n``` python\ndtype=np.dtype([('GDP', np.float64), ('Population', np.int64)])\npd.Panel(items=['AU','AT'],\n         major_axis=['1972','1973'],\n         minor_axis=['GDP','Population'], \n         dtype=[np.float, np.int64])\n```\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69411011",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69411011",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69411011,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDExMDEx",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-09T22:31:02Z",
    "updated_at": "2015-01-09T22:31:02Z",
    "author_association": "CONTRIBUTOR",
    "body": "this is only an API / convenience issue \n\nagreed the perf is really an incidental issue (and not the driver)\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69459636",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69459636",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69459636,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDU5NjM2",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T15:33:14Z",
    "updated_at": "2015-01-10T15:33:14Z",
    "author_association": "NONE",
    "body": "@bashtage \n\n%timeit pd.DataFrame(np.empty((100, 1000000)))\n100 loops, best of 3: 15.6 ms per loop\n\n%timeit pd.DataFrame(np.empty((100, 1000000)), copy=True)\n1 loops, best of 3: 302 ms per loop\n\nSo copying into a dataframe seems to take 20 times longer than all the other work involved in creating the DataFrame, i.e. the copy (and extra allocation) is 95% of the time. The benchmarks you did do not benchmark the correct thing. Whether the copy itself or the allocation is what's taking time doesn't really matter, the point is that if I could avoid copies for a multiple dtype DataFrame the way I can for a single dtype DataFrame I could save a huge amount of time.\n\nYour two order of magnitude reasoning is also deceiving. This is not the only operation being performed, there are other operations being performed that take time, like disk reads. Right now, the extra copy I need to do to create the DataFrame is taking about half the time in my simple program that just reads the data off disk and into a DataFrame. If it took 1/20 th as much time, then the disk read would be dominant (as it should be) and further improvements would have almost no effect.\n\nSo I want to again emphasize to both of you: this is a real performance issue. \n\njreback, given that the concatenation strategy does not work for Categoricals, don't think that the improvements you suggested above will work. I think a better starting point would be reindex. The issue right now is that reindex does lots of extra stuff. But in principle, a DataFrame with zero rows has all the information necessary to allow the creation of a DataFrame with the correct number of rows, without doing any unnecessary work. Btw, this makes me really feel like pandas needs a schema object, but that's a discussion for another day. \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69460624",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69460624",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69460624,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYwNjI0",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:02:25Z",
    "updated_at": "2015-01-10T16:02:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "I think we wil have to agree to disagree.   IMO DataFrames are not extreme performance objects in the numeric ecosystem, as show by the order of magntude difference between a basic numpy array and a DataFrame creation.\n\n``` python\n%timeit np.empty((1000000, 100))\n1000 loops, best of 3: 1.61 ms per loop\n\n%timeit pd.DataFrame(np.empty((1000000,100)))\n100 loops, best of 3: 15.3 ms per loop\n```\n\n> Right now, the extra copy I need to do to create the DataFrame is taking about half the time in my simple program that just reads the data off disk and into a DataFrame. If it took 1/20 th as much time, then the disk read would be dominant (as it should be) and further improvements would have almost no effect.\n\nI think this is even less reason to care about DataFrame performance -- even if you can make it 100% free, the total program time only declines by 50%.  \n\nI agree that there is scope for you to do a PR here to resolve this issue, whether you want to think of it as a performance issue or as a convenience issue.  From my POV, I see it as the latter since I will always use a numpy array when I care are performance. Numpy does other things like not use a block manager which is relatively efficient for some things (like growing the array by adding columns). but bad from other points of view.\n\nThere could be two options.  The first, an empty constructor as in the example I gave above.  This would not copy anything, but would probably Null-fill to be consistent with other things in pandas.  Null filling is pretty cheap and is not at the root of the problem IMO.\n\nThe other would be to have a method `DataFrame.from_blocks` that would take preformed blocks to pass straight to the block manager.  Something like\n\n``` python\nDataFrame.from_blocks([np.empty((100,2)), \n                       np.empty((100,3), dtype=np.float32), \n                       np.empty((100,1), dtype=np.int8)],\n                     columns=['f8_0','f8_1','f4_0','f4_1','f4_2','i1_0'],\n                     index=np.arange(100))\n```\n\nA method of this type would enforce that the blocks have compatible shape, all blocks have unique types, as well as the usual checks for shape of the index and columns.  This type of method would do nothing to the data and would use it in the BlockManger.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69460838",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69460838",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69460838,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYwODM4",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:08:56Z",
    "updated_at": "2015-01-10T16:08:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "@quicknir you are trying to combine pretty complicated things. Categorical don't exist in numpy, rather they are a compound dtype like that is a pandas construct. You have to construct and assign then separately (which is actually quite cheap - these are not combined into blocks like other singular dtypes).\n\n@bashtage soln seems reasonable. This could provide some simple checks and simply pass thru the data (and be called by the other internal routines). Normally the user need not concern themselves with the internal repr. Since you really really want to, then you need to be cognizant of this.\n\nAll that said, I am still not sure why you don't just create a frame exactly like you want. Then grab the block pointers and change the values. It costs the same memory, and as @bashtage points out this is pretty cheap to create essentially a null frame (that has all of the dtype,index,columns) already set.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69460991",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69460991",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69460991,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYwOTkx",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:12:37Z",
    "updated_at": "2015-01-10T16:12:37Z",
    "author_association": "NONE",
    "body": "Not sure what you mean by the empty constructor, but if you mean constructing a dataframe with no rows and the desired schema and calling reindex, this is the same amount of time as creating with copy=True. \n\nYour second proposal is reasonable, but only if you can figure out how to do Categoricals. On that subject, I was going through the code and I realized that Categoricals are non-consolidatable. So on a hunch, I created an integer array and two categorical Series, I then created three DataFrames, and concatenated all three. Sure enough, it did not perform a copy even though two of the DataFrames had the same dtype. I will try to see how to get this to work for Datetime Index.\n\n@jreback I still do not follow what you mean by create the frame exactly like you want.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69461144",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69461144",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69461144,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYxMTQ0",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:16:25Z",
    "updated_at": "2015-01-10T16:16:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "@quicknir why don't you show a code/pseudo-code sample of what you are actually trying to do. \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69461541",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69461541",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69461541,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYxNTQx",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:26:44Z",
    "updated_at": "2015-01-10T16:26:58Z",
    "author_association": "NONE",
    "body": "```\ndef read_dataframe(filename, ....):\n   f = my_library.open(filename)\n   schema = f.schema()\n   row_count = f.row_count()\n   df = pd.DataFrame.from_empty(schema, row_count)\n   dict_of_np_arrays = get_np_arrays_from_DataFrame(df)\n   f.read(dict_of_np_arrays)\n   return df\n```\n\nThe code previous was constructing a dictionary of numpy arrays first, and then constructing a DataFrame from that because it was copying everything. About half the time was being spent on that. So I am trying to change it to this scheme. The thing is, that constructing df as above even when you don't care about the contents is extremely expensive. \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69461727",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69461727",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69461727,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYxNzI3",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:31:48Z",
    "updated_at": "2015-01-10T16:32:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "@quicknir dict of np arrays requires lots of copying.\n\nYou should simply do this:\n\n```\n# construct your biggest block type (e.g. say you have mostly floats)\ndf = DataFrame(np.empty((....)),index=....,columns=....)\n\n# then add in other things you need (say strings)\ndf['foo'] = np.empty(.....)\n\n# say ints\ndf['foo2'] = np.empty(...)\n\n```\n\nif you do this by dtype it will be cheap\n\nthen.\n\n```\nfor dtype, block in df.as_blocks():\n    # fill the values\n    block.values[0,0] = 1\n```\n\nas these block values are views into numpy arrays\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69462022",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69462022",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69462022,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDYyMDIy",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T16:41:20Z",
    "updated_at": "2015-01-10T16:41:20Z",
    "author_association": "NONE",
    "body": "The composition of types isn't known in advance in general, and in the most common use case there is a healthy mix of floats and ints. I guess I don't follow how this will be cheap, if I have 30 float columns and 10 int columns, then yes, the floats will be very cheap. But when you do the ints, unless there is some way to do them all at once that I'm missing, each time you add one more column of ints it will cause the entire int block to be reallocated.\n\nThe solution you gave me previously is close to working, I can't seem to make it work out for DatetimeIndex.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69465869",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69465869",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69465869,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDY1ODY5",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T18:19:46Z",
    "updated_at": "2015-01-10T18:19:46Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Not sure what you mean by the empty constructor, but if you mean constructing a dataframe with no rows and the desired schema and calling reindex, this is the same amount of time as creating with copy=True.\n\nAn empty constructor would look like\n\n``` python\ndtype=np.dtype([('a', np.float64), ('b', np.int64), ('c', np.float32)])\ndf = pd.DataFrame(columns='abc',index=np.arange(100),dtype=dtype)\n```\n\nThis would produce the same output as \n\n``` python\ndtype=np.dtype([('a', np.float64), ('b', np.int64), ('c', np.float32)])\narr = np.empty(100, dtype=dtype)\ndf = pd.DataFrame.from_records(arr, index=np.arange(100))\n```\n\nonly it wouldn't copy data.\n\nBasically the constructor would allow for a mixed dtype for the following call which works but only a single basic dtype.\n\n``` python\ndf = pd.DataFrame(columns=['a','b','c'],index=np.arange(100), dtype=np.float32)\n```\n\nThe only other _feature_ would be to prevent it from null-filling int arrays which has the side effect of converting them to object dtype since there is no missing value for ints.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69466193",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69466193",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69466193,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDY2MTkz",
    "user": {
      "login": "bashtage",
      "id": 5585221,
      "node_id": "MDQ6VXNlcjU1ODUyMjE=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/5585221?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bashtage",
      "html_url": "https://github.com/bashtage",
      "followers_url": "https://api.github.com/users/bashtage/followers",
      "following_url": "https://api.github.com/users/bashtage/following{/other_user}",
      "gists_url": "https://api.github.com/users/bashtage/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bashtage/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bashtage/subscriptions",
      "organizations_url": "https://api.github.com/users/bashtage/orgs",
      "repos_url": "https://api.github.com/users/bashtage/repos",
      "events_url": "https://api.github.com/users/bashtage/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bashtage/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T18:27:44Z",
    "updated_at": "2015-01-10T18:27:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Your second proposal is reasonable, but only if you can figure out how to do Categoricals. On that subject, I was going through the code and I realized that Categoricals are non-consolidatable. So on a hunch, I created an integer array and two categorical Series, I then created three DataFrames, and concatenated all three. Sure enough, it did not perform a copy even though two of the DataFrames had the same dtype. I will try to see how to get this to work for Datetime Index.\n\nThe `from_block` method would have to know the rules of consolidation, so that it would allow multiple categoricals, but only one of other basic types. \n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69466235",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69466235",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69466235,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NDY2MjM1",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-10T18:29:05Z",
    "updated_at": "2015-01-10T18:29:05Z",
    "author_association": "CONTRIBUTOR",
    "body": "yep...this is not that difficult to do....looking for someone who wants to have a gentle introduction to the internals..... hint.hint.hint.... :)\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/69767458",
    "html_url": "https://github.com/pandas-dev/pandas/issues/9216#issuecomment-69767458",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/9216",
    "id": 69767458,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5NzY3NDU4",
    "user": {
      "login": "quicknir",
      "id": 10457096,
      "node_id": "MDQ6VXNlcjEwNDU3MDk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10457096?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/quicknir",
      "html_url": "https://github.com/quicknir",
      "followers_url": "https://api.github.com/users/quicknir/followers",
      "following_url": "https://api.github.com/users/quicknir/following{/other_user}",
      "gists_url": "https://api.github.com/users/quicknir/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/quicknir/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/quicknir/subscriptions",
      "organizations_url": "https://api.github.com/users/quicknir/orgs",
      "repos_url": "https://api.github.com/users/quicknir/repos",
      "events_url": "https://api.github.com/users/quicknir/events{/privacy}",
      "received_events_url": "https://api.github.com/users/quicknir/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-13T16:00:43Z",
    "updated_at": "2015-01-13T16:00:43Z",
    "author_association": "NONE",
    "body": "Haha, I am willing to do some implementation work, don't get me wrong. I will try to look at the internals this weekend and get a sense of which constructor is easier to implement. First though I need to deal with some DatetimeIndex issues I'm having in a separate thread.\n"
  }
]
