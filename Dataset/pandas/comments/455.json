[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3059035",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3059035",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3059035,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNTkwMzU=",
    "user": {
      "login": "lodagro",
      "id": 1094464,
      "node_id": "MDQ6VXNlcjEwOTQ0NjQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1094464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/lodagro",
      "html_url": "https://github.com/lodagro",
      "followers_url": "https://api.github.com/users/lodagro/followers",
      "following_url": "https://api.github.com/users/lodagro/following{/other_user}",
      "gists_url": "https://api.github.com/users/lodagro/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/lodagro/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/lodagro/subscriptions",
      "organizations_url": "https://api.github.com/users/lodagro/orgs",
      "repos_url": "https://api.github.com/users/lodagro/repos",
      "events_url": "https://api.github.com/users/lodagro/events{/privacy}",
      "received_events_url": "https://api.github.com/users/lodagro/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-08T07:55:36Z",
    "updated_at": "2011-12-08T07:55:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "Duality between _key_ and _number_, is a difficult thing. The idea is clear of course, but i feel somehow this will be a source of bugs in application code using pandas. It would be good to have a way to enforce accessing by _key_ or _number_. You had the idea to create a specific object for this (cfr passing levels by _key_ and _number_ to `df.groupby(level=...)`. This could work here to `df.xs(Number(247))`, but that is not really easier/shorter than  `df.xs(df.index[247])`.\n\nMaybe `df.xsn(number)` and `dfxsk(key)`?\nBut than how to do this for all the other methods, does not seem a good idea to duplicate them all. Furthermore duplication does not offer solution when more than one argument can refer to something by _key_ or _number_.\n\n<table>\n  <tr><th>method</th><th>key</th><th>number</th></tr>\n  <tr><td>df[]</td><td>Yes</td><td>No</td></tr>\n  <tr><td>df.ix[]</td><td>Yes</td><td>Yes</td></tr>\n  <tr><td>df.xs()</td><td>Yes</td><td>No</td></tr>\n  <tr><td>df.drop()</td><td>Yes</td><td>No</td></tr>\n  <tr><td>df.stack()</td><td>Yes</td><td>Yes</td></tr>\n  <tr><td>df.unstack()</td><td>Yes</td><td>Yes</td></tr>\n</table>\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3203355",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3203355",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3203355,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDMzNTU=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T13:58:07Z",
    "updated_at": "2011-12-19T13:58:07Z",
    "author_association": "CONTRIBUTOR",
    "body": "I also needed a lot of trial&error to find out what I get when I call the various slicing/ix/xs/... methods. Something like \nselect_rows() and select_columns() (with arguments like number=[...](or using slice notation), keys=[key, key2, key3]) is maybe not as short as the is/xs notations, but for a beginner coming from R (and using pandas not as time series and so (still) having no idea what ix/xs stands for) they would be more consistent.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3204290",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3204290",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3204290,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDQyOTA=",
    "user": {
      "login": "wesm",
      "id": 329591,
      "node_id": "MDQ6VXNlcjMyOTU5MQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/329591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wesm",
      "html_url": "https://github.com/wesm",
      "followers_url": "https://api.github.com/users/wesm/followers",
      "following_url": "https://api.github.com/users/wesm/following{/other_user}",
      "gists_url": "https://api.github.com/users/wesm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wesm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wesm/subscriptions",
      "organizations_url": "https://api.github.com/users/wesm/orgs",
      "repos_url": "https://api.github.com/users/wesm/repos",
      "events_url": "https://api.github.com/users/wesm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wesm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T15:19:47Z",
    "updated_at": "2011-12-19T15:19:47Z",
    "author_association": "MEMBER",
    "body": "I'll think a bit about this. There _is_ a lot of documentation on pandas.sourceforge.net about these methods.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3207222",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3207222",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3207222,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDcyMjI=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T18:25:30Z",
    "updated_at": "2011-12-19T18:53:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "First of all, I'm a beginner of python and only learned a little R beforehand. I did know list-slices, but for example not \"double slices\".\n\nIn the documentation (PDF, chapter 4.2.2), the \"double slices\" methods are not introduced and are (as far as I know) the only method to select multiple columns: df.ix[:,1:] worked for what I wanted: a dataframe of just certain non-string columns to ask for .corr(). \n\nHere are some examples of what I just now (re-)tried and tested to get to know the \"selecting\" mechanism:\ndf.ix[1] -> Series of one row\ndf.ix[1:1] -> DF of one(!) row (not in doc 4.2.2) (Bug -> should contain zero elements?)\ndf[\"name\"] -> Series of one column\ndf[1:2] -> DF of one row(!) -> does not fit to the df[\"name\"] which selects a column\ndf[1:1] -> error (???)\ndf[1] -> error -> should be first column (from \"name\")  or row (from slice) as a Series?\ndf[[\"name\"]] -> DF of one column (not in 4.2.2, but 6.1.7)\ndf[[\"name\", \"var2\"]] -> DF of two columns (not in 4.2.2, but 6.1.7)\ndf[:,0:1] -> error, would have expected a DF of first column\ndf[0,0] -> error, would have expected the value of the first (0,0) cell\ndf[0,\"name\"] -> error, would have expected the value of the (0-row, \"name\"-column) cell\ndf.ix[:,1:1] -> empty DF\ndf.ix[:,1:2] -> DF of one column\n\nAll in all, that's a little too much black magic and too much surprise for me. Why is there actually a difference between df[...] and df.ix[]? I think for beginners (of python or pandas dataframe) it would be helpful if the selecting could be more consistent. \n\ndf.rows[arg] -> returns df (arg is slice or list) or row as a Series (number/key)\ndf.columns[arg] -> returns df (slice/list) or column as a Series (number/key)\ndf.data[arg, arg] -> return df (both slices/lists) or series (slice/list+number/key) or one value (both number/key); omitting the second arg implies 'every column' (:)\n\nSome ideas for the int-as-key problem (brainstorming :-) ):\n- you can't have integer keys, they get casted to strings or throw an Exception (probably cleanest solution?)\n- []'ing with integer-args uses row/column numbers, you need to call a method for int-keys (df.rows_by_key(...))\n- single values are always keys, only when there is no explicit defined key and the argument is an int, it's used as a row/column number. If keys are in int (and row/col-number != key), you need to use slices or a method (df.row_by_number())\n- different \"entrypoints\" for different args: df.by_number[] df.by_key[]\n\n[edited: updated doc references, df.data[] instead of df[] in examples]\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3207457",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3207457",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3207457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDc0NTc=",
    "user": {
      "login": "wesm",
      "id": 329591,
      "node_id": "MDQ6VXNlcjMyOTU5MQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/329591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wesm",
      "html_url": "https://github.com/wesm",
      "followers_url": "https://api.github.com/users/wesm/followers",
      "following_url": "https://api.github.com/users/wesm/following{/other_user}",
      "gists_url": "https://api.github.com/users/wesm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wesm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wesm/subscriptions",
      "organizations_url": "https://api.github.com/users/wesm/orgs",
      "repos_url": "https://api.github.com/users/wesm/repos",
      "events_url": "https://api.github.com/users/wesm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wesm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T18:42:23Z",
    "updated_at": "2011-12-19T18:44:21Z",
    "author_association": "MEMBER",
    "body": "Well, as far as making any major departures from the current API design, I can say that \"that ship has sailed\", and long ago. There's far too much production code relying on the way things currently work to make major changes. \n\nThe idea behind DataFrame indexing was to make it a dict-like structure, first and foremost, as a collection of Series objects. So\n\n```\ndf[key] -> Series\n```\n\nis the natural `__getitem__` behavior for a dict-like structure-- the columns are the keys, and the Series the values. Slicing via `__getitem__`, e.g. `df[:5]` is provided solely as a convenience. Selecting multiple columns like `df[['a', 'b', 'c']]` was added very recently as an alternative to either\n\n```\ndf.ix[:, ['a', 'b', 'c']]\ndf.reindex(columns=['a', 'b', 'c'])\n```\n\nIt used to be that `reindex` was the main way to select rows and columns by label, but this summer I gave in to requests and added the `ix` operator which treats the DataFrame like a NumPy ndarray, but allowing indexing with labels, too. See for example http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html . If you had used NumPy a bit more the \"double slicing\" as you call it would have been very familiar :) (on the front page of the docs I say that I assume general familiarity with NumPy)\n\nThe challenge in indexing with integer labels is the ambiguity problem. In a near release I'm going to disable position-based indexing with integer labels altogether to address this and #328. So when you do something like:\n\n```\ndf.ix['a':'a']\n```\n\nif `a` is in `df.index`, the only sensible result is a DataFrame with one row (the slice endpoints must be inclusive). So you got a slightly confusing result in your case because your row labels were integers. If you do something like `df.ix[date1:date2]` the result is very natural.\n\nBasically, loading up everything in `df[]` isn't going to happen-- that's what `ix` is for, `df[]` is reserved for dict-like indexing and column access, with the legacy syntactic conveniences of being able to do `df[:5]` or `df[boolean_vector]` to select rows. If I could remove those and force everyone to use `.ix` for that behavior, I would, but it would be a too-burdensome API change. The extra confusion you mention has to do with label-based indexing and slicing with integer labels, which is a feature not present in R.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3207532",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3207532",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3207532,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMDc1MzI=",
    "user": {
      "login": "wesm",
      "id": 329591,
      "node_id": "MDQ6VXNlcjMyOTU5MQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/329591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wesm",
      "html_url": "https://github.com/wesm",
      "followers_url": "https://api.github.com/users/wesm/followers",
      "following_url": "https://api.github.com/users/wesm/following{/other_user}",
      "gists_url": "https://api.github.com/users/wesm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wesm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wesm/subscriptions",
      "organizations_url": "https://api.github.com/users/wesm/orgs",
      "repos_url": "https://api.github.com/users/wesm/repos",
      "events_url": "https://api.github.com/users/wesm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wesm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T18:48:07Z",
    "updated_at": "2011-12-19T18:48:13Z",
    "author_association": "MEMBER",
    "body": "I do think that having very explicit \"by label\" vs. \"by integer location\" functions makes sense. For example the `xs` function (cross-section) is label-only. So having an `xsi` function or something like that (whatever I decide to call it) would be a good solution\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3210439",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3210439",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3210439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTA0Mzk=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T22:03:51Z",
    "updated_at": "2011-12-19T22:03:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "Actually I can see where my problems come from: I see a dataframe as \"rows of cases\" (questionnaires -> cases in rows, variables in columns) and not \"(time) series\". So \"cross sections\" are in my case a complete dataframe. \n\nI think when pandas gets included in statsmodel (and statsmodel gets a formula interface like R), lots of newbies will have similar problems and questions as I had/have... :-)\n\nRe: \"the slice endpoints must be inclusive\" -> why? Coming from normal python slices this is confusing :-) Even with dates it makes more sense for me that df.ix[date1:date1] is empty. \n\nThis is for example very confusing:\n\n``` python\ndf = DataFrame({0:[1,2], 1:[3,4]})\ndf.ix[0:1,0:1]\n   0  1\n0  1  3\n1  2  4\ndf = DataFrame({\"one\":[1,2], \"two\":[3,4]})\ndf.ix[0:1,0:1]\n   one\n0  1  \n1  2  \ndf = DataFrame({\"one\":[1,2], \"two\":[3,4]}, index=[\"one\", \"two\"])\ndf.ix[0:1,0:1]\n     one\none  1  \ndf = DataFrame(zip(*[[1,2],[3,4]]), columns=[\"one\", \"two\"], index=[1,2])\ndf.ix[0:1,0:1]\n   one\n1  1\n```\n\n-> When the slice is of the keys(index?) then its \"including endpoints\" and when it's row-/column-numbers, it's \"excluding endpoints\" (python-like)?\n\n``` python\ndf2 = DataFrame(zip(*[[1,2,3],[4,5,6], [7,8,9]]), columns=[\"zero\", 1, \"two\"], index=[1,\"two\", 5])\ndf2.ix[2:3,1:2] # ok, no keys in index, so only use \"python slicing\"\n   1\n5  6\ndf2 = DataFrame(zip(*[[1,2,3],[4,5,6], [7,8,9]]), columns=[\"zero\", 1, \"two\"], index=[1,\"two\", 3])\ndf2.ix[2:3,1:2] # but why include the row \"two\"?\n     1\ntwo  5\n3    6\ndf2.ix[\"one\":3,1:2] # Again, why is row \"two\" included?\n     1\ntwo  5  \n3    6 \ndf2.ix[\"two\":\"three\",1:2] # and why is this now empty?\nEmpty DataFrame\nColumns: Index([1], dtype=object)\nIndex: Index([], dtype=object) \n```\n\nRe: 'df.ix is the new API': fair enough, I will try to get familiar with that :-)\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3210707",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3210707",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3210707,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMyMTA3MDc=",
    "user": {
      "login": "wesm",
      "id": 329591,
      "node_id": "MDQ6VXNlcjMyOTU5MQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/329591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wesm",
      "html_url": "https://github.com/wesm",
      "followers_url": "https://api.github.com/users/wesm/followers",
      "following_url": "https://api.github.com/users/wesm/following{/other_user}",
      "gists_url": "https://api.github.com/users/wesm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wesm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wesm/subscriptions",
      "organizations_url": "https://api.github.com/users/wesm/orgs",
      "repos_url": "https://api.github.com/users/wesm/repos",
      "events_url": "https://api.github.com/users/wesm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wesm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2011-12-19T22:24:45Z",
    "updated_at": "2011-12-19T22:24:45Z",
    "author_association": "MEMBER",
    "body": "Re: inclusion of endpoints, what do you do with data without any kind of strict ordering? Or suppose that you do in fact want the data from start date to end date, inclusive, but start date == end date, what do you do then? From an API perspective it starts to get thorny extremely quickly, like:\n\n```\nstart = end = some_date\ndf.ix[start : ???]\n```\n\nOr suppose you're just indexed by some strings with an order that is meaningful in context but not ordered in the sorted sense:\n\n```\nIn [2]: s = Series(np.random.randn(5), index=['z', 'd', 'a', 'c', 'f'])\n\nIn [3]: s\nOut[3]: \nz    0.1985\nd    0.5749\na    -2.06\nc    -0.4051\nf    0.6808\n\nIn [4]: s.ix['d':'c']\nOut[4]: \nd    0.5749\na    -2.06\nc    -0.4051\n```\n\nAllowing integer labels make life very unpleasant and this is the result :) At the Datarray summit earlier this year (http://inscight.org/2011/05/18/episode_13/) we literally spent an hour or two talking about what to do about integer labels. My personal view (like most Pythonistas) is that \"practical beats purity\"-- I am not willing to sacrifice the usability of the library to meet purity standards regarding indexing with integer labels. That was what I thought while implementing it, anyway :) \n\nSome of those last examples look buggy. I'll turn them into bug reports and figure out what's going on\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3397610",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3397610",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3397610,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMzOTc2MTA=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-01-07T19:28:53Z",
    "updated_at": "2012-01-07T19:28:53Z",
    "author_association": "CONTRIBUTOR",
    "body": "I tried to understand the podcast but was out quite quickly... Seems like tricky topic... \n\nFrom my experience it would be nice to separate the two different behaviors quite cleanly so that there is no surprise for the user:\n\n```\ndf.by_index[...,...] # normal python, only for integer arguments, \n                     # using any other argument results in an error\ndf.ix[...,...] # (or df.by_label[...])-> current indexing behavior \n               # (include both endpoints), using integers is only \n               # working if the label is an integer\n```\n\nSo in the above example the \n\n```\ndf = DataFrame({\"one\":[1,2], \"two\":[3,4]})\ndf.ix[0:1,0:1]\n```\n\nwill error (or return nothing) because one index is not integer.\n\nFor the API: isn't such a thing possible in python:\n\n```\nfrom pandas.future import clean_integer_index # in user code\n```\n\nand then in your slicing code:\n\n``` python\nif clean_integer_index:\n    raise Error()\nelse:\n    print(\"using integer slices with non integer index is depricated\")\n```\n\nAnyway, thanks for the discussion, it made me realize that there are some differences to R's dataframe :-) Especially the different axes \"thinking\" (pandas: time x cases x variable, R: cases x variable x time) is confusing when you think (and use) a dataframe as \"cases x variables\" -> xs (if that stands for cross sections) as a name on panels makes then no sense.\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/3578834",
    "html_url": "https://github.com/pandas-dev/pandas/issues/455#issuecomment-3578834",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/455",
    "id": 3578834,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM1Nzg4MzQ=",
    "user": {
      "login": "wesm",
      "id": 329591,
      "node_id": "MDQ6VXNlcjMyOTU5MQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/329591?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/wesm",
      "html_url": "https://github.com/wesm",
      "followers_url": "https://api.github.com/users/wesm/followers",
      "following_url": "https://api.github.com/users/wesm/following{/other_user}",
      "gists_url": "https://api.github.com/users/wesm/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/wesm/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/wesm/subscriptions",
      "organizations_url": "https://api.github.com/users/wesm/orgs",
      "repos_url": "https://api.github.com/users/wesm/repos",
      "events_url": "https://api.github.com/users/wesm/events{/privacy}",
      "received_events_url": "https://api.github.com/users/wesm/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-01-20T03:53:49Z",
    "updated_at": "2012-01-20T03:53:49Z",
    "author_association": "MEMBER",
    "body": "I added some API functions `irow`, `icol` and `iget_value` to DataFrame for consistent integer-based row and column access for 0.7.0. see docs / what's new once i get the release out (or feel free to rtfs ;) \n"
  }
]
