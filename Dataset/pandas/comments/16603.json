[
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/306343365",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-306343365",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 306343365,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMwNjM0MzM2NQ==",
    "user": {
      "login": "jreback",
      "id": 953992,
      "node_id": "MDQ6VXNlcjk1Mzk5Mg==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/953992?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jreback",
      "html_url": "https://github.com/jreback",
      "followers_url": "https://api.github.com/users/jreback/followers",
      "following_url": "https://api.github.com/users/jreback/following{/other_user}",
      "gists_url": "https://api.github.com/users/jreback/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jreback/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jreback/subscriptions",
      "organizations_url": "https://api.github.com/users/jreback/orgs",
      "repos_url": "https://api.github.com/users/jreback/repos",
      "events_url": "https://api.github.com/users/jreback/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jreback/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-06-05T23:58:00Z",
    "updated_at": "2017-06-05T23:58:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "yes that sounds right\r\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348982650",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-348982650",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 348982650,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODk4MjY1MA==",
    "user": {
      "login": "naure",
      "id": 8718243,
      "node_id": "MDQ6VXNlcjg3MTgyNDM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8718243?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naure",
      "html_url": "https://github.com/naure",
      "followers_url": "https://api.github.com/users/naure/followers",
      "following_url": "https://api.github.com/users/naure/following{/other_user}",
      "gists_url": "https://api.github.com/users/naure/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naure/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naure/subscriptions",
      "organizations_url": "https://api.github.com/users/naure/orgs",
      "repos_url": "https://api.github.com/users/naure/repos",
      "events_url": "https://api.github.com/users/naure/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naure/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T14:46:03Z",
    "updated_at": "2017-12-04T14:48:42Z",
    "author_association": "NONE",
    "body": "Joining is broken because of this. This randomly broke a real world script depending on input data. Real headache to troubleshoot!\r\n\r\nTest case:\r\n\r\n```\r\n# Same categories but in different order\r\nXi = pd.Categorical([\"A\"], categories=[\"A\", \"B\"])\r\nYi = pd.Categorical([\"B\"], categories=[\"B\", \"A\"])\r\n\r\nx = pd.DataFrame(1, columns=[\"x\"], index=Xi)\r\nassert \"B\" not in x.index\r\ny = pd.DataFrame(2, columns=[\"y\"], index=Yi)\r\nassert \"B\" in y.index\r\n\r\nxy = x.join(y, how=\"inner\")\r\n\r\nprint(x)\r\nprint(y)\r\nprint(\"Incorrect join:\")\r\nprint(xy)\r\n\r\n# It used the codes instead of the labels\r\nassert x.index.codes == y.index.codes == xy.index.codes == [0]\r\n\r\nassert len(xy) == 0, \"Should be empty\"  # Broken\r\nassert \"B\" not in xy.index              # Broken\r\nassert \"B\" not in xy                    # Actually passes somehow\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n   x\r\nA  1\r\n\r\n   y\r\nB  2\r\n\r\nIncorrect join:\r\n   x  y\r\nB  1  2\r\n\r\n---------------------------------------------------------------------------\r\nAssertionError                            Traceback (most recent call last)\r\n<ipython-input-690-c66e71d6d8ba> in <module>()\r\n     18 assert x.index.codes == y.index.codes == xy.index.codes == [0]\r\n     19 \r\n---> 20 assert len(xy) == 0, \"Should be empty\"  # Broken\r\n     21 assert \"B\" not in xy.index              # Broken\r\n     22 assert \"B\" not in xy                    # Actually passes somehow\r\n\r\nAssertionError: Should be empty\r\n```\r\n\r\n\r\npd.show_versions()\r\n<details>\r\nINSTALLED VERSIONS\r\n------------------\r\ncommit: None\r\npython: 3.5.3.final.0\r\npython-bits: 64\r\nOS: Linux\r\nOS-release: 4.10.0-33-generic\r\nmachine: x86_64\r\nprocessor: x86_64\r\nbyteorder: little\r\nLC_ALL: en_US.UTF-8\r\nLANG: en_US.UTF-8\r\nLOCALE: en_US.UTF-8\r\n\r\npandas: 0.21.0\r\npytest: None\r\npip: 9.0.1\r\nsetuptools: 36.0.1\r\nCython: None\r\nnumpy: 1.13.3\r\nscipy: 1.0.0\r\npyarrow: None\r\nxarray: None\r\nIPython: 6.1.0\r\nsphinx: None\r\npatsy: None\r\ndateutil: 2.6.1\r\npytz: 2017.3\r\nblosc: None\r\nbottleneck: 1.2.1\r\ntables: 3.4.2\r\nnumexpr: 2.6.2\r\nfeather: None\r\nmatplotlib: 2.0.2\r\nopenpyxl: None\r\nxlrd: None\r\nxlwt: None\r\nxlsxwriter: None\r\nlxml: None\r\nbs4: None\r\nhtml5lib: 0.999999999\r\nsqlalchemy: None\r\npymysql: None\r\npsycopg2: None\r\njinja2: 2.9.6\r\ns3fs: None\r\nfastparquet: None\r\npandas_gbq: None\r\npandas_datareader: None\r\n</details>"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348983510",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-348983510",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 348983510,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODk4MzUxMA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T14:48:42Z",
    "updated_at": "2017-12-04T14:48:42Z",
    "author_association": "CONTRIBUTOR",
    "body": "@naure do you have time to submit a PR fixing this? I haven't had a chance,\nand won't for a little while yet.\n\nOn Mon, Dec 4, 2017 at 8:46 AM, naure <notifications@github.com> wrote:\n\n> Joining is broken because of this. This randomly broke a real world script\n> depending on input data. Real headache to troubleshoot!\n>\n> Test case:\n>\n> # Same categories but in different order\n> Xi = pd.Categorical([\"A\"], categories=[\"A\", \"B\"])\n> Yi = pd.Categorical([\"B\"], categories=[\"B\", \"A\"])\n>\n> x = pd.DataFrame(1, columns=[\"x\"], index=Xi)\n> assert \"B\" not in x.index\n> y = pd.DataFrame(2, columns=[\"y\"], index=Yi)\n> assert \"B\" in y.index\n>\n> xy = x.join(y, how=\"inner\")\n>\n> print(x)\n> print(y)\n> print(\"Incorrect join:\")\n> print(xy)\n>\n> # It used the codes instead of the labels\n> assert x.index.codes == y.index.codes == xy.index.codes == [0]\n>\n> assert len(xy) == 0, \"Should be empty\"  # Broken\n> assert \"B\" not in xy.index              # Broken\n> assert \"B\" not in xy                    # Actually passes somehow\n>\n> Output:\n>\n>    x\n> A  1\n>\n>    y\n> B  2\n>\n> Incorrect join:\n>    x  y\n> B  1  2\n>\n> ---------------------------------------------------------------------------\n> AssertionError                            Traceback (most recent call last)\n> <ipython-input-690-c66e71d6d8ba> in <module>()\n>      18 assert x.index.codes == y.index.codes == xy.index.codes == [0]\n>      19\n> ---> 20 assert len(xy) == 0, \"Should be empty\"  # Broken\n>      21 assert \"B\" not in xy.index              # Broken\n>      22 assert \"B\" not in xy                    # Actually passes somehow\n>\n> AssertionError: Should be empty\n>\n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/pandas-dev/pandas/issues/16603#issuecomment-348982650>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABQHInR9ZCKhWKkRPYWU7TDF3Ofnd22bks5s9AWzgaJpZM4NwHJG>\n> .\n>\n"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348989520",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-348989520",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 348989520,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODk4OTUyMA==",
    "user": {
      "login": "naure",
      "id": 8718243,
      "node_id": "MDQ6VXNlcjg3MTgyNDM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8718243?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naure",
      "html_url": "https://github.com/naure",
      "followers_url": "https://api.github.com/users/naure/followers",
      "following_url": "https://api.github.com/users/naure/following{/other_user}",
      "gists_url": "https://api.github.com/users/naure/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naure/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naure/subscriptions",
      "organizations_url": "https://api.github.com/users/naure/orgs",
      "repos_url": "https://api.github.com/users/naure/repos",
      "events_url": "https://api.github.com/users/naure/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naure/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T15:08:06Z",
    "updated_at": "2017-12-04T15:08:06Z",
    "author_association": "NONE",
    "body": "I can have a look, where to start?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/348991495",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-348991495",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 348991495,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0ODk5MTQ5NQ==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-04T15:14:38Z",
    "updated_at": "2017-12-04T15:14:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks. CategoricalIndex is defined at https://github.com/pandas-dev/pandas/blob/master/pandas/core/indexes/category.py. It inherits the `union` / `intersection` methods from `Index`, defined in `indexes/base.py`.\r\n\r\nI apparently started a branch for this, https://github.com/pandas-dev/pandas/compare/master...TomAugspurger:categorical-index-set-ops. I can't recall what was broken, but I suspect it was the set-ops issues with duplicates in https://github.com/pandas-dev/pandas/issues/13432\r\n\r\nThe basic idea in that branch was to override the set ops methods for `CategoricalIndex` with versions that do the regular set-ops *on the codes*. And then we construct a new CategoricalIndex based on the codes. Feel free to pick that up, or start fresh and ping if you have issues."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349290078",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-349290078",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 349290078,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTI5MDA3OA==",
    "user": {
      "login": "naure",
      "id": 8718243,
      "node_id": "MDQ6VXNlcjg3MTgyNDM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8718243?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naure",
      "html_url": "https://github.com/naure",
      "followers_url": "https://api.github.com/users/naure/followers",
      "following_url": "https://api.github.com/users/naure/following{/other_user}",
      "gists_url": "https://api.github.com/users/naure/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naure/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naure/subscriptions",
      "organizations_url": "https://api.github.com/users/naure/orgs",
      "repos_url": "https://api.github.com/users/naure/repos",
      "events_url": "https://api.github.com/users/naure/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naure/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T12:29:11Z",
    "updated_at": "2017-12-05T14:09:14Z",
    "author_association": "NONE",
    "body": "No I think this is actually a regression in equality testing of Categorical, independently of the effort you mentioned. [Commit](https://github.com/pandas-dev/pandas/commit/e57f1894b55ecec3687a4484e119124d32ff942b?diff=split#diff-d295fd3c83b52dcaabdf13701ead1a41L2001). It's not clear whether it should ultimately be equal or not, but if it does, that breaks a number of operations.\r\n\r\nHere is a monkey-patch for anyone who needs it safely working regardless of version.\r\nThis restores the behaviour of 0.20.1 regarding equality of Categorical and CategoricalIndex.\r\nconcat() & co will return regular Index and Series if categories are different in any way.\r\n\r\n```\r\nimport pandas as pd\r\n\r\ndef Categorical_is_dtype_equal(self, other):\r\n    \"\"\"\r\n    Returns True if categoricals are the same dtype\r\n      same categories, and same ordered\r\n\r\n    Parameters\r\n    ----------\r\n    other : Categorical\r\n\r\n    Returns\r\n    -------\r\n    are_equal : boolean\r\n    \"\"\"\r\n\r\n    try:\r\n        return (self.categories.equals(other.categories) and\r\n                self.ordered == other.ordered)\r\n    except (AttributeError, TypeError):\r\n        return False\r\n\r\npd.core.categorical.Categorical.is_dtype_equal = Categorical_is_dtype_equal\r\n```\r\n\r\nTest:\r\n```\r\n# Same categories but in different order\r\nXi = pd.Categorical([\"A\"], categories=[\"A\", \"B\"])\r\nYi = pd.Categorical([\"B\"], categories=[\"B\", \"A\"])\r\nassert not Xi.equals(Yi)\r\n\r\nx = pd.DataFrame(1, columns=[\"x\"], index=Xi)\r\ny = pd.DataFrame(2, columns=[\"y\"], index=Yi)\r\nassert not x.index.equals(y.index)\r\n\r\nxy = x.join(y, how=\"inner\")\r\nassert len(xy) == 0, \"Inner join should be empty\"\r\n```\r\n\r\n@TomAugspurger Would like this as a PR?"
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349292820",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-349292820",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 349292820,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTI5MjgyMA==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T12:41:26Z",
    "updated_at": "2017-12-05T12:41:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "> No I think this is actually a regression in equality testing of Categorical, independently of the effort you mentioned.\r\n\r\nWhy do you say that?\r\n\r\n> It's not clear whether it should ultimately be equal or not, but if it does, that breaks a number of operations.\r\n\r\nWhat is \"it\" in this case that's being compared?\r\n\r\nThat equality you linked to is on the CategoricalDtype, whose equality semantics are a bit strange especially around empty Categoricals."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349315708",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-349315708",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 349315708,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTMxNTcwOA==",
    "user": {
      "login": "naure",
      "id": 8718243,
      "node_id": "MDQ6VXNlcjg3MTgyNDM=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/8718243?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naure",
      "html_url": "https://github.com/naure",
      "followers_url": "https://api.github.com/users/naure/followers",
      "following_url": "https://api.github.com/users/naure/following{/other_user}",
      "gists_url": "https://api.github.com/users/naure/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naure/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naure/subscriptions",
      "organizations_url": "https://api.github.com/users/naure/orgs",
      "repos_url": "https://api.github.com/users/naure/repos",
      "events_url": "https://api.github.com/users/naure/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naure/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T14:13:17Z",
    "updated_at": "2017-12-05T14:13:17Z",
    "author_association": "NONE",
    "body": "Because it used to work in 0.20.1. The root cause is the definition of equality that changed: Xi.equals(Yi).\r\n\r\nStarting with 0.21.0, it returns True, which leads other operations to manipulate raw codes. This gives meaningless results as the categories are different."
  },
  {
    "url": "https://api.github.com/repos/pandas-dev/pandas/issues/comments/349321689",
    "html_url": "https://github.com/pandas-dev/pandas/issues/16603#issuecomment-349321689",
    "issue_url": "https://api.github.com/repos/pandas-dev/pandas/issues/16603",
    "id": 349321689,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM0OTMyMTY4OQ==",
    "user": {
      "login": "TomAugspurger",
      "id": 1312546,
      "node_id": "MDQ6VXNlcjEzMTI1NDY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/1312546?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TomAugspurger",
      "html_url": "https://github.com/TomAugspurger",
      "followers_url": "https://api.github.com/users/TomAugspurger/followers",
      "following_url": "https://api.github.com/users/TomAugspurger/following{/other_user}",
      "gists_url": "https://api.github.com/users/TomAugspurger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TomAugspurger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TomAugspurger/subscriptions",
      "organizations_url": "https://api.github.com/users/TomAugspurger/orgs",
      "repos_url": "https://api.github.com/users/TomAugspurger/repos",
      "events_url": "https://api.github.com/users/TomAugspurger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TomAugspurger/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-12-05T14:34:10Z",
    "updated_at": "2017-12-05T14:35:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "Apologies for my slowness, I was looking at `CategoricalIndex.equals`, not `Categorical.equals`.\r\n\r\nSo, as you say, Categorical.equals should be defined as:\r\n\r\n1. The dtypes are equal (categories match and ordering of categories is unimportant when both are unorderd)\r\n2. The values are equal\r\n\r\nThe issue with the current definition is that it assumes dtype equality implies that mapping between values and codes match, which isn't always true. So I'd propose something like:\r\n\r\n```python\r\nif self.is_dtype_equal(other):\r\n    if self.categories.equals(other.categories):\r\n        # the fast case for codes aligning\r\n        np.array_equal(self._codes, other._codes)\r\n    else:\r\n        # unorded categories with different order\r\n        codes2 = _recode_for_categories(Yi.codes, Yi.categories, Xi.categories)\r\n        return np.array_equal(self._codes, codes2)\r\nreturn False\r\n```\r\n\r\n*then* we should be OK.  I'll submit that as a PR later today, unless you beat me to it :)"
  }
]
