[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/51381276",
    "html_url": "https://github.com/ipython/ipython/issues/6278#issuecomment-51381276",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6278",
    "id": 51381276,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMzgxMjc2",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-08-06T19:04:44Z",
    "updated_at": "2014-08-06T19:04:44Z",
    "author_association": "MEMBER",
    "body": "Setting arbitrary attributes works on functions, but apparently not on methods. Simple fix is just to catch AttributeError and ignore it - it's not essential that the widget be attached to the object. Though maybe it needs to be stored somewhere so it doesn't fall out of scope and get GCed.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/51381671",
    "html_url": "https://github.com/ipython/ipython/issues/6278#issuecomment-51381671",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6278",
    "id": 51381671,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMzgxNjcx",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-08-06T19:07:42Z",
    "updated_at": "2014-08-06T19:07:42Z",
    "author_association": "MEMBER",
    "body": "We just talked about it and I like @minrk's suggestion of wrapping it in a `lambda` if it's a method. That way the behavior from the outside still appears the same, in that we can return a function with those attributes.\n\nPeople may have written code that assumes the widget is attached, so it's best to expose a uniform interface regardless of whether they started with a function or method.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/60197301",
    "html_url": "https://github.com/ipython/ipython/issues/6278#issuecomment-60197301",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6278",
    "id": 60197301,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYwMTk3MzAx",
    "user": {
      "login": "2t7",
      "id": 9021101,
      "node_id": "MDQ6VXNlcjkwMjExMDE=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/9021101?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/2t7",
      "html_url": "https://github.com/2t7",
      "followers_url": "https://api.github.com/users/2t7/followers",
      "following_url": "https://api.github.com/users/2t7/following{/other_user}",
      "gists_url": "https://api.github.com/users/2t7/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/2t7/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/2t7/subscriptions",
      "organizations_url": "https://api.github.com/users/2t7/orgs",
      "repos_url": "https://api.github.com/users/2t7/repos",
      "events_url": "https://api.github.com/users/2t7/events{/privacy}",
      "received_events_url": "https://api.github.com/users/2t7/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-10-23T06:23:23Z",
    "updated_at": "2014-10-25T13:27:20Z",
    "author_association": "NONE",
    "body": "You can achieve it without `lambda` if you use `f.__dict__[\"widget\"]=w`, but this looks very unpythonic (and I did not test it in python3). Also wrapping the method into a `lambda` will not eliminate the problem that no deep copy of the object has been created. If the caller decides to modify the original object then the lambda function will also change its behaviour. So I would come up with one of the following:\n\n```\ndef attach(callab):\n    ''' uses lambda to wrap the method and does not need __dict__'''\n    from copy import deepcopy\n    from inspect import ismethod,isfunction\n    if ismethod(callab):\n        ccallab=deepcopy(callab)\n        f=lambda x: ccallab(x)\n    elif isfunction(callab):\n        f=callab\n    else:\n        raise Exception()\n    f.widget=\"dummy\"\n    return f\n\ndef attach2(callab):\n    ''' uses no lambda to wrap the method but does need __dict__'''\n    from copy import deepcopy\n    from inspect import ismethod,isfunction\n    if ismethod(callab):\n        ccallab=deepcopy(callab)\n        f=ccallab\n    elif isfunction(callab):\n        f=callab\n    else:\n        raise Exception()\n    f.__dict__[\"widget\"]=\"dummy\"\n    return f\n```\n\nEDIT:\nI thought a while about this and making a copy does not seem to be apropriate, my bad. The reason why the `f.widget = w` does not work for methods in the first place is because of its `__setattr__` function which behaves differently than a normal function's `__setattr__` (does not allow for new entries to be created). So circumventing this call by `f.__dict__[\"widget\"]=w` should be fine.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67229777",
    "html_url": "https://github.com/ipython/ipython/issues/6278#issuecomment-67229777",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6278",
    "id": 67229777,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjI5Nzc3",
    "user": {
      "login": "denfromufa",
      "id": 7870949,
      "node_id": "MDQ6VXNlcjc4NzA5NDk=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/7870949?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/denfromufa",
      "html_url": "https://github.com/denfromufa",
      "followers_url": "https://api.github.com/users/denfromufa/followers",
      "following_url": "https://api.github.com/users/denfromufa/following{/other_user}",
      "gists_url": "https://api.github.com/users/denfromufa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/denfromufa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/denfromufa/subscriptions",
      "organizations_url": "https://api.github.com/users/denfromufa/orgs",
      "repos_url": "https://api.github.com/users/denfromufa/repos",
      "events_url": "https://api.github.com/users/denfromufa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/denfromufa/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T20:52:37Z",
    "updated_at": "2014-12-16T20:53:34Z",
    "author_association": "NONE",
    "body": "the workaround I found is wrapping the instance method with a regular function, which has the instance of this object as a global variable and calls the instance method within the function:\n\n```\nclass Tank(object): #our tank object which has volume, accepts intake and outflow\n    def __init__(self,volume):\n        self.volume=self.initvol=volume\n        self.dt=1\n    def flow(self,qin,qout,dt=1):\n        if dt!=self.dt:\n            self.dt=dt\n            self.volume=self.initvol\n        self.volume+=(qin-qout)*dt\n        print self.volume\n        return self.volume\nt=Tank(10)\nprint t.flow(10,20,2)\ndef flow(qin,qout,dt):\n    global t\n    return t.flow(qin,qout,dt)\ninteract(flow,qin=(0,10),qout=(0,10),dt=(0,10)) \n```\n"
  }
]
