[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/15537986",
    "html_url": "https://github.com/ipython/ipython/issues/3092#issuecomment-15537986",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/3092",
    "id": 15537986,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTM3OTg2",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-03-27T17:23:22Z",
    "updated_at": "2013-03-27T17:23:22Z",
    "author_association": "MEMBER",
    "body": "It's an interesting idea - yes, all the machinery is there for any frontend to do different things with the output of kernels.  For instance, one could write a webapp that monitors all stdout from all kernels associated with a given notebook server, or all engines in one (or more) IPython cluster.  I don't know what the UI would be for it in the regular notebook, though.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/15557139",
    "html_url": "https://github.com/ipython/ipython/issues/3092#issuecomment-15557139",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/3092",
    "id": 15557139,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE1NTU3MTM5",
    "user": {
      "login": "davclark",
      "id": 120710,
      "node_id": "MDQ6VXNlcjEyMDcxMA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/120710?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davclark",
      "html_url": "https://github.com/davclark",
      "followers_url": "https://api.github.com/users/davclark/followers",
      "following_url": "https://api.github.com/users/davclark/following{/other_user}",
      "gists_url": "https://api.github.com/users/davclark/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davclark/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davclark/subscriptions",
      "organizations_url": "https://api.github.com/users/davclark/orgs",
      "repos_url": "https://api.github.com/users/davclark/repos",
      "events_url": "https://api.github.com/users/davclark/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davclark/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-03-27T22:25:52Z",
    "updated_at": "2013-03-27T22:25:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "It's probably best to start with use-case.\n\nFor me, I end up in vim if I'm doing something complicated (where complicated might mean something like more than 5 lines of code). I'll be executing this and seeing the results from Vim. But in the end, I want to end up with something in the notebook as a reference to see what ran to produce the results.\n\nSo, the workflow isn't that cumbersome - open a new cell, and copy-paste the code in. But then I need to run it again if I want the output to show (and in some cases that could be very expensive).\n\nThe simplest UI I could imagine is that you could simply have a similar option as in vim: you can turn \"subchannel monitoring\" on, and then things that are executed elsewhere get rendered in the notebook.\n\nI can forsee some difficulties arising around plotting and other activities where output is finessed by the web console. But plotting isn't (usually) that expensive of an operation, so I wouldn't mind if I needed to re-run those cells (which I could do just like with a cell entered directly into the notebook).\n"
  }
]
