[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/405016099",
    "html_url": "https://github.com/ipython/ipython/issues/11228#issuecomment-405016099",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11228",
    "id": 405016099,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTAxNjA5OQ==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-14T11:07:09Z",
    "updated_at": "2018-07-14T11:07:09Z",
    "author_association": "MEMBER",
    "body": "I'm not sure why you're getting an IPython crash message there, but it looks like a problem with Theano."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/405021154",
    "html_url": "https://github.com/ipython/ipython/issues/11228#issuecomment-405021154",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11228",
    "id": 405021154,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTAyMTE1NA==",
    "user": {
      "login": "Peng-Ru",
      "id": 31172620,
      "node_id": "MDQ6VXNlcjMxMTcyNjIw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/31172620?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Peng-Ru",
      "html_url": "https://github.com/Peng-Ru",
      "followers_url": "https://api.github.com/users/Peng-Ru/followers",
      "following_url": "https://api.github.com/users/Peng-Ru/following{/other_user}",
      "gists_url": "https://api.github.com/users/Peng-Ru/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Peng-Ru/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Peng-Ru/subscriptions",
      "organizations_url": "https://api.github.com/users/Peng-Ru/orgs",
      "repos_url": "https://api.github.com/users/Peng-Ru/repos",
      "events_url": "https://api.github.com/users/Peng-Ru/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Peng-Ru/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-14T12:37:39Z",
    "updated_at": "2018-07-14T12:37:39Z",
    "author_association": "NONE",
    "body": "Thank you for your reply, I did encounter the problem in Theano, the main problem is the Scan() operator in Theano, which led to AdvancedBooleanSubtensor.grad illegally returned an integer-valued variable.\r\nHere is the code I have compiled:\r\n\r\n    def _step_slice(m, m_, x_, xx_, h_, ctx_, alpha_, pctx_, cc_,\r\n                            Wc_att, b_att,U, Wc, W_comb_att, U_att, c_tt, Ux, Wcx,\r\n                            U_nl, Ux_nl, b_nl, bx_nl,Wemb_dec):  \r\n\r\n        preact1 = tensor.dot(h_, U)\r\n        preact1 += x_\r\n        preact1 = tensor.nnet.sigmoid(preact1)  \r\n\r\n        r1 = _slice(preact1, 0, dim)\r\n        u1 = _slice(preact1, 1, dim)\r\n\r\n        preactx1 = tensor.dot(h_, Ux)\r\n        preactx1 *= r1\r\n        preactx1 += xx_\r\n\r\n        h1 = tensor.tanh(preactx1)\r\n\r\n        h1 = u1 * h_ + (1. - u1) * h1\r\n        h1 = m_[:, None] * h1 + (1. - m_)[:, None] * h_      # h1 is source hidden state ,batchsize*dim\r\n\r\n        srclen = (context_mask.sum(0, keepdims=True) - 1).T  # context_mask.sum(0,keepdims=True)-1 Corresponding to source sentence length of this batch \r\n        pctx__ = tensor.tanh(tensor.dot(h1, W_comb_att)) \r\n        pctx__ = tensor.dot(pctx__, U_att) + c_tt            # batchsize*1\r\n        pstate_ = srclen * tensor.nnet.sigmoid(pctx__) + 1.  # +1：eos is considered\r\n        srcPositions = tensor.floor(pstate_)                 # batchsize*1\r\n        srcPositions = tensor.cast(srcPositions, dtype='int32')  # srcPosition is index, so shoud cast to int,like 3.6-->3.0\r\n\r\n \r\n        unmaskedId = tensor.flatnonzero(m)  # per timesteps ,take per row element of the source mask matrix  as m ,(batchsize-x)\r\n        srcPositions = srcPositions[unmaskedId, :]  # (batchsize-x)*1\r\n        srclen = srclen[unmaskedId, :]  # (batchsize-x)*1\r\n        startAttnIds = srcPositions - D\r\n        indicesAll = startAttnIds.repeat(numPositions, axis=1)\r\n        indicesAll += tensor.mgrid[0:unmaskedId.shape[0], 0:numPositions][1]  # (batchsize-x)*numPositions\r\n        indicesAll = indicesAll.T.flatten()  # 1*(numPositions*(batchsize-x))\r\n\r\n        includeIds = (indicesAll <= tensor.tile(srclen, [numPositions, 1]).flatten()) & (indicesAll >= 0)  # Delete the source sentence index position centered on pstate_ and the window size D, which exceeds 0 or the maximum length of the sentence\r\n        indicesAll = indicesAll[includeIds]  # dimensional reduction，1*((numPosition*batchsize-x)-y)\r\n        indicesSub = tensor.arange(0, numPositions).repeat(unmaskedId.shape[0])  # Scale-out numPositions times,1*(numPosition*batchsize-x)\r\n        indicesSub = indicesSub[includeIds]  # i1*((numPosition*batchsize-x)-y)\r\n        unmaskedIds = tensor.tile(unmaskedId, numPositions)  # Scale-out numPositions times,，1*(numPosition*batchsize-x)\r\n        unmaskedIds = unmaskedIds[includeIds]  # 1*((numPosition*batchsize-x)-y)\r\n\r\n        srcVecsSub = tensor.zeros([numPositions * n_samples, dim])\r\n        linearIdSub = indicesSub * n_samples + unmaskedIds                # 1*((numPosition*batchsize-x)-y)\r\n        linearIdAll = indicesAll * n_samples + unmaskedIds                # 1*((numPosition*batchsize-x)-y)\r\n        cc_ = tensor.reshape(cc_, [nsteps * n_samples, dim])\r\n        srcVecsSub = tensor.set_subtensor(srcVecsSub[linearIdSub, :],cc_[linearIdAll, :])  # numPositions*n_samples*dim\r\n        srcVecsSub = srcVecsSub.reshape([numPositions, n_samples, dim])  \r\n\r\n        e_ij = tensor.dot(srcVecsSub, Wc_att) + b_att  # equivalent to eq:W_a*hs+b_a,numPositions * batchSize*dim\r\n        e_ij = (h1 * e_ij).sum(2)                      # equivalent to eq:h_t' *(W_a*hs+b_a),numPositions * batchSize\r\n\r\n        scaleX = (indicesAll - tensor.tile(pstate_[unmaskedId], (numPositions, 1)).flatten())/(D/2) #((numPosition*batchsize-x)-y)/batchsize\r\n        distWeights = tensor.zeros([n_samples,numPositions])          # n_samples = batch size\r\n        distWeights = tensor.set_subtensor(distWeights[unmaskedIds,indicesSub], scaleX) # numPositions * batchSize\r\n        alpha = e_ij * tensor.exp(-0.5 * tensor.square(distWeights))  # alpha = alpha_t(s)，numPositions * batchSize\r\n\r\n        \r\n        alpha = alpha - alpha.max(0)  # subtract max elements\r\n        alpha = tensor.exp(alpha)  # numPositions * batchSize\r\n\r\n        context_mask_ = tensor.zeros([numPositions, n_samples])\r\n        context_mask_ = tensor.set_subtensor(context_mask_[indicesSub, unmaskedIds], 1.)\r\n        if context_mask_:  # context_mask =x_mask，nsteps_src * batchSize，be truncated to numPositions * batchSize\r\n            alpha = alpha * context_mask_\r\n\r\n        alpha_sum = alpha.sum(0, keepdims=True)  # ∑eij\r\n        alpha_sum = tensor.switch(alpha_sum, alpha_sum, 1.)  # if alpua_sum = 0 ->1\r\n        alpha = alpha / alpha_sum  # (numPositions * batchSize),eij/∑eij\r\n\r\n        # current context,(numPositions*batchSize*dim).sum(0) -->batchSize*dim\r\n        ctx_ = (srcVecsSub * alpha[:, :, None]).sum(0)  \r\n\r\n        preact2 = tensor.dot(h1, U_nl) + b_nl\r\n        preact2 += tensor.dot(ctx_, Wc)\r\n        preact2 = tensor.nnet.sigmoid(preact2)\r\n\r\n        r2 = _slice(preact2, 0, dim)\r\n        u2 = _slice(preact2, 1, dim)\r\n\r\n        preactx2 = tensor.dot(h1, Ux_nl) + bx_nl\r\n        preactx2 *= r2\r\n        preactx2 += tensor.dot(ctx_, Wcx)\r\n\r\n        h2 = tensor.tanh(preactx2)\r\n\r\n        h2 = u2 * h1 + (1. - u2) * h2\r\n        h2 = m_[:, None] * h2 + (1. - m_)[:, None] * h1\r\n\r\n        return h2, ctx_, alpha.T  \r\n\r\n    seqs = [context_mask, mask, state_below_, state_belowx]  # context_mask, mask, state_below_, and state_belowx are source mask matrix and target mask matrix, and the product of word embedding matrix and superparameter, respectively.\r\n    _step = _step_slice\r\n\r\n    shared_vars = [tparams[_p(prefix, 'Wc_att')],\r\n                   tparams[_p(prefix, 'b_att')],\r\n                   tparams[_p(prefix, 'U')],\r\n                   tparams[_p(prefix, 'Wc')],\r\n                   tparams[_p(prefix, 'W_comb_att')],\r\n                   tparams[_p(prefix, 'U_att')],\r\n                   tparams[_p(prefix, 'c_tt')],\r\n                   tparams[_p(prefix, 'Ux')],\r\n                   tparams[_p(prefix, 'Wcx')],\r\n                   tparams[_p(prefix, 'U_nl')],\r\n                   tparams[_p(prefix, 'Ux_nl')],\r\n                   tparams[_p(prefix, 'b_nl')],\r\n                   tparams[_p(prefix, 'bx_nl')],\r\n                   tparams['Wemb_dec']] \r\n\r\n    if one_step:  \r\n        rval = _step(*(seqs + [init_state, None, None, pctx_, context] +\r\n                       shared_vars))  # one_step == Flase\r\n    else:  \r\n        rval, updates = theano.scan(_step,\r\n                                    sequences=seqs,\r\n                                    outputs_info=[init_state,\r\n                                                  tensor.alloc(0., n_samples,\r\n                                                               context.shape[2]),\r\n                                                  tensor.alloc(0., n_samples,\r\n                                                               context.shape[0])],\r\n                                    non_sequences=[pctx_, context]+shared_vars,\r\n                                    name=_p(prefix, '_layers'),\r\n                                    n_steps=nsteps,\r\n                                    profile=profile,\r\n                                    strict=True)\r\n    return rval\r\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/405021433",
    "html_url": "https://github.com/ipython/ipython/issues/11228#issuecomment-405021433",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11228",
    "id": 405021433,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTAyMTQzMw==",
    "user": {
      "login": "Peng-Ru",
      "id": 31172620,
      "node_id": "MDQ6VXNlcjMxMTcyNjIw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/31172620?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Peng-Ru",
      "html_url": "https://github.com/Peng-Ru",
      "followers_url": "https://api.github.com/users/Peng-Ru/followers",
      "following_url": "https://api.github.com/users/Peng-Ru/following{/other_user}",
      "gists_url": "https://api.github.com/users/Peng-Ru/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Peng-Ru/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Peng-Ru/subscriptions",
      "organizations_url": "https://api.github.com/users/Peng-Ru/orgs",
      "repos_url": "https://api.github.com/users/Peng-Ru/repos",
      "events_url": "https://api.github.com/users/Peng-Ru/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Peng-Ru/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-14T12:43:33Z",
    "updated_at": "2018-07-14T12:43:33Z",
    "author_association": "NONE",
    "body": "And I think the problem lies in the line:\r\n**distWeights = tensor.set_subtensor(distWeights[unmaskedIds,indicesSub], scaleX)**\r\nWhether theano.tensor.set_subtensor does the above error “... grad illegally ... ”when doing the operation tensor.grad(cost, wrt=itemlist(tparams))"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/405021860",
    "html_url": "https://github.com/ipython/ipython/issues/11228#issuecomment-405021860",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11228",
    "id": 405021860,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwNTAyMTg2MA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-07-14T12:51:48Z",
    "updated_at": "2018-07-14T12:51:48Z",
    "author_association": "MEMBER",
    "body": "I'm confused why you got a message suggesting you post this to the IPython bug tracker. Theano is nothing to do with IPython, and we can't help you with debugging it. If you think there's a bug in Theano itself, try https://github.com/Theano/Theano ."
  }
]
