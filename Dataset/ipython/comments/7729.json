[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73746058",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73746058",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73746058,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzQ2MDU4",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T17:43:57Z",
    "updated_at": "2015-02-10T17:43:57Z",
    "author_association": "MEMBER",
    "body": "As you know, right now the model is defined in Python and it's structure is mirrored by Javascript upon first state push.  This behavior is asymmetric, since you can't create traitlets dynamically.  One of the students working with @ellisonbg has created a method that does allow you to create traitlets dynamically.  I was thinking it would be nice (but not essential) if we could further the symmetry of the framework by allowing models created in Javascript to be mirrored by Python.  I'm keeping this in mind as I think about this problem.\n\nWith the first approach, it seems like the symmetry would increase.  Since you'd need the class to already exists on both ends the dynamic-ness would decrease.  \n\nWith the second approach, a serializing/deserializing registry could be introduced, similar to the view/model registry mechanisms in place now, with requirejs/python-import support.  This is nice because the serialization methods could be centralized.  i.e. all model (de)serialization would happen in the same two methods.  Additionally, a bidirectional \"register trait\" message could be implemented, which would be called to associate traits with types.  This has the added benefit of allowing one to add traits at runtime.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73766399",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73766399",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73766399,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzY2Mzk5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T19:30:36Z",
    "updated_at": "2015-02-10T19:30:36Z",
    "author_association": "MEMBER",
    "body": "Thanks for getting the ball rolling on this one.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73766960",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73766960",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73766960,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzY2OTYw",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T19:33:08Z",
    "updated_at": "2015-02-10T19:33:08Z",
    "author_association": "MEMBER",
    "body": "@sylvaincorlay worked a bit on dynamic traits too - maybe @ellisonbg's student and Sylvain should exchange notes.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73768023",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73768023",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73768023,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzY4MDIz",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T19:37:52Z",
    "updated_at": "2015-02-10T19:38:59Z",
    "author_association": "MEMBER",
    "body": "@rmorshea is @ellisonbg 's student who has worked on dynamic traits.  @sylvaincorlay met him at the Bloomberg hackathon in NY .\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73782394",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73782394",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73782394,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzgyMzk0",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T20:59:27Z",
    "updated_at": "2015-02-12T05:31:54Z",
    "author_association": "MEMBER",
    "body": "I think that having widget class-level serialization / deserialization functions is not the way to go. Indeed, this would be a problem for parameterized traits such as\n\n`List(Unicode(allow_none=False))`\n\nSpecifying how the elements of the list should be specialized should be done at the trait type level, like it is at the moment with `to_json` and `from_json`.\n\nOn the JavaScript side, we can create counterparts for those TraitTypes, implementing serialization and de-serialization (could be called trait types as well). The synced Python trait-type could have a requirejs path in its metadata to indicate what is its front-end counterpart. In the case where none is provided, the default JSON.parse would be used. \n\nThe case of _parameterized traits_ really shows that having the serialization logic at the widget object level would not work, while the traitlet instance-level approach handles it well, as well as the case of a `Union` trait type. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73784599",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73784599",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73784599,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzg0NTk5",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T21:12:30Z",
    "updated_at": "2015-02-10T21:13:11Z",
    "author_association": "MEMBER",
    "body": "What @SylvainCorlay suggests sounds like a good idea.  However, @SylvainCorlay I don't think your suggestion clarifies how the model (JS) and widget (Py) will tell each other what keys map to what types (traits in your suggestion).  My suggestion for a bidirectional \"register trait(s)\" message still stands _as an addition to your suggestion_, which would be called to associate keys with types (traits). This has the added benefit of allowing one to add or redefine traits dynamically.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73787390",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73787390",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73787390,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzg3Mzkw",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T21:27:54Z",
    "updated_at": "2015-02-12T05:30:45Z",
    "author_association": "MEMBER",
    "body": "One could use a more sophisticated `Widget.get_state` when sending the state that adds that information as a new attribute in the result of `to_json`. A consequence would be that we could have specific serialization only if to_json returns a dict, and not in the case of an list. (It would become a requirement to diverge from the bare json), and that the name of that key would be reserved for this purpose. We could use a unicode string like ｔｙｐｅ\n\nIf no front-end module is provided (such as in the case where to_json returns a list), we would simply decode with `JSON.parse`.\n\nAnother way to put it: have that module name be included in the `to_json` serialization if present. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73788390",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73788390",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73788390,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzg4Mzkw",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T21:33:34Z",
    "updated_at": "2015-02-10T21:33:34Z",
    "author_association": "MEMBER",
    "body": "@sylvaincorlay, so now you're encoding the type in the value sent over the wire?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73788570",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73788570",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73788570,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzg4NTcw",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T21:34:37Z",
    "updated_at": "2015-02-10T21:34:37Z",
    "author_association": "MEMBER",
    "body": "Yes, only when provided. It is necessary for the cases of\n- `Union`\n- `Parameterized traits`\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73791890",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73791890",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73791890,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzkxODkw",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T21:52:47Z",
    "updated_at": "2015-02-10T21:52:47Z",
    "author_association": "MEMBER",
    "body": "@SylvainCorlay one reason I prefer a separate message is that the typing could be defined once, reducing message overhead.  Also the state synchronizing messages are dirt simple, **except** the `modelid_` string parsing, which would be removed.  Complicating the messages again seems like a step backwards.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73793861",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73793861",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73793861,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzkzODYx",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T22:04:03Z",
    "updated_at": "2015-02-10T22:05:51Z",
    "author_association": "MEMBER",
    "body": "How would you handle Union(Date, Float), where Date has a custom deserialization?\n\nJust to clarify, with the solution that I propose, basic types such as int, float, string would still be transferred in the same way. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73797922",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73797922",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73797922,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczNzk3OTIy",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T22:27:44Z",
    "updated_at": "2015-02-10T22:28:58Z",
    "author_association": "MEMBER",
    "body": "> Just to clarify, with the solution that I propose, basic types such as int, float, string would still be transferred in the same way.\n\nYes I understand that, with the type message that would remain the same.  It would only contain information about types that required it, like Union.  \n\n> How would you handle Union(Date, Float), where Date has a custom deserialization?\n\nI propose something like this:\n\nYour class:\n\n``` python\nclass MyWidget(Widget):\n    a = Union(Date, Float, sync=True, trait_frontend_module='/nbextension/union')\n    b = Int(sync=True)\n```\n\nThe type message sent (note b isn't in it because it's a type supported by JSON):\n\n``` js\n{\n  a: {\n    module: 'nbextensions/union', \n    metadata: {\n      types: ['date', 'time']\n    }\n  }\n}\n```\n\nWhere metadata can be anything that the trait wants.  If not provided explicitly by the user, the trait can generate it itself.  For union, it would do something like `self.trait_frontend_metadata = {'types': typelist}`.\n\nBefore the backend sent a state message with `a` in it, it would send the type message above.  The type message would only have to be sent once because the front-end would be stateful.  Basically, types would be synced almost the same way values are now, just with a different message type.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73802975",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73802975",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73802975,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODAyOTc1",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T23:00:36Z",
    "updated_at": "2015-02-12T05:28:53Z",
    "author_association": "MEMBER",
    "body": "OK, I think that we understand each other. \n\nBtw, Union trait types cannot have metadata on their own at the moment (even `sync=True` is a property of the different types of which you take the Union). The Union switches between the metadata of the traittypes of which it takes the Union. \n\nWhat I propose would handle a class like\n\n``` Python\nclass MyWidget(Widget):\n    a = Date(sync=True) | Float(sync=True)\n    b = Int(sync=True)\n    c = List(Date() | Int), sync=True)\n```\n- `a` (Union) is serialized either \n   by `Date.to_json` into something like `{   ..., 'ｔｙｐｅ': '/nbextensions/datetime/date'  }` \n   or by `Float.to_json` into a bare Float\n- `b` (Int) is sent over the wire as a bare int\n- `c` (parameterized type): we recurse through the element trait types for serialization as we already do\n  something like `[Date('20120405'), 7]` is serialized into someting like\n  `[ {  'value': '20120405', 'ｔｙｐｅ': '/nbextensions/datetime/date'  } , 7 ]`\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73807971",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73807971",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73807971,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODA3OTcx",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T23:36:54Z",
    "updated_at": "2015-02-10T23:46:33Z",
    "author_association": "MEMBER",
    "body": "So here's what I propose as a first step: just a single top-level function to do serialization, set in the metadata of a trait.  I think basically all of the other things we are talking about could be experimented with if we had this infrastructure.\n\n``` python\nclass MyWidget(Widget):\n    a = Union(Float(sync=True), Date(sync=True, serialization={'python': ('IPython.html.widgets.types', 'Date'), 'javascript': ('/nbextension/types', 'date')}))\n    b = List(Date, serialization={'python': ('IPython.html.widgets.types', 'ListOfDates'), 'javascript': ('/nbextension/types', 'listofdates')})\n```\n\nIn `IPython.html.widgets.types`, we have\n\n``` python\ndef serialize_date(value):\n    ....\ndef deserialize_date(value):\n    ....\nDate = (serialize_date, deserialize_date)\n```\n\nWhen python serializes the message:\n- imports the `serialization['python']` module, and gets the `Date` tuple in that module.  It uses the serialization function in that tuple to serialize the value it is going to sync.  \n- If the serialization module returns a memoryview, it appends it as a binary buffer to the sync message, otherwise, it incorporates it into the state dictionary.  If it appends the binary buffer, then it adds the key to a special `buffers` list it sends in the sync message\n- If the `serialization['javascript']` tuple exists, it adds that tuple to a special `serialization` dict it sends in the sync message.\n\nWhen js deserializes the message, it\n- Goes through the binary buffers and attaches the DataViews to the appropriate places in the message\n- requires the appropriate module and retrieves the appropriate deserialization function, if needed, for each field.\n\nIt should also overwrite the serialization function for that field, to use when it sends data back.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73809392",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73809392",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73809392,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODA5Mzky",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T23:48:21Z",
    "updated_at": "2015-02-10T23:59:14Z",
    "author_association": "MEMBER",
    "body": "~~@jasongrout that sounds good.  You're right, that's basically the piece we all agree on at this point.~~\n\nEdit: You changed your post and I haven't read it completely, yet.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73809797",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73809797",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73809797,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODA5Nzk3",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-10T23:51:48Z",
    "updated_at": "2015-02-10T23:51:48Z",
    "author_association": "MEMBER",
    "body": "I think these two proposals summarize well what we have been discussing here. \n\n-The problem with the first solution (the one I proposed) is efficiency for small boxed types in sequences. \n-The problem with the second solution (Jason's) is the fact that you need a special serializer in the case of parameterized trait types. (like in the second example). \n\nI guess we could have both, the default being the box-typing, and when efficiency requires it, we could let one force a custom serialization at the top level of the parameterized type. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73811006",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73811006",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73811006,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODExMDA2",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T00:01:50Z",
    "updated_at": "2015-02-11T00:01:50Z",
    "author_association": "MEMBER",
    "body": "@jasongrout I just finished reading your edited post and I still think it makes sense, and is a good starting point.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73812974",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73812974",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73812974,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODEyOTc0",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T00:18:52Z",
    "updated_at": "2015-02-11T00:20:10Z",
    "author_association": "MEMBER",
    "body": "> -The problem with the second solution (Jason's) is the fact that you need a special serializer in the case of parameterized trait types. (like in the second example).\n\nWell I don't think that's actually a problem.  The serializer could just recurse to other serializers for the contained types.  That logic will have to exist somewhere anyways.  \n\n@jasongrout 's example can be adjusted where each argument in the tuple past the second gets blindly passed into the serialization methods:\n\n``` python\n_date = {'python': ('IPython.html.widgets.types', 'date'), 'javascript': ('/nbextension/types', 'date')}\n b = List(Date, serialization={'python': ('IPython.html.widgets.types', 'listof', _date), 'javascript': ('/nbextension/types', 'listof', _date)})\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73813091",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73813091",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73813091,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODEzMDkx",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T00:19:55Z",
    "updated_at": "2015-02-11T00:19:55Z",
    "author_association": "MEMBER",
    "body": "Admittedly, that's not as clean looking as what you (@SylvainCorlay) suggest.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73813648",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73813648",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73813648,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODEzNjQ4",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T00:24:52Z",
    "updated_at": "2015-02-11T00:24:52Z",
    "author_association": "MEMBER",
    "body": "Maybe this is easier to read:\n\n``` python\n_date = {'python': ('IPython.html.widgets.types', 'date'), 'javascript': ('/nbextension/types', 'date')}\n_listof = lambda x: {'python': ('IPython.html.widgets.types', 'listof', x), 'javascript': ('/nbextension/types', 'listof', x)}\n\n b = List(Date, serialization=_listof(_date))\n```\n\nIf we send this information as a separate message, only once, we could really minimize the overhead.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73817573",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73817573",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73817573,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczODE3NTcz",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T01:03:22Z",
    "updated_at": "2015-02-11T01:04:16Z",
    "author_association": "MEMBER",
    "body": "@jdfreder we could implement the box-typing as a default and allow one to overload when necessary. List of dates is the only unfavorable case for box typing:\n- box typing is nicer for Unions. The actual trait type handles everything\n- its overhead is small for large footprint trait types: \n  numpy array: { 'v': BASE64encoding, 'type': 'ndarray'}\n- it handles arbitrary nested parameterized types like Tuple(Bar) without having to specify a serializer for the resulting structure.\n- it does not impact basic types that are sent without decoration. \n\nBUT\n- has a big overhead on this like List(Date()) because Date has a small footprint. Then, we could allow the overload of a `serialization` method.\n\nHowever, I don't think that it should be necessary to overload the serializer of `Tuple([Foo(), Int()])`  for example in every case, especially if is it not meant to be a long list. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73927432",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73927432",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73927432,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczOTI3NDMy",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T17:46:27Z",
    "updated_at": "2015-02-11T17:53:14Z",
    "author_association": "MEMBER",
    "body": "I've been resisting doing something with boxed types for a while now, but the thing that almost convinced me to use them last week keeps coming back, and I think Sylvain makes a good argument for - the languages are dynamic, so they are a natural fit.  Here's a proposal that is very close to Sylvain's proposal:\n\n`Date` is a traitlet that has a default serialization metadata, equal to `serialization={'python': ('IPython.html.widgets.types', 'Date'), 'javascript': ('/nbextension/types', 'date')}`\n\n``` python\nclass MyWidget(Widget):\n    a = Union(Float(sync=True), Date(sync=True))\n    b = List(Date, sync=True)\n    c = List(Date, sync=True, serialization={'python': ('IPython.html.widgets.types', 'ListOfDates'), 'javascript': ('/nbextension/types', 'listofdates')})\n```\n- the serialization function takes in the value of the field, and returns a tuple `(value, metadata)`: a value (which is either a JSONable object, like a list or dict, or a memoryview), and a dict of metadata or None.  For example:\n  - The Date serialization function could return `('2015-01-01T15:20:00', None)`.  The trait value in the state dictionary is then `['IPY_CUSTOM_TYPE', {'serialization': ('/nbextension/types', 'date'), 'value': '2015-01-01T15:20:00'}]`\n  - The ListOfDates serialization function could return a memoryview of a numpy array of datetimes (converted to floats), `(memory_view, {'dtype': 'datetime64[h]', 'shape': (2000,)}`.  The traitlet value in the state dictionary is then `['IPY_CUSTOM_TYPE', {'serialization': ('/nbextension/types', 'listofdates'), 'metadata': {'dtype': 'datetime64[h]', 'shape': (2000,)}, buffer: 2}]`, where the memoryview is transmitted as buffers[2] in the message.\n\nThe basic form of a custom-typed value is `['IPY_CUSTOM_TYPE', {'serialization': ('require_module_path', 'name_of_serialize_tuple'), ['metadata': (optional, metadata returned)], 'value': JSONable_value, 'buffer': int}]`, where exactly one of value or buffer is specified.\n\nIn the unserialize phase, all traits are parsed with JSON.  Then we recurse into lists and dicts, looking for custom type lists (lists of length 2 that have our custom weird sentinel string as the first item).  If we ever find a custom type list, we extract the deserializer, get the buffer and make it the value (if needed), and call the deserializer with the buffer and the value.  We replace the entire custom type list with the return value from the deserializer.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73931768",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73931768",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73931768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczOTMxNzY4",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T18:08:53Z",
    "updated_at": "2015-02-11T18:08:53Z",
    "author_association": "MEMBER",
    "body": "I can live with box typing, but that really is a lot of overhead to send with every state sync (which may be happening often).  How about adding a new message type, which allows Python to register types with JS, and vice versa (using the same serialize/deserialize Python/JS pairs scheme we've been talking about).  Then each boxed type would be keyed, where 0 would be a JSON safe type.  Every value would be a 2 entry tuple of this form (type_key, data).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73936128",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73936128",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73936128,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczOTM2MTI4",
    "user": {
      "login": "SylvainCorlay",
      "id": 2397974,
      "node_id": "MDQ6VXNlcjIzOTc5NzQ=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/2397974?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/SylvainCorlay",
      "html_url": "https://github.com/SylvainCorlay",
      "followers_url": "https://api.github.com/users/SylvainCorlay/followers",
      "following_url": "https://api.github.com/users/SylvainCorlay/following{/other_user}",
      "gists_url": "https://api.github.com/users/SylvainCorlay/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/SylvainCorlay/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/SylvainCorlay/subscriptions",
      "organizations_url": "https://api.github.com/users/SylvainCorlay/orgs",
      "repos_url": "https://api.github.com/users/SylvainCorlay/repos",
      "events_url": "https://api.github.com/users/SylvainCorlay/events{/privacy}",
      "received_events_url": "https://api.github.com/users/SylvainCorlay/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T18:32:16Z",
    "updated_at": "2015-02-11T18:35:25Z",
    "author_association": "MEMBER",
    "body": "@jdfreder a new message type to reduce the `type` string to a int. Early\noptimization?\n\nOn Wed, Feb 11, 2015 at 1:09 PM, Jonathan Frederic <notifications@github.com\n\n> wrote:\n> \n> I can live with box typing, but that really is a lot of overhead to send\n> with every state sync (which may be happening often). How about adding a\n> new message type, which allows Python to register types with JS, and vice\n> versa (using the same serialize/deserialize Python/JS pairs scheme we've\n> been talking about). Then each boxed type would be keyed, where 0 would be\n> a JSON safe type. Every value would be a 2 entry tuple of this form\n> (type_key, data).\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/ipython/ipython/issues/7729#issuecomment-73931768.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/73937517",
    "html_url": "https://github.com/ipython/ipython/issues/7729#issuecomment-73937517",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7729",
    "id": 73937517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDczOTM3NTE3",
    "user": {
      "login": "jdfreder",
      "id": 3292874,
      "node_id": "MDQ6VXNlcjMyOTI4NzQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3292874?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdfreder",
      "html_url": "https://github.com/jdfreder",
      "followers_url": "https://api.github.com/users/jdfreder/followers",
      "following_url": "https://api.github.com/users/jdfreder/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdfreder/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdfreder/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdfreder/subscriptions",
      "organizations_url": "https://api.github.com/users/jdfreder/orgs",
      "repos_url": "https://api.github.com/users/jdfreder/repos",
      "events_url": "https://api.github.com/users/jdfreder/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdfreder/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-02-11T18:39:52Z",
    "updated_at": "2015-02-11T18:39:52Z",
    "author_association": "MEMBER",
    "body": "I must be confused, I thought @jasongrout was suggesting a trait's value be synced as `['IPY_CUSTOM_TYPE', {'serialization': ('require_module_path', 'name_of_serialize_tuple'), ['metadata': (optional, metadata returned)], 'value': JSONable_value, 'buffer': int}]`\\- which is much longer than a string type name.\n"
  }
]
