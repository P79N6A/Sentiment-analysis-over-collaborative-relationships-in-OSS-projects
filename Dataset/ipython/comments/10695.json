[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/314408271",
    "html_url": "https://github.com/ipython/ipython/issues/10695#issuecomment-314408271",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/10695",
    "id": 314408271,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDQwODI3MQ==",
    "user": {
      "login": "bluenote10",
      "id": 3620703,
      "node_id": "MDQ6VXNlcjM2MjA3MDM=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/3620703?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bluenote10",
      "html_url": "https://github.com/bluenote10",
      "followers_url": "https://api.github.com/users/bluenote10/followers",
      "following_url": "https://api.github.com/users/bluenote10/following{/other_user}",
      "gists_url": "https://api.github.com/users/bluenote10/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bluenote10/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bluenote10/subscriptions",
      "organizations_url": "https://api.github.com/users/bluenote10/orgs",
      "repos_url": "https://api.github.com/users/bluenote10/repos",
      "events_url": "https://api.github.com/users/bluenote10/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bluenote10/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-11T10:54:24Z",
    "updated_at": "2017-07-11T10:54:24Z",
    "author_association": "NONE",
    "body": "Another search has brought up https://github.com/ipython/ipython/issues/8918, not clear why it's closed though."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/314995798",
    "html_url": "https://github.com/ipython/ipython/issues/10695#issuecomment-314995798",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/10695",
    "id": 314995798,
    "node_id": "MDEyOklzc3VlQ29tbWVudDMxNDk5NTc5OA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2017-07-13T07:29:05Z",
    "updated_at": "2017-07-13T07:29:05Z",
    "author_association": "MEMBER",
    "body": "See also #62. There's a limitation of executing Python code in a local namespace, which we haven't found a good way to work around."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/400231247",
    "html_url": "https://github.com/ipython/ipython/issues/10695#issuecomment-400231247",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/10695",
    "id": 400231247,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQwMDIzMTI0Nw==",
    "user": {
      "login": "liushapku",
      "id": 12460646,
      "node_id": "MDQ6VXNlcjEyNDYwNjQ2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/12460646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/liushapku",
      "html_url": "https://github.com/liushapku",
      "followers_url": "https://api.github.com/users/liushapku/followers",
      "following_url": "https://api.github.com/users/liushapku/following{/other_user}",
      "gists_url": "https://api.github.com/users/liushapku/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/liushapku/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/liushapku/subscriptions",
      "organizations_url": "https://api.github.com/users/liushapku/orgs",
      "repos_url": "https://api.github.com/users/liushapku/repos",
      "events_url": "https://api.github.com/users/liushapku/events{/privacy}",
      "received_events_url": "https://api.github.com/users/liushapku/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-06-26T08:48:27Z",
    "updated_at": "2018-06-26T08:49:45Z",
    "author_association": "NONE",
    "body": "As mentioned in [this thread](https://stackoverflow.com/questions/35161324/how-to-make-imports-closures-work-from-ipythons-embed/51036158#51036158), I post my code here. Hopefully it can partially solve the problems. The code below also loads the startup files for IPython, which is missing from the origin code.\r\n\r\n```\r\nclass InteractiveShellEmbedEnhanced(InteractiveShellEmbed):\r\n    \"\"\"\r\n    A workaround to issue https://github.com/ipython/ipython/issues/10695\r\n    In embedded ipython shell, new variables are created in locals() instead of globals()\r\n    and functions do not make closures for the locals.\r\n\r\n    Examples:\r\n\r\n    If not embedded from a function, then nothing special needs to be done other than calling embed() defined below.\r\n    These code will work:\r\n\r\n        a=3; (lambda: a)()\r\n        import time; (lambda: time.time())()\r\n\r\n    If embedded from a function, in order to introduce new variables to global name space, we need to call\r\n    ipy.to_global() first and then call ipy.to_local() to come back\r\n\r\n        ipy.to_global()\r\n        a=3  # here we cannot access the local variables\r\n        ipy.to_local()\r\n        (lambda: a)()\r\n\r\n    It seems that a contextmanager to switch back automatically will not work:\r\n\r\n        with ipy.to_global_manager():\r\n            a=3\r\n            print((lambda: a)())\r\n\r\n    It may be because of that IPython compiles the whole cell and run it using exec(code, globals, locals).\r\n    But globals and locals are calculated at the time this context manager is defined.\r\n    \"\"\"\r\n    @property\r\n    def user_global_ns(self):\r\n        if getattr(self, 'embedded_outside_func', False):\r\n            return self.user_ns\r\n        else:\r\n            return self.user_module.__dict__\r\n\r\n    def init_frame(self, frame):\r\n        if frame.f_code.co_name == '<module>': # if embedded outside a function\r\n            self.embedded_outside_func = True\r\n        else:  # if embedded from a function\r\n            self.embedded_outside_func = False\r\n\r\n            self._saved_user_ns = None\r\n            self._ns = {}\r\n            # make global variables for user access to the histories\r\n            self._ns['_ih'] = self.history_manager.input_hist_parsed\r\n            self._ns['_oh'] = self.history_manager.output_hist\r\n            self._ns['_dh'] = self.history_manager.dir_hist\r\n\r\n            # user aliases to input and output histories.  These shouldn't show up\r\n            # in %who, as they can have very large reprs.\r\n            self._ns['In']  = self.history_manager.input_hist_parsed\r\n            self._ns['Out'] = self.history_manager.output_hist\r\n\r\n            # Store myself as the public api!!!\r\n            # ns['get_ipython'] = self.get_ipython\r\n            self._ns['exit'] = self.exiter\r\n            self._ns['quit'] = self.exiter\r\n\r\n            self.to_global = self._to_global\r\n            self.to_local = self._to_local\r\n\r\n    def _to_global(self):\r\n        self._saved_user_ns = self.user_ns\r\n        assert not set(self._ns).intersection(self.user_module.__dict__)\r\n        self.user_ns = self.user_module.__dict__\r\n        self.user_ns.update(self._ns)\r\n\r\n    def _to_local(self):\r\n        if self._saved_user_ns is None:\r\n            return\r\n        for key in self._ns:\r\n            del self.user_ns[key]\r\n        self.user_ns = self._saved_user_ns\r\n\r\n    def share_locals(self):\r\n        \"\"\"\r\n        share the locals to global manually\r\n        \"\"\"\r\n        if (id(self.user_ns) != id(self.user_module.__dict__)):\r\n            self.user_module.__dict__.update(self.user_ns)\r\n\r\n\r\ndef embed(local_ns=None, **kwargs):\r\n    \"\"\"\r\n    based on IPython.terminal.embed.embed()\r\n    \"\"\"\r\n    config = kwargs.get('config')\r\n    header = kwargs.pop('header', u'')\r\n    compile_flags = kwargs.pop('compile_flags', None)\r\n    if config is None:\r\n        config = load_default_config()\r\n        config.InteractiveShellEmbedEnhanced = config.TerminalInteractiveShell\r\n        kwargs['config'] = config\r\n    #save ps1/ps2 if defined\r\n    ps1 = None\r\n    ps2 = None\r\n    try:\r\n        ps1 = sys.ps1\r\n        ps2 = sys.ps2\r\n    except AttributeError:\r\n        pass\r\n    #save previous instance\r\n    saved_shell_instance = InteractiveShell._instance\r\n    if saved_shell_instance is not None:\r\n        cls = type(saved_shell_instance)\r\n        cls.clear_instance()\r\n    frame = sys._getframe(1)\r\n\r\n    # shell is the ipython instance returned from get_ipython()\r\n    # frame refers to the caller of this function\r\n    shell = InteractiveShellEmbedEnhanced.instance(_init_location_id='%s:%s' % (\r\n        frame.f_code.co_filename, frame.f_lineno), **kwargs)\r\n    shell.init_frame(frame)\r\n\r\n    #######################\r\n    # load the startup files and update the local_ns\r\n    ######################\r\n\r\n    # if local_ns is None:\r\n    #     local_ns = frame.f_locals\r\n    global_ns = frame.f_globals\r\n    global_ns['ipy'] = shell\r\n    global_ns['share_locals'] = shell.share_locals\r\n\r\n    startup_files = glob.glob(os.path.join(shell.profile_dir.startup_dir, '*.py'))\r\n    startup_files += glob.glob(os.path.join(shell.profile_dir.startup_dir, '*.ipy'))\r\n\r\n    if '__file__' in global_ns:\r\n        hasfile = True\r\n        cfile = global_ns['__file__']\r\n    else:\r\n        hasfile = False\r\n\r\n    for filename in sorted(startup_files):\r\n        if filename.endswith('.ipy'):\r\n            shell.safe_execfile_ipy(filename)\r\n        else:\r\n            global_ns['__file__'] = filename\r\n            shell.safe_execfile(filename, global_ns, raise_exceptions=True)  # this updates the global_ns\r\n\r\n    if hasfile:\r\n        global_ns['__file__'] = cfile\r\n    else:\r\n        del global_ns['__file__']\r\n\r\n    ########################\r\n    #  launch the shell\r\n    #######################\r\n    shell(local_ns=local_ns, header=header, stack_depth=2, compile_flags=compile_flags,\r\n          _call_location_id='%s:%s' % (frame.f_code.co_filename, frame.f_lineno))\r\n    InteractiveShellEmbedEnhanced.clear_instance()\r\n    #restore previous instance\r\n    if saved_shell_instance is not None:\r\n        cls = type(saved_shell_instance)\r\n        cls.clear_instance()\r\n        for subclass in cls._walk_mro():\r\n            subclass._instance = saved_shell_instance\r\n    if ps1 is not None:\r\n        sys.ps1 = ps1\r\n        sys.ps2 = ps2\r\n```"
  }
]
