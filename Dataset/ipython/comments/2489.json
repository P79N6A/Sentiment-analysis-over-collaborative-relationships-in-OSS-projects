[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9412233",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9412233",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9412233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MTIyMzM=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-13T22:49:51Z",
    "updated_at": "2012-10-13T22:49:51Z",
    "author_association": "MEMBER",
    "body": "in your case, what is the engine working directory?\n\nDoes `dv.execute(\"import functions\")` work?  If not, then I think the right behavior is happening.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9413285",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9413285",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9413285,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MTMyODU=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-13T23:37:19Z",
    "updated_at": "2012-10-13T23:37:19Z",
    "author_association": "MEMBER",
    "body": "It is not unreasonable for module functions to require that their module be present.  If you want to explicitly note that functions do not need their module, then you can use the `@interactive` decorator, which tells IPython that a function should be treated as if it was typed interactively instead of as a part of the module in which it is defined.\n\nYou are right that the old version of the options pricer will see an ImportError (unless the engines share the client's working dir), and I can confirm that simply applying `@interactive` to `price_options`, works as expected:\n\n``` python\nfrom IPython.parallel import interactive\n\n@interactive\ndef price_options(...):\n   \"\"\"the rest unchanged\"\"\"\n```\n\nBased on that, I am marking this as a docs bug, and pinging @ellisonbg, as he is the one who removed the files that are in the 0.13 docs via `literalinclude`, but are now missing.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9414895",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9414895",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9414895,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MTQ4OTU=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T01:16:28Z",
    "updated_at": "2012-10-14T01:20:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "The engines are on a different computer and the engines use the default working dir (whatever is used when running the \"ipcluster engine\" from a comandline)\n\nJust to make it clear:\nmy \"project\" consists of two files: functions.py and main.py. Running main.py with a above code worked before the change but not with the change from #2395.\n\nIf that's really the intended change, then how would one split code into different files? Do I really have to put every function into main.py? From my current understading, both of this is not possible:\n- Splitting the remote function into a different file (this issue) [Update: ok, with `@interactive`]\n- running a function remotely which calls a function from the same file where the function comes from https://github.com/ipython/ipython/issues/2473#issuecomment-9200719\n\nSo splitting code and organizing it is actually not possible at all: your remote function must be single function (or use code from installed libraries)\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9416381",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9416381",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9416381,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MTYzODE=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T05:19:44Z",
    "updated_at": "2012-10-14T05:21:37Z",
    "author_association": "MEMBER",
    "body": "> If that's really the intended change, then how would one split code into\n> different files?\n\nPlenty of ways, involving push/pull, `@interactive`, or possibly sending\nfile contents around.  See below.\n\n> Do I really have to put every function into main.py?\n\nAbsolutely not.\n\n> From my current understading, both of this is not possible:\n> - Splitting the remote function into a different file (this issue)\n> - running a function remotely which calls a function from the same\n>   file where the function comes from #2473\n> \n> So splitting code and organizing it is actually not possible at all: your\n> remote function must be single function (or use code from installed\n> libraries)\n\nI guess my comment above was not clear.  There are _many_ ways for you to\nbreak up code within a single script, or deal with simple modules only\navailable on the Client:\n- use scripts as scripts, e.g. with `view.run('script.py')` to make names\n  available\n- use `@interactive` to associate module functions with the user namespace\n  (and dissociate them from their module)\n- send functions with push/pull to establish required namespace\n- send the modules themselves, so they are importable remotely:\n\n``` python\ndef send_module(view, mod):\n    fname = mod.__file__\n    with open(fname) as f:\n        data = f.read()\n\n    def _write_module(filename, filedata):\n        import os\n        if os.path.exists(filename):\n            return False\n        with open(filename, 'w') as f:\n            f.write(filedata)\n        return os.path.abspath(filename)\n\n    return view.apply_async(_write_module, fname, data)\n\nimport functions\nsend_module(view, functions)\n```\n\nThe _only_ difference between before/after #2395 is that if you want to use\na function from a local module on an engine where that module is not\navailable,\nyou have to decorate that function with `@interactive`.  Other than that,\nthe exact same things will and will not work.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9418209",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9418209",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9418209,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MTgyMDk=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T10:38:52Z",
    "updated_at": "2012-10-14T10:38:52Z",
    "author_association": "CONTRIBUTOR",
    "body": "> use scripts as scripts, e.g. with view.run('script.py') to make names available\n> use @interactive to associate module functions with the user namespace (and dissociate them from their module)\n> send functions with push/pull to establish required namespace\n> send the modules themselves, so they are importable remotely:\n\nThis still leaves out a the case of a LoadBalancedView, where new engines can appear during the execution of many tasks... I will give it a try to build a `@remote_runable(put_in_namesspace=[function1, function2])` decorator, which takes the required function names with it...\n\n> def send_module(view, mod):\n>     [...]\n\nIt would be nice if this (and the rest of you suggestion) could be made available in Client. And documented :-) I've renamed the issue accordingly...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9419910",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9419910",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9419910,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MTk5MTA=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T14:22:36Z",
    "updated_at": "2012-10-14T21:28:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "A first try (should probably get a extra flag in loadbalanced view or in the client, which then would just wrap the function, instead of doing it manually in the calling code):\n\n```\nfrom IPython.parallel import Client, RemoteError, AsyncResult\nc = Client(profile=\"ipython_test\")  \nlv = c.load_balanced_view()  \n\ndef remote_wrapped(*args_fn, **kwargs_fn):\n    po=\"\"\n    try:\n        current_func = kwargs_fn.pop(\"__current_func__\")\n        local_functs = kwargs_fn.pop(\"__local_functs__\")\n        local_modules = kwargs_fn.pop(\"__local_modules__\")\n    except:\n        #raise Exception(\"Remote Func sync did not work\")\n        raise\n    modules = {}\n    for filename, filedata, modulename in local_modules:\n        #import os\n        #if os.path.exists(filename):\n        #    continue\n        orig_name = filename\n        if filedata is not None:\n            with open(filename, 'w') as f:\n                f.write(filedata)\n            orig_name = filename[:-4]\n        import importlib\n        po += \"\\n%s|%s\" %(modulename,filename[:-4])\n        modules[modulename] = importlib.import_module(orig_name)\n        po += \"\\n\" + str(globals())\n    po += \"\\nall: \" + str(globals())\n    current_func.func_globals.update(local_functs)\n    current_func.func_globals.update(modules)\n    kwargs_fn[\"out\"] = po\n    return current_func(*args_fn, **kwargs_fn)\n\ndef get_locally_defined_functions(fn):\n    import os, inspect, sys\n    base_path, _ = os.path.split(sys.executable)\n    #print(base_path)\n    local_refs = {}\n    # first get all methods which are locally defined for the method\n    for _name, _obj in fn.func_globals.items():\n        if not inspect.isfunction(_obj):\n            continue\n        try:\n            _file = inspect.getfile(_obj)\n            _file_base = os.path.split(_file)\n            if not _file_base[0].startswith(base_path):\n                #print(\"name: %s, file:%s\" % (_name, _file_base[0]))\n                local_refs[_name] = _obj\n        except TypeError:\n            # Fails for builtin types\n            pass\n    return local_refs\n\ndef get_locally_defined_modules(fn):\n    import os, inspect\n    cwd = os.getcwd()\n    #print(base_path)\n    local_functs = []\n    # first get all modules which are locally defined for the method\n    for _name, _obj in fn.func_globals.items():\n        if not inspect.ismodule(_obj):\n            continue\n        try:\n            _file = inspect.getfile(_obj)\n            _file_base = os.path.split(_file)\n            #print(\"%s|%s\" % _file_base)\n            if _file_base[0].startswith(cwd):\n                #print(\"name: %s, file:%s\" % (_name, _file_base[0]))\n                with open(_file) as f: # use the pyc\n                    data = f.read()    \n                local_functs.append((_file_base[1], data, _name))\n            else:\n                _file_name = _file_base[1]\n                if _file_name.startswith(\"__init__\"):\n                    _file_name = os.path.basename(_file_base[0])\n                    #print(_file_name)\n                local_functs.append((_file_name, None, _name))\n        except TypeError:\n            # Fails for builtin types\n            pass\n    return local_functs\n\n\n\ndef sync_local_functions(*args, **kwargs):\n    #print args\n    #print kwargs\n    # Add all local defined functions (including the current method!) to the arguments\n    kwargs[\"__local_functs__\"] = get_locally_defined_functions(args[0])\n    kwargs[\"__local_modules__\"] = get_locally_defined_modules(args[0])\n    kwargs[\"__current_func__\"] = args[0]\n    # Wrap the function, so that it uses the new arguments\n    newargs = (remote_wrapped,) + args[1:]\n    return newargs, kwargs\n\n\nimport import_test as blubber\nimport numpy as np\ndef do_work2(inputs=None, out=\"\"):\n    #return str(globals())\n#    np.random.normal(1,1,1)\n    #rest = str(globals())\n    return \"input=\" + blubber.make_happy(inputs) #+ \"\\n\" + rest + \"\\n\" + out\n\ntasks = []\n\nfor i in range(2):\n    args, kwargs = sync_local_functions(do_work2, inputs=i, )\n    tasks.append(lv.apply(*args, **kwargs))  \n\n# Take that, you ansi escape sequence bitches...\nfrom colorama import init\ninit()\n\nfor task in tasks:\n    try:\n        print(str(task.metadata))\n        print(str(task.get()))\n    except RemoteError as e:\n        e.print_traceback()\n        print e\n        if e.engine_info:\n            print \"e-info: \" + str(e.engine_info)\n        if e.ename:\n            print \"e-name:\" + str(e.ename)\n\n\n\n```\n\nWhats working:\n\n```\ndef func_a:\n    pass\nfrom numpy import np\nimport func_x from local_module\nimport local_module\nimport local_module as bar\ndef simualtion():\n    func_a(...)\n    func_x(...)\n    module.func(...)\n    bar.func(...)\n    np.random.normal(1,1,1)\n```\n\nWhats not working:\n\n```\ndef simulation():\n    from local_module import func_b\n    import local_module [as xxx]\n    # basically every local import *only* inside the function won't work\n```\n\nIf you have a way to get at the local imports _inside_ the function, then I thing this would be great...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9423627",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9423627",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9423627,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MjM2Mjc=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T17:52:49Z",
    "updated_at": "2012-10-14T17:52:49Z",
    "author_association": "MEMBER",
    "body": "@JanSchulz thanks for the sample code.  I'm not sure that I could write a version of this that would belong in library code, but it definitely belongs in docs/examples or the cookbook at least.\n\nAs you point out, one case that is not served particularly well by IPython.parallel is using a LoadBalancedView with engines arriving over time where the engines need some initialization prior to assigning tasks.  We do relatively well when you can use a DirectView to set up your engine namespaces prior to task submission, but the only hook we have for initializing an engine is the regular IPython startup code.  I don't have a great model for how to improve this use case.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9427969",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9427969",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9427969,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0Mjc5Njk=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T21:26:25Z",
    "updated_at": "2012-10-14T21:26:25Z",
    "author_association": "CONTRIBUTOR",
    "body": "@minrk  I've updated the code to also work with modules. So basically every import works but local modules/functions imported inside the function (you would need to do a `import local_module` beforehand to just push the code through).\n\nThis model currently replaces the module level `.pyc` every time the task is run, so it works on a `LoadBalanceView` but is probably not very efficient, especially when the module is big. \n\nTo solve that probably the lbv would need a \"setup\" task, which the hub would then run once on every engine before any other task from that lbv would be sent to that engine.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9429069",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9429069",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9429069,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0MjkwNjk=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-14T23:14:11Z",
    "updated_at": "2012-10-14T23:14:11Z",
    "author_association": "MEMBER",
    "body": "If we had a send_module function and a mechanism for clients to register one or more tasks to be run at startup of an engine prior to availability for new tasks, then this use case should be covered, yes?  It would look like:\n\n``` python\nimport functions\nrc.register_startup_task(send_module, functions)\n\nlv = rc.load_balanced_view()\nproceed_unchanged()\n...\n```\n\nAs opposed to the mechanism that already works today, as long as new engines are not arriving while the queue is processing (and you want your tasks to be assigned to them):\n\n``` python\nimport functions\n\ndv = rc[:]\nsend_module(dv, functions) # defined above\n\nlv = rc.load_balanced_view()\nproceed_unchanged()\n...\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/9440299",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-9440299",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 9440299,
    "node_id": "MDEyOklzc3VlQ29tbWVudDk0NDAyOTk=",
    "user": {
      "login": "jankatins",
      "id": 890156,
      "node_id": "MDQ6VXNlcjg5MDE1Ng==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/890156?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jankatins",
      "html_url": "https://github.com/jankatins",
      "followers_url": "https://api.github.com/users/jankatins/followers",
      "following_url": "https://api.github.com/users/jankatins/following{/other_user}",
      "gists_url": "https://api.github.com/users/jankatins/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jankatins/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jankatins/subscriptions",
      "organizations_url": "https://api.github.com/users/jankatins/orgs",
      "repos_url": "https://api.github.com/users/jankatins/repos",
      "events_url": "https://api.github.com/users/jankatins/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jankatins/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-10-15T10:18:56Z",
    "updated_at": "2012-10-15T10:18:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yep, the above would be nice. Then the \"help\" would simple say that by putting all your simulation code into a new module and doing an import and registering it with a start_task would be enough.\n\nI think that would be a very easy way to both explain it in the documentation and to work with it.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/142992268",
    "html_url": "https://github.com/ipython/ipython/issues/2489#issuecomment-142992268",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2489",
    "id": 142992268,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE0Mjk5MjI2OA==",
    "user": {
      "login": "RafalSkolasinski",
      "id": 10928117,
      "node_id": "MDQ6VXNlcjEwOTI4MTE3",
      "avatar_url": "https://avatars3.githubusercontent.com/u/10928117?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/RafalSkolasinski",
      "html_url": "https://github.com/RafalSkolasinski",
      "followers_url": "https://api.github.com/users/RafalSkolasinski/followers",
      "following_url": "https://api.github.com/users/RafalSkolasinski/following{/other_user}",
      "gists_url": "https://api.github.com/users/RafalSkolasinski/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/RafalSkolasinski/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/RafalSkolasinski/subscriptions",
      "organizations_url": "https://api.github.com/users/RafalSkolasinski/orgs",
      "repos_url": "https://api.github.com/users/RafalSkolasinski/repos",
      "events_url": "https://api.github.com/users/RafalSkolasinski/events{/privacy}",
      "received_events_url": "https://api.github.com/users/RafalSkolasinski/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-09-24T17:13:30Z",
    "updated_at": "2015-09-24T17:13:30Z",
    "author_association": "NONE",
    "body": "Hi, I am trying to use `send_module` function from https://github.com/ipython/ipython/issues/2489 to make my module available on remote engines. \n\nFirst of all I am suspicious about lines \n\n``` python\n        if os.path.exists(filename):\n            return False\n```\n\nbecause after sending module once, changing it locally and trying to send again would not work, am I right?\n\nAnother annoying problem I got is that anytime I try to send my module the only thing that is being written to a file on remote machine is `<memory at 0x2aac02ac43e0>` or similar stuff. \n\nI would be grateful for a help.\n"
  }
]
