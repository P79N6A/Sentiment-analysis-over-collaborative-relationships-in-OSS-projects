[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/84683554",
    "html_url": "https://github.com/ipython/ipython/pull/8108#issuecomment-84683554",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/8108",
    "id": 84683554,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0NjgzNTU0",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-03-22T19:29:43Z",
    "updated_at": "2015-03-22T19:29:43Z",
    "author_association": "MEMBER",
    "body": "I _think_ it might be correct to swallow the error and continue polling, rather than raise Empty. I'm not quite sure, though.\n\nNormally, interrupting socket.poll raises KeyboardInterrupt. It doesn't, however, when a signal handler is registered for SIGINT. Unlike normal Python calls, the underlying system call is still interrupted. So, when you get ZMQError(EINTR), that means:\n- the process received SIGINT\n- and a signal handler is trying to swallow that event\n\nSo, if you want it to behave the same as a regular Python call with a signal handler, I think it would be:\n\n``` python\n            while True:\n                try:\n                    ready = self.socket.poll(timeout)\n                except ZMQError as e:\n                    if e.errno == errno.EINTR:\n                        continue\n                    else:\n                        raise\n                else:\n                    break\n```\n\nThat does make it uninterruptible, though.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/84685550",
    "html_url": "https://github.com/ipython/ipython/pull/8108#issuecomment-84685550",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/8108",
    "id": 84685550,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0Njg1NTUw",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-03-22T19:43:42Z",
    "updated_at": "2015-03-22T19:43:42Z",
    "author_association": "MEMBER",
    "body": "I thought about that, but then it waits for the specified timeout again, regardless of how much had elapsed before it was interrupted. Is that acceptable? If it needs to subtract the elapsed time from the timeout, the logic gets more complex.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/84689965",
    "html_url": "https://github.com/ipython/ipython/pull/8108#issuecomment-84689965",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/8108",
    "id": 84689965,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg0Njg5OTY1",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-03-22T20:05:59Z",
    "updated_at": "2015-03-22T20:06:11Z",
    "author_association": "MEMBER",
    "body": "That's true. If we want to handle the timeout properly, it would look something like this:\n\n``` python\n            if timeout is None:\n                timeout = 315360000 # 10 years ~= forever\n            deadline = time.clock() + timeout\n            ready = False\n            ms = 1000 * (deadline - time.clock())\n            while ms >= 0:\n                try:\n                    ready = self.socket.poll(timeout=ms)\n                except zmq.ZMQError as e:\n                    if e.errno == errno.EINTR:\n                        ms = 1000 * (deadline - time.clock())\n                        continue\n                    else:\n                        raise\n                else:\n                    break\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/85633539",
    "html_url": "https://github.com/ipython/ipython/pull/8108#issuecomment-85633539",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/8108",
    "id": 85633539,
    "node_id": "MDEyOklzc3VlQ29tbWVudDg1NjMzNTM5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-03-24T18:30:42Z",
    "updated_at": "2015-03-24T18:30:42Z",
    "author_association": "MEMBER",
    "body": "closing in favor of #8129\n"
  }
]
