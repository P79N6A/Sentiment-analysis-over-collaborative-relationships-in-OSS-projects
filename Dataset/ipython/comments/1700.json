[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5526089",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5526089",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5526089,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MjYwODk=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-05T10:42:38Z",
    "updated_at": "2012-05-05T10:42:38Z",
    "author_association": "MEMBER",
    "body": "My rationale for this module: we are trying to shift our http://aleph.sagemath.org web service over to using ipython more.  We already use a version of the messaging protocol.  We sometimes construct custom messages that we send to the frontend, though.  For example, we send messages for embedding interactive javascript controls.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5528584",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5528584",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5528584,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Mjg1ODQ=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-05T16:55:39Z",
    "updated_at": "2012-05-05T16:55:39Z",
    "author_association": "MEMBER",
    "body": "So here's one question:\n\nShould IPython itself define a user-message for black-box extension of the message spec, or should we simply allow arbitrary new message types (i.e. ensure frontends don't raise on unrecognized message types).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5528823",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5528823",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5528823,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Mjg4MjM=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-05T17:23:05Z",
    "updated_at": "2012-05-05T17:23:16Z",
    "author_association": "MEMBER",
    "body": "I like the encapsulation and separation of official messaging spec and the custom user stuff, so I would vote for a black-box message type.  That allows a frontend to just ignore the user msg_type.  \n\nIn our case, we use the IPython message format as our content, so in effect we have the same sort of processing code, but we just peel off the user msg wrapper.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5528883",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5528883",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5528883,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Mjg4ODM=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-05T17:30:55Z",
    "updated_at": "2012-05-05T17:30:55Z",
    "author_association": "MEMBER",
    "body": "The disadvantage of having a single extension msg_type is that if you have more than one message type, you must switch _internally_, rather than being able to switch on the message type itself.  Similarly, you have to protect your own code against any other libraries that _also_ use the UserMessage in ways you don't expect.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5529106",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5529106",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5529106,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MjkxMDY=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-05T17:58:05Z",
    "updated_at": "2012-05-05T17:58:05Z",
    "author_association": "MEMBER",
    "body": "You'll have to guard against name conflicts anyway to protect against other libraries, whether it is at the top level or at the wrapped level.  What about somewhat of a compromise: encouragement to have message types that are, in effect, namespaces for custom applications.  For example, we could claim the sage namespace (the 'sage' message type).  What I think would be bad (and have many conflicts) is for every custom application to be littering the top-level msg_type namespace with random message types.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5529226",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5529226",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5529226,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1MjkyMjY=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-05T18:10:40Z",
    "updated_at": "2012-05-05T18:10:40Z",
    "author_association": "MEMBER",
    "body": "Yet another alternative would be for the user message to define a sub_type, so that it functions like a sub-namespace.\n\nThe difference from IPython's perspective between different applications having a single extensions msg_type, and multiple is nonexistent.  These are all unsupported msg_types, which are to be ignored, and it doesn't really matter if there are n*p different messages or just n.  When defining new entries in a namespace, it is always a good idea to use a project-specific prefix to avoid conflict, e.g. `sage_foo_reply`.\n\nSo the choice remains:\n\nShould projects be allowed to define their own message types, or fit all extension of the spec in the IPython-defined user-message.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5550539",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5550539",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5550539,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NTA1Mzk=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-07T13:58:38Z",
    "updated_at": "2012-05-07T13:58:38Z",
    "author_association": "MEMBER",
    "body": "And another alternative is to treat the msg_type as a dotted namespace.  For example, msg_type could be 'sage.interact_prepare', or 'sage.show_file'\n\nAs far as I'm concerned, there is little difference between these options from a coding standpoint.  So if you guys want to just make an executive call on which color the bikeshed is, that sounds great.  I can update this pull request to conform to whatever the decision is.  The key for us is to move on it, though, if at all possible.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5554063",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5554063",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5554063,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NTQwNjM=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-07T16:29:06Z",
    "updated_at": "2012-05-07T16:29:06Z",
    "author_association": "MEMBER",
    "body": "@jasongrout what are the main usage cases for this.  Initially, I am pretty -1 on the idea as it would cause there to be many incompatible ipython message implementations.  I understand that those incompatibilities could be ignored by frontends that don't know what to do with them.  But it still creates a situation where the IPython kernel is not a universal compute engine for any frontend that can speak the protocol.  You would get a fragmentation of frontend/kernels that I don't think will help in the long run.\n\nAnother way of saying it is this.  We think we have designed a message protocol that covers all possible usage cases.  If you have found a usage case that our protocol can't cover, let's tackle that specific usage case first.  Maybe we will realize that an extensible message spec is the answer, but let's not jump to that conclusion quite yet.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5556584",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5556584",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5556584,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NTY1ODQ=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-07T18:12:31Z",
    "updated_at": "2012-05-07T18:12:31Z",
    "author_association": "MEMBER",
    "body": "Sure; if you want to incorporate our extensions, that's even better :).\n\nUse-case 1: anyone who wants to experiment with adding messages to the standard protocol.  Having a way to experiment with new messages, before they make their way into the standard implementation, is very nice.\n\nUse-case 2: our specific need is a way to send various messages to a Sage frontend.  Our custom messages at this point include [1]:\n- 'files' -- this message notifies the frontend of any files that were created by the code, and lets the front end make links to those files.  I suppose this could be a display_data message, with a 'text/filename' mime type, one message per file?\n- 'session_end' - this is somewhat of an artifact of our current execution model, and may go away as we switch to a model that is closer to the ipython execution model.  This indicates that, basically, a kernel has quit (we support multiple kernels on the same page).\n- 'interact_prepare' - we've defined a small protocol for having user code request various controls to be built to make a Sage interact.  We make this a message specifying controls instead of just sending, for example, javascript since we also have iOS and Android apps that make native controls (well, actually I think the Android app is the only one that implements it right now...)\n\nWith custom messages (if the message types are properly namespaced), you don't end up with many incompatible message implementations.  Instead, you end up with messaging implementations that can use IPython code for the standard messages, along with custom code to handle custom messages.  We aren't redefining the standard messages, but just adding more, which our frontend can handle.\n\nThe end goal is to make it possible for a kernel to send to the frontend information (and meta-information about computations) that is richer than just strings (the files and interact_prepare messages are examples above).  Do you have a suggestion for a better way to send back structured information (i.e., a JSON message) from the kernel to the frontend?  Having custom message types lets us have namespaces for different messages, which is an advantage.  A frontend could even register for understanding certain message types (with the standard message types being a requirement).\n\nThis is good that you're making us think of other options so that we can compare.  Here's another way, I think: custom messages can be sent as pyout or display_data messages with custom application/x-sage (in our case) mime types?  We'd have to look inside of every pyout message to see if we had an application/sage message hiding in there, but I guess that would be doable.  Can the data format values inside of pyout and display_data messages be JSON, or do they have to be strings?\n\n[1] See https://github.com/sagemath/sagecell/blob/master/static/compute_server.js#L266 for our javascript parsing code for each of these custom types.  Right now, we use a message type of 'extension', and then the content dict is our custom message, which itself has a msg_type and in general mirrors the format of the IPython messages.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5556907",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5556907",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5556907,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NTY5MDc=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-07T18:23:45Z",
    "updated_at": "2012-05-07T18:23:45Z",
    "author_association": "MEMBER",
    "body": "In looking into things further, I suppose we can just add a `_repr_json_` method to our Interact objects, for example, which could send the JSON representation of an interact to the frontend.  The frontend would then be responsible for constructing the necessary javascript controls, etc.  Am I understanding things correctly?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5562626",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5562626",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5562626,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjI2MjY=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-07T22:32:44Z",
    "updated_at": "2012-05-07T22:32:44Z",
    "author_association": "MEMBER",
    "body": "I've explored the _repr_\\* methods a little bit more, and I want to try to implement what we've done using custom mime types (or even just the standard mime types, like application/json) instead of needing custom messages.  That's at least a good experiment to test out how flexible the IPython display system is these days.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5566468",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5566468",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5566468,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjY0Njg=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T03:11:37Z",
    "updated_at": "2012-05-08T03:11:37Z",
    "author_association": "MEMBER",
    "body": "On Mon, May 7, 2012 at 11:12 AM, Jason Grout\nreply@reply.github.com\nwrote:\n\n> Sure; if you want to incorporate our extensions, that's even better :).\n> \n> Use-case 1: anyone who wants to experiment with adding messages to the standard protocol.  Having a way to experiment with new messages, before they make their way into the standard implementation, is very nice.\n\nThis is the use case that I am not OK with.  There is a\ncomplexity/maintenance cost associated with it that I don't think is\nworth it for merely \"experimentation\".\n\n> Use-case 2: our specific need is a way to send various messages to a Sage frontend.  Our custom messages at this point include [1]:\n\nThis stuff I am interested in...\n\n> - 'files' -- this message notifies the frontend of any files that were created by the code, and lets the front end make links to those files.  I suppose this could be a display_data message, with a 'text/filename' mime type, one message per file?\n\nI could imagine this being part of the display system.  How would\nthese filenames be given.  Just the filename?  As an absolute or\nrelative URL?\n\n> - 'session_end' - this is somewhat of an artifact of our current execution model, and may go away as we switch to a model that is closer to the ipython execution model.  This indicates that, basically, a kernel has quit (we support multiple kernels on the same page).\n\nWe already have a message for this, namely the kernel status message:\n\nhttp://ipython.org/ipython-doc/dev/development/messaging.html#kernel-status\n\nWe might need to implement other values for the status, but this\nshould be sufficient no?\n\n> - 'interact_prepare' - we've defined a small protocol for having user code request various controls to be built to make a Sage interact.  We make this a message specifying controls instead of just sending, for example, javascript since we also have iOS and Android apps that make native controls (well, actually I think the Android app is the only one that implements it right now...)\n\nWhat do these JSON messages look like.  We may end up needed this\nourselves and I would rather see if we can find a common set of\nfunctionality.  While we currently envision sending back JavaScript,\nyou are right that it would be tough to use that approach while\nbuilding multiple different (like mobile) HTML clients.\n\n> With custom messages (if the message types are properly namespaced), you don't end up with many incompatible message implementations.  Instead, you end up with messaging implementations that can use IPython code for the standard messages, along with custom code to handle custom messages.  We aren't redefining the standard messages, but just adding more, which our frontend can handle.\n\nYou still fragment the frontends: I can't connect the regular IPython\nnotebook to your kernels and vice versa.  Also remember that the\nkernel has no idea what frontends are connected.  The kernel always\nneeds to be prepared to send information to any client and those\nclients have to be able to discern which messages matter.\n\n> The end goal is to make it possible for a kernel to send to the frontend information (and meta-information about computations) that is richer than just strings (the files and interact_prepare messages are examples above).  Do you have a suggestion for a better way to send back structured information (i.e., a JSON message) from the kernel to the frontend?  Having custom message types lets us have namespaces for different messages, which is an advantage.  A frontend could even register for understanding certain message types (with the standard message types being a requirement).\n\nI agree that JSON messages are definitely the way to go and I am even\nopen to the idea of allowing custom messages.  But I don't want to go\nthat way until we are convinced there is a good usage case that we\ncan't solve by improving the standard message spec.\n\n> This is good that you're making us think of other options so that we can compare.  Here's another way, I think: custom messages can be sent as pyout or display_data messages with custom application/x-sage (in our case) mime types?  We'd have to look inside of every pyout message to see if we had an application/sage message hiding in there, but I guess that would be doable.  Can the data format values inside of pyout and display_data messages be JSON, or do they have to be strings?\n\nYes, it might make sense to allow additional representations.\n\n> [1] See https://github.com/sagemath/sagecell/blob/master/static/compute_server.js#L266 for our javascript parsing code for each of these custom types.  Right now, we use a message type of 'extension', and then the content dict is our custom message, which itself has a msg_type and in general mirrors the format of the IPython messages.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/pull/1700#issuecomment-5556584\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5566491",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5566491",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5566491,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjY0OTE=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T03:14:17Z",
    "updated_at": "2012-05-08T03:14:17Z",
    "author_association": "MEMBER",
    "body": "On Mon, May 7, 2012 at 11:23 AM, Jason Grout\nreply@reply.github.com\nwrote:\n\n> In looking into things further, I suppose we can just add a `_repr_json_` method to our Interact objects, for example, which could send the JSON representation of an interact to the frontend.  The frontend would then be responsible for constructing the necessary javascript controls, etc.  Am I understanding things correctly?\n\nThere is a problem with the current _repr_json_:  we don't say\nanywhere what the format of that data is.  Different libraries could\nput different things in there that are used by different clients in\nincompatible ways.  For example, I thought I having the JSON repr of a\npython dict be a JSON structure of keys/repr(values) that could be\nexposed in the browser using a nice UI.  The problem with that is\nthere is no way of telling a client that is how it should interpret\nthat data.\n\nSeems like the _repr_json_ method needs some rethinking and part of\nthat may overlap with the discussion about custom messages.\n\n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/pull/1700#issuecomment-5556907\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5566499",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5566499",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5566499,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjY0OTk=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T03:15:07Z",
    "updated_at": "2012-05-08T03:15:07Z",
    "author_association": "MEMBER",
    "body": "On Mon, May 7, 2012 at 3:32 PM, Jason Grout\nreply@reply.github.com\nwrote:\n\n> I've explored the _repr_\\* methods a little bit more, and I want to try to implement what we've done using custom mime types (or even just the standard mime types, like application/json) instead of needing custom messages.  That's at least a good experiment to test out how flexible the IPython display system is these days.\n\nThe only problem is that currently it is pretty painful and tedious to\nadd new display types.  The system was designed for a small number of\npredefined display types and is not very extensible.\n\n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/pull/1700#issuecomment-5562626\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567128",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567128",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567128,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjcxMjg=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T04:16:58Z",
    "updated_at": "2012-05-08T04:16:58Z",
    "author_association": "MEMBER",
    "body": "On 5/7/12 10:11 PM, Brian E. Granger wrote:\n\n> On Mon, May 7, 2012 at 11:12 AM, Jason Grout\n> reply@reply.github.com wrote:\n> \n> > Use-case 1: anyone who wants to experiment with adding messages to\n> > the standard protocol.  Having a way to experiment with new\n> > messages, before they make their way into the standard\n> > implementation, is very nice.\n> \n> This is the use case that I am not OK with.  There is a\n> complexity/maintenance cost associated with it that I don't think is\n> worth it for merely \"experimentation\".\n\nI agree that the maintenance burden is too high.  Good point.\n\n> > - 'files' -- this message notifies the frontend of any files that\n> >   were created by the code, and lets the front end make links to\n> >   those files.  I suppose this could be a display_data message, with\n> >   a 'text/filename' mime type, one message per file?\n> \n> I could imagine this being part of the display system.  How would\n> these filenames be given.  Just the filename?  As an absolute or\n> relative URL?\n\nRight now they are given just as filenames, and the frontend knows how \nto construct the URL to retrieve the file.  We have a separation between \nthe web frontend and the worker process (kernel) backend.  The kernel \ndoesn't know the web address or how the files are being presented to the \nuser---that is something that is agreed on between the web frontend and \nthe browser client.\n\nIn our model, after a block of code is executed, an execute_reply \nmessage is sent, and then a cleanup process goes through the files in \nthe directory and checks to see what was created or updated.  That \ncleanup process then sends this file message, _after_ the execute_reply \nmessage is sent.  Rather than sending this list as a custom message or \nas part of the display system, I think it's better to send it as part of \nthe `payload` in the execute_reply message, populated with some code \nwe've registered with the `register_post_execute` function.\n\n> > - 'session_end' - this is somewhat of an artifact of our current\n> >   execution model, and may go away as we switch to a model that is\n> >   closer to the ipython execution model.  This indicates that,\n> >   basically, a kernel has quit (we support multiple kernels on the\n> >   same page).\n> \n> We already have a message for this, namely the kernel status\n> message:\n> \n> http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-status\n> \n>  We might need to implement other values for the status, but this\n> should be sufficient no?\n\nThat sounds like it might work well.  We just need some way of notifying \nthe front end that the kernel is no longer running so it doesn't attempt \nto send messages anymore.  Maybe just before a kernel shuts down, it can \nsend a 'quit' message.  We'd also listen for a crash message type.\n\nOn the other hand, it seems that you implemented this kernel shutdown \ndetection with a heartbeat.  Do you use the heartbeat from the web \nnotebook too?  That uses up some bandwidth, but is more robust.\n\n> > - 'interact_prepare' - we've defined a small protocol for having\n> >   user code request various controls to be built to make a Sage\n> >   interact.  We make this a message specifying controls instead of\n> >   just sending, for example, javascript since we also have iOS and\n> >   Android apps that make native controls (well, actually I think the\n> >   Android app is the only one that implements it right now...)\n> \n> What do these JSON messages look like.  We may end up needed this\n> ourselves and I would rather see if we can find a common set of\n> functionality.  While we currently envision sending back JavaScript,\n> you are right that it would be tough to use that approach while\n> building multiple different (like mobile) HTML clients.\n\nHere is an example message:\n\nhttps://gist.github.com/2632328\n\nThat's from this interact: \nhttp://aleph.sagemath.org/?z=eJxNj8tuwyAQRff-CpQNIE2lPHaVkPoR3Vmuhe0hQZ14LDxW3Hx9gXRRFleXeXAPH3EWTH4UQ_6HN3FTzF54cW2rgwalRyZOuutANYRBSt3vuOoO8kAkerUGFuF7aT6Z77lmbTNhUL0JLs7LJv3Au9m_zvCIk9zc-WjzVn3bVe1XJByFk8kDVxT3Cl7i-I0pc5AfkNzhYKEp8e4zbQhNAfizJdclP1-xXylOmMzbBS6gMoXfSFy9WmvfG5XPeuOHWYjFBDA7lOX2mD9SzanLcP_YQNXIIlATi1irfgESeWlN\n\nWe haven't totally settled on a perfect protocol (we haven't really even \nfully documented or tested what we have), but this has served us fairly \nwell.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567226",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567226",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567226,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjcyMjY=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T04:27:30Z",
    "updated_at": "2012-05-08T04:27:30Z",
    "author_association": "MEMBER",
    "body": "On 5/7/12 10:14 PM, Brian E. Granger wrote:\n\n> There is a problem with the current _repr_json_:  we don't say\n> anywhere what the format of that data is.  Different libraries could\n> put different things in there that are used by different clients in\n> incompatible ways.  For example, I thought I having the JSON repr of\n> a python dict be a JSON structure of keys/repr(values) that could be\n> exposed in the browser using a nice UI.  The problem with that is\n> there is no way of telling a client that is how it should interpret\n> that data.'\n\nWell, there is the metadata attribute in the message, but I agree that \nthe mimetype should carry information about the structure of the data.\n\n> Seems like the _repr_json_ method needs some rethinking and part of\n> that may overlap with the discussion about custom messages.\n\nYou're right.  Still I think for our purposes that a custom mimetype \napplication/x-sage-interact actually is a better fit for us than a \ncustom message.  Really, we are trying to display a function by passing \ndata about the function to the frontend.  The @interact decorator would \nattach such a display formatter to the function, and then display the \nfunction.  Clients that don't handle interacts would just display the \ntext/plain data, which would be something like 'Interactive function'.\n\nHaving a \"standard\" mimetype for such things seems even better.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567299",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567299",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567299,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjcyOTk=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T04:36:52Z",
    "updated_at": "2012-05-08T04:36:52Z",
    "author_association": "MEMBER",
    "body": "On Mon, May 7, 2012 at 9:16 PM, Jason Grout\nreply@reply.github.com\nwrote:\n\n> On 5/7/12 10:11 PM, Brian E. Granger wrote:\n> \n> > On Mon, May 7, 2012 at 11:12 AM, Jason Grout\n> > reply@reply.github.com wrote:\n> > \n> > > Use-case 1: anyone who wants to experiment with adding messages to\n> > > the standard protocol.  Having a way to experiment with new\n> > > messages, before they make their way into the standard\n> > > implementation, is very nice.\n> > \n> > This is the use case that I am not OK with.  There is a\n> > complexity/maintenance cost associated with it that I don't think is\n> > worth it for merely \"experimentation\".\n> \n> I agree that the maintenance burden is too high.  Good point.\n> \n> > > - 'files' -- this message notifies the frontend of any files that\n> > >   were created by the code, and lets the front end make links to\n> > >   those files.  I suppose this could be a display_data message, with\n> > >   a 'text/filename' mime type, one message per file?\n> > \n> > I could imagine this being part of the display system.  How would\n> > these filenames be given.  Just the filename?  As an absolute or\n> > relative URL?\n> \n> Right now they are given just as filenames, and the frontend knows how\n> to construct the URL to retrieve the file.  We have a separation between\n> the web frontend and the worker process (kernel) backend.  The kernel\n> doesn't know the web address or how the files are being presented to the\n> user---that is something that is agreed on between the web frontend and\n> the browser client.\n> \n> In our model, after a block of code is executed, an execute_reply\n> message is sent, and then a cleanup process goes through the files in\n> the directory and checks to see what was created or updated.  That\n> cleanup process then sends this file message, _after_ the execute_reply\n> message is sent.  Rather than sending this list as a custom message or\n> as part of the display system, I think it's better to send it as part of\n> the `payload` in the execute_reply message, populated with some code\n> we've registered with the `register_post_execute` function.\n\nYes, I think the payload system would be a good place for this.  We\nalready have other payloads that come back this way.\n\n> > > - 'session_end' - this is somewhat of an artifact of our current\n> > >   execution model, and may go away as we switch to a model that is\n> > >   closer to the ipython execution model.  This indicates that,\n> > >   basically, a kernel has quit (we support multiple kernels on the\n> > >   same page).\n> > \n> > We already have a message for this, namely the kernel status\n> > message:\n> > \n> > http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-status\n> > \n> >  We might need to implement other values for the status, but this\n> > should be sufficient no?\n> \n> That sounds like it might work well.  We just need some way of notifying\n> the front end that the kernel is no longer running so it doesn't attempt\n> to send messages anymore.  Maybe just before a kernel shuts down, it can\n> send a 'quit' message.  We'd also listen for a crash message type.\n\nYep.\n\n> On the other hand, it seems that you implemented this kernel shutdown\n> detection with a heartbeat.  Do you use the heartbeat from the web\n> notebook too?  That uses up some bandwidth, but is more robust.\n\nThe main notebook server does heartbeat each kernel.\n\nBut there is no reason you can't implement the status messages using\nanother approach.\n\n> > > - 'interact_prepare' - we've defined a small protocol for having\n> > >   user code request various controls to be built to make a Sage\n> > >   interact.  We make this a message specifying controls instead of\n> > >   just sending, for example, javascript since we also have iOS and\n> > >   Android apps that make native controls (well, actually I think the\n> > >   Android app is the only one that implements it right now...)\n> > \n> > What do these JSON messages look like.  We may end up needed this\n> > ourselves and I would rather see if we can find a common set of\n> > functionality.  While we currently envision sending back JavaScript,\n> > you are right that it would be tough to use that approach while\n> > building multiple different (like mobile) HTML clients.\n> \n> Here is an example message:\n> \n> https://gist.github.com/2632328\n\nOK so it is pretty complex and specific to Sage.  I could image us\ndeveloping something _like_ this, but it probably wouldn't start out\nthis complex.  I think we do need to figure out way for you to get\nthese messages back.  One related question:  for a given cell how many\nof these messages would there be?  When do they show up?\n\n> That's from this interact:\n> http://aleph.sagemath.org/?z=eJxNj8tuwyAQRff-CpQNIE2lPHaVkPoR3Vmuhe0hQZ14LDxW3Hx9gXRRFleXeXAPH3EWTH4UQ_6HN3FTzF54cW2rgwalRyZOuutANYRBSt3vuOoO8kAkerUGFuF7aT6Z77lmbTNhUL0JLs7LJv3Au9m_zvCIk9zc-WjzVn3bVe1XJByFk8kDVxT3Cl7i-I0pc5AfkNzhYKEp8e4zbQhNAfizJdclP1-xXylOmMzbBS6gMoXfSFy9WmvfG5XPeuOHWYjFBDA7lOX2mD9SzanLcP_YQNXIIlATi1irfgESeWlN\n> \n> We haven't totally settled on a perfect protocol (we haven't really even\n> fully documented or tested what we have), but this has served us fairly\n> well.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/pull/1700#issuecomment-5567128\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567374",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567374",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567374,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NjczNzQ=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T04:46:43Z",
    "updated_at": "2012-05-08T04:46:43Z",
    "author_association": "MEMBER",
    "body": "On 5/7/12 11:36 PM, Brian E. Granger wrote:\n\n> The main notebook server does heartbeat each kernel.\n> \n> But there is no reason you can't implement the status messages using\n> another approach.\n\nA heartbeat is more robust, but a quit message is less bandwidth (we \ndon't assume websockets, so it's more bandwidth and latency for us).  It \nwouldn't hurt to have both.\n\n> OK so it is pretty complex and specific to Sage.  I could image us\n> developing something _like_ this, but it probably wouldn't start out\n> this complex.  I think we do need to figure out way for you to get\n> these messages back.  One related question:  for a given cell how many\n> of these messages would there be?  When do they show up?\n\nUsually only one such message, though it really could be as many \ninteracts as are defined in the cell.  They show up when the decorator \nis called (so when the function is defined).\n\nWe could just use IPython.core.display.display to send the message, right?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567411",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567411",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567411,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Njc0MTE=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T04:51:39Z",
    "updated_at": "2012-05-08T04:51:39Z",
    "author_association": "MEMBER",
    "body": "On Mon, May 7, 2012 at 9:46 PM, Jason Grout\nreply@reply.github.com\nwrote:\n\n> On 5/7/12 11:36 PM, Brian E. Granger wrote:\n> \n> > The main notebook server does heartbeat each kernel.\n> > \n> > But there is no reason you can't implement the status messages using\n> > another approach.\n> \n> A heartbeat is more robust, but a quit message is less bandwidth (we\n> don't assume websockets, so it's more bandwidth and latency for us).  It\n> wouldn't hurt to have both.\n> \n> > OK so it is pretty complex and specific to Sage.  I could image us\n> > developing something _like_ this, but it probably wouldn't start out\n> > this complex.  I think we do need to figure out way for you to get\n> > these messages back.  One related question:  for a given cell how many\n> > of these messages would there be?  When do they show up?\n> \n> Usually only one such message, though it really could be as many\n> interacts as are defined in the cell.  They show up when the decorator\n> is called (so when the function is defined).\n> \n> We could just use IPython.core.display.display to send the message, right?\n\nYes, definitely.\n\n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/pull/1700#issuecomment-5567374\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567517",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567517",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567517,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Njc1MTc=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T05:03:19Z",
    "updated_at": "2012-05-08T05:03:19Z",
    "author_association": "MEMBER",
    "body": "Regarding kernel shutdown:\n1. We _do_ have shutdown_request/reply, and the reply goes out over IOPUB, I believe, so all frontends are notified when a clean shutdown is happening.  I do not believe we have any code in the notebook to actually _use_ the shutdown messages.\n2. The heartbeat channel is not actually forwarded to the browsers over websockets.  It is monitored by the KernelManager in the server, and only when the heartbeat fails does an event fire to the Client ([ref](https://github.com/ipython/ipython/blob/master/IPython/frontend/html/notebook/handlers.py#L446)).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5567661",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5567661",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5567661,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Njc2NjE=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T05:18:49Z",
    "updated_at": "2012-05-08T05:18:49Z",
    "author_association": "MEMBER",
    "body": "On 5/8/12 12:03 AM, Min RK wrote:\n\n> Regarding kernel shutdown:\n> 1. We _do_ have shutdown_request/reply, and the reply goes out over\n>    IOPUB, I believe, so all frontends are notified when a clean shutdown\n>    is happening.  I do not believe we have any code in the notebook to\n>    actually _use_ the shutdown messages.\n\nIn our case, we launch a new kernel, then shut it down after it has been \nidle for 60 seconds.  Our goal is to support hundreds or thousands of \nnew kernels in an hour, so having a time-limited kernel is important.  I \nsuppose we could start up another process somewhere that would monitor \nmessages from the kernel, and when it was idle for 60 seconds (or \nwhatever), could request a shutdown.\n\n> 1. The heartbeat channel is not actually forwarded to the browsers\n>    over websockets.  It is monitored by the KernelManager in the server,\n>    and only when the heartbeat fails does an event fire to the Client\n>    ([ref](https://github.com/ipython/ipython/blob/master/IPython/frontend/html/notebook/handlers.py#L446)).\n\nAh, so that is a new status message not mentioned in the docs? \n('execution_state':'dead') That sounds valuable.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5763259",
    "html_url": "https://github.com/ipython/ipython/pull/1700#issuecomment-5763259",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1700",
    "id": 5763259,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NjMyNTk=",
    "user": {
      "login": "jasongrout",
      "id": 192614,
      "node_id": "MDQ6VXNlcjE5MjYxNA==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/192614?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jasongrout",
      "html_url": "https://github.com/jasongrout",
      "followers_url": "https://api.github.com/users/jasongrout/followers",
      "following_url": "https://api.github.com/users/jasongrout/following{/other_user}",
      "gists_url": "https://api.github.com/users/jasongrout/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jasongrout/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jasongrout/subscriptions",
      "organizations_url": "https://api.github.com/users/jasongrout/orgs",
      "repos_url": "https://api.github.com/users/jasongrout/repos",
      "events_url": "https://api.github.com/users/jasongrout/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jasongrout/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-17T12:42:46Z",
    "updated_at": "2012-05-17T12:42:46Z",
    "author_association": "MEMBER",
    "body": "I'm convinced that our use-case is better managed using the existing messages, as detailed above, so I'm closing this pull request.\n"
  }
]
