[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/420500210",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-420500210",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 420500210,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDUwMDIxMA==",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-12T03:29:04Z",
    "updated_at": "2018-09-12T03:29:04Z",
    "author_association": "CONTRIBUTOR",
    "body": "I should've continued reading a bit more:\r\n\r\nhttps://github.com/ipython/ipython/blob/73d63355447cf806a440b8cfe22e8367d3665abf/docs/source/whatsnew/version7.rst#L135-L139\r\n\r\nwhich implies that event loop is not persistent at the moment.\r\n\r\n---\r\n\r\nBut it's still useful if I can run \"background\" tasks.  Maybe not in the REPL, but I'm thinking in terms of IPython extensions.  Yes, I know it does not run in parallel, only concurrently.  The usecase I have in mind is [pyjulia](https://github.com/JuliaPy/pyjulia) which has to execute code in the main thread to avoid segfault.  In general, I think it is useful for interacting with non- therad-safe libraries concurrently.\r\n\r\nTo run \"background\" tasks, how about just running a \"tick\" in `inputhook`?\r\n\r\n```diff\r\ndiff --git a/IPython/terminal/interactiveshell.py b/IPython/terminal/interactiveshell.py\r\nindex 35cb06978..bf07c8a0d 100644\r\n--- a/IPython/terminal/interactiveshell.py\r\n+++ b/IPython/terminal/interactiveshell.py\r\n@@ -1,5 +1,6 @@\r\n \"\"\"IPython terminal interface using prompt_toolkit\"\"\"\r\n\r\n+import asyncio\r\n import os\r\n import sys\r\n import warnings\r\n@@ -485,6 +486,8 @@ def mainloop(self, display_banner=DISPLAY_BANNER_DEPRECATED):\r\n     def inputhook(self, context):\r\n         if self._inputhook is not None:\r\n             self._inputhook(context)\r\n+        if self.loop_runner:\r\n+            self.loop_runner(asyncio.sleep(0))\r\n\r\n     active_eventloop = None\r\n     def enable_gui(self, gui=None):\r\n\r\n```\r\n\r\n(I don't know if `asyncio.sleep` is compatible with other loop runners. If not, maybe add a method to `loop_runner` and do appropriate `sleep(0)`?  Also, if you are only targeting `asyncio` I guess `prompt_toolkit.eventloop.use_asyncio_event_loop` would be the best option?  But then supporting `curio` and `trio` would become impossible?)\r\n\r\nAnyway, with the above change, background tasks can run:\r\n\r\n```pycon\r\nIn [1]: import asyncio\r\n   ...:\r\n   ...:\r\n   ...: async def repeat(msg, n):\r\n   ...:     for i in range(n):\r\n   ...:         print(f\"{msg} {i}\")\r\n   ...:         await asyncio.sleep(1)\r\n   ...:     return f\"{msg} done\"\r\n   ...:\r\n   ...: asyncio.ensure_future(repeat(\"background\", 10))\r\nOut[1]: <Task pending coro=<repeat() running at <ipython-input-1-07ccbef816cf>:4>>\r\n\r\nbackground 0\r\nbackground 1\r\nbackground 2\r\nbackground 3\r\nbackground 4\r\nbackground 5\r\nIn [2]:\r\n\r\nbackground 6\r\nbackground 7\r\nbackground 8\r\nbackground 9\r\nIn [2]:\r\n```\r\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/420501510",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-420501510",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 420501510,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDUwMTUxMA==",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-12T03:38:51Z",
    "updated_at": "2018-09-12T03:38:51Z",
    "author_association": "CONTRIBUTOR",
    "body": "... though I guess above example works nicely because I used `print` inside the coroutine (so that `prompt_toolkit` tries to re-draw the prompt and then re-initiate the inputhook)?\r\n\r\nIf I run:\r\n\r\n```python\r\nimport asyncio\r\n\r\nmessages = []\r\n\r\nasync def repeat(msg, n):\r\n    for i in range(n):\r\n        messages.append(f\"{msg} {i}\")\r\n        await asyncio.sleep(1)\r\n    messages.append.append(f\"{msg} done\")\r\n\r\nasyncio.ensure_future(repeat(\"background\", 10))\r\n```\r\n\r\n`messages` does not fill up after 10 sec unless I type something."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/420566168",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-420566168",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 420566168,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDU2NjE2OA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-12T08:50:42Z",
    "updated_at": "2018-09-12T08:50:42Z",
    "author_association": "MEMBER",
    "body": "Thanks for testing and the in-depth review and trying to understand how it work.\r\n\r\nYes, one of the current limitation is that a loop get created/stopped for each execution. This is because we do some weird things with prompt_toolkit (actually starting and stopping prompt_toolkit in between each `exec`. So:\r\n - background task are not processed. \r\n - non async code `>>> asyncio.create_task` does not run in aloop.\r\n\r\nActually the second one is done on purpose for people wanting to manipulate `loop` themselve. \r\n\r\nI'm pretty sure the following will work:\r\n\r\n```\r\n>>> await asyncio.sleep(0)\r\n... asyncio.create_task(aprint(\"background task\"))\r\n```\r\n\r\nIt will force the thing to run in a loop.\r\n\r\n\r\nI'm guessing we would move toward always running a loop, so once IPython kernel 5.0 is out, you can try some of these features in notebook (or Jupyter-console) and see if it fixes (some) of the problem. \r\n\r\nWe'll have to figure out trio/curio, but for now in ipykernel, we just block on their `run` method, be we could likely find a way to interleave tasks of asyncio and trio/curio.\r\n\r\nI'm temptatively marking this as 7.0 (for more docs), but I think we'll stay with current limitation for 7.0 because async support is way overdue.\r\n\r\n(We're also pushing to have async-exec in core Python in 3.8 if possible, to not have all these crazy hacks.)"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/420831847",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-420831847",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 420831847,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMDgzMTg0Nw==",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-12T23:29:38Z",
    "updated_at": "2018-09-12T23:29:38Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the detailed explanation!  Yes, allowing non-`await` statement to be eventloop-free seems to be a nice feature to have.\r\n\r\n> so once IPython kernel 5.0 is out, you can try some of these features in notebook (or Jupyter-console) and see if it fixes (some) of the problem\r\n\r\nI wanted is to run the following in `load_ipython_extension`:\r\n\r\n```python\r\nasync def polling_julia():\r\n    from julia.Base import sleep\r\n    while True:\r\n        sleep(0)\r\n        await asyncio.sleep(0.05)\r\n\r\n\r\nif asyncio.get_event_loop().is_running():  # if in ipykernel\r\n    asyncio.ensure_future(polling_julia())\r\n```\r\n\r\nIt seems that this works in ipykernel master.\r\n\r\nFor this purpose, it would be nice if inputhook is implemented using event loop.  It seems like many (but not all) inputhooks are implemented as polling in normal blocking functions.  If they were async coroutines then multiple inputhooks can be run concurrently.  Then I guess IPython can provide an API to register async coroutines as inputhooks.  But this is more like a different feature request so I'll open another issue later (so that it can be fixed when the documentation is improved).\r\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/421280945",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-421280945",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 421280945,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTI4MDk0NQ==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-14T08:56:39Z",
    "updated_at": "2018-09-14T08:56:39Z",
    "author_association": "MEMBER",
    "body": "We pushed more docs [here](https://ipython.readthedocs.io/en/latest/interactive/autoawait.html#autoawait), les me know if that's clearer. "
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/421297197",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-421297197",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 421297197,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTI5NzE5Nw==",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-14T09:44:50Z",
    "updated_at": "2018-09-14T09:44:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, it clarifies my question. Thanks a lot!\r\n\r\nBTW, reading Internals section, I cannot help trying\r\n\r\n```python\r\nIn [1]: x = 1\r\n   ...: def f():\r\n   ...:     nonlocal x\r\n   ...:     x = 10000\r\n```\r\n\r\nwhich \"\"\"should\"\"\" cause `SyntaxError`, I guess (which does happen in IPython 6 and also at module level).  Though I don't think it matters in practice.  If Python devs ask for a hundred reasons why they need async-exec maybe you can include it :)\r\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/421298987",
    "html_url": "https://github.com/ipython/ipython/issues/11303#issuecomment-421298987",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11303",
    "id": 421298987,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQyMTI5ODk4Nw==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-09-14T09:50:10Z",
    "updated_at": "2018-09-14T09:50:10Z",
    "author_association": "MEMBER",
    "body": "Gah... good catch. I'm not sure we'll try to fix this one which seem to be miss-labeled as async indeed:\r\n\r\n```\r\nIn [1]: x = 1\r\n   ...: import asyncio\r\n   ...: loop = asyncio.get_event_loop()\r\n   ...: def f():\r\n   ...:     nonlocal x\r\n   ...:     x = 10000\r\n   ...: loop\r\nOut[1]: <_UnixSelectorEventLoop running=True closed=False debug=False>\r\n```"
  }
]
