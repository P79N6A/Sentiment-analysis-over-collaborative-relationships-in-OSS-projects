[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10925192",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10925192",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10925192,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI1MTky",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T02:30:49Z",
    "updated_at": "2012-12-02T06:40:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "grrr. doctest doesn't like my examples that try to show what happens when you enter the tab key. I want to just write \"TAB\" to show what happens, but that doesn't work w.r.t doctests.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10925432",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10925432",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10925432,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI1NDMy",
    "user": {
      "login": "asmeurer",
      "id": 71486,
      "node_id": "MDQ6VXNlcjcxNDg2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/71486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asmeurer",
      "html_url": "https://github.com/asmeurer",
      "followers_url": "https://api.github.com/users/asmeurer/followers",
      "following_url": "https://api.github.com/users/asmeurer/following{/other_user}",
      "gists_url": "https://api.github.com/users/asmeurer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asmeurer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asmeurer/subscriptions",
      "organizations_url": "https://api.github.com/users/asmeurer/orgs",
      "repos_url": "https://api.github.com/users/asmeurer/repos",
      "events_url": "https://api.github.com/users/asmeurer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asmeurer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T03:01:10Z",
    "updated_at": "2012-12-02T03:01:10Z",
    "author_association": "CONTRIBUTOR",
    "body": "Shouldn't they have IPython In[1]: instead of >>>?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10926715",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10926715",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10926715,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI2NzE1",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T06:39:32Z",
    "updated_at": "2012-12-02T06:39:32Z",
    "author_association": "CONTRIBUTOR",
    "body": "This is from the reply I sent to the Python-ideas thread that @takluyver started on function annotations, but it should probably go here too.\n\nHere's the scheme that this code is using to check the annotations for tab completion information:\n\n1) Check if the function in question has an annotation.\n- If not, bail out and skip this feature. No harm, no foul.\n- If so, go to (2).\n\n2) Check if the annotation is one of _our_ objects / implements _our_ interface.\n- If so, fantastic! Start invoking this feature.\n- If not, go to (3).\n\n3) Check if the annotation is iterable, and if it is iterable check if any of the items are one of _our_ objects or implement _our_ interface.\n- If so, fantastic! Start invoking this feature.\n- If not, bail out and skip this feature.\n\n(An obvious optimization is skipping step (3) if the annotation is a string.)\n\nOne thing that I'm not sure about is whether the check for whether an annotations is _ours_ is by looking for it to subclass an (abstract) baseclass `extensions/annotations.py:AnnotationCompleterBase`, by using `hasattr` to check for the method `tab_matches` implements the behavior one of these tab matching annotations needs to provide, or by simply trying to call `obj.tab_matches` inside of a try/catch block. I've read some discussion that `hasattr` is [broken by design](http://mail.python.org/pipermail/python-dev/2010-August/103178.html), but I don't know if that's relevant to this issue.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10927231",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10927231",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10927231,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI3MjMx",
    "user": {
      "login": "asmeurer",
      "id": 71486,
      "node_id": "MDQ6VXNlcjcxNDg2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/71486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asmeurer",
      "html_url": "https://github.com/asmeurer",
      "followers_url": "https://api.github.com/users/asmeurer/followers",
      "following_url": "https://api.github.com/users/asmeurer/following{/other_user}",
      "gists_url": "https://api.github.com/users/asmeurer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asmeurer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asmeurer/subscriptions",
      "organizations_url": "https://api.github.com/users/asmeurer/orgs",
      "repos_url": "https://api.github.com/users/asmeurer/repos",
      "events_url": "https://api.github.com/users/asmeurer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asmeurer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T08:18:48Z",
    "updated_at": "2012-12-02T08:18:48Z",
    "author_association": "CONTRIBUTOR",
    "body": "I wouldn't call that broken by design.  It was just originally written with the equivalent of `except:` instead of `except AttributeError:`.  This was changed in Python 3.  I don't think it affects us here.  The worst that can happen is that it will mask an error in someone else's code, but actually, when tab completing, we might even want to mask all errors (or maybe not. It should be discussed).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10927399",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10927399",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10927399,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI3Mzk5",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T08:45:16Z",
    "updated_at": "2012-12-02T08:45:16Z",
    "author_association": "CONTRIBUTOR",
    "body": "If you keep reading the thread, the discussion morphs into the fact that `hasattr` isn't really the static introspection that you might think it is (I did). (But I don't really care about `hasattr`, and I'd rather not get bogged down.)\n\nMaybe the bigger issue is Nick Coglan's [comments](http://permalink.gmane.org/gmane.comp.python.ideas/18080) on python-ideas, saying that it would be better to use a decorator in addition to the annotation.\n\nThe syntax that he's recommending is something like:\n\n```\n>>> @tab_expansion\n>>> def foo(filename : glob_expansion('*.txt')):\n...    pass\n```\n\nWhere the `@tab_expansion` decorator moves the `glob_expansion` information from `__annotations__` into an ipython specific metadata location.\n\nAs Nick [said](http://permalink.gmane.org/gmane.comp.python.ideas/18080):\n\n> Mixing annotations intended for different consumers is a fundamentally bad idea, as it encourages unreadable code  and complex dances to avoid stepping on each other's toes. It's better to design a _separate_ API that supports composition by passing the per-parameter details directly to a decorator factory (which then adds appropriate named attributes to the function), with annotations used just as syntactic sugar for simple cases where no composition is involved.\n\nI am inclined to follow this advice, because he (1) makes a very good point and (2) is a python core developer.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10927534",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10927534",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10927534,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI3NTM0",
    "user": {
      "login": "asmeurer",
      "id": 71486,
      "node_id": "MDQ6VXNlcjcxNDg2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/71486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asmeurer",
      "html_url": "https://github.com/asmeurer",
      "followers_url": "https://api.github.com/users/asmeurer/followers",
      "following_url": "https://api.github.com/users/asmeurer/following{/other_user}",
      "gists_url": "https://api.github.com/users/asmeurer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asmeurer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asmeurer/subscriptions",
      "organizations_url": "https://api.github.com/users/asmeurer/orgs",
      "repos_url": "https://api.github.com/users/asmeurer/repos",
      "events_url": "https://api.github.com/users/asmeurer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asmeurer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T09:02:20Z",
    "updated_at": "2012-12-02T09:02:20Z",
    "author_association": "CONTRIBUTOR",
    "body": "> If you keep reading the thread, the discussion morphs into the fact that hasattr isn't really the static introspection that you might think it is (I did). \n\nNo, almost nothing in Python is static.  But that's the way the language works.  \n\n> Where the @tab_expansion decorator moves the glob_expansion information from **annotations** into an ipython specific metadata location.\n\nWe'll probably want to move it elsewhere at some point anyway, for caching purposes, because tab completion is one of those things that you want to be absolutely instantaneous, or else it significantly degrades the user experience. \n\n> I am inclined to follow this advice, because he (1) makes a very good point and (2) is a python core developer.\n\nYes, this is a good point.\n\nHere are some other thoughts I've had: \n- We might want a way to \"decorate a whole module\", so to speak.  That is to say, if you know that every function in a module acts the same way, you should be able to say that in one fell swoop.\n- Does your code work for classes?  It will need to look at `__new__` or `__init__`.\n- We also need to look at return types.  There is annotations syntax for this as well.  I think this case is easier, because we really just need to annotate the type of the object being returned.  It is only needed for things like `f(x).<TAB>`.  I guess eventually it can be made to be smarter for functions whose return type depends on the input.  \n- Combining the last two points, return types for classes that define `__new__`.\n\nMy personal use case is SymPy.  A lot of SymPy's API uses method chaining, which is annoying since it can't be tab completed unless you do it in steps (i.e., set the object to a variable, and then call the method on that variable).  For my first point, almost all public facing SymPy functions and classes take in `Expr` objects as input, and give them as output.  So it would be nice to just tell the completer to compete `Expr`s methods on basically everything, with as little work as possible on the part of me (the SymPy developer).  \n\nAside from method chaining, the case where I personally find myself wishing for better tab completion is not in the types of the arguments, but in the names of the arguments themselves, i.e., keyword arguments. When the keyword arguments are explicitly named in the function definition, the tab completer should be able to get that information straightaway, using whatever functions from the `inspect` module.  When they are given as `**kwargs`, they will have to be annotated.  \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10927926",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10927926",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10927926,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTI3OTI2",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T09:59:50Z",
    "updated_at": "2012-12-02T09:59:50Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks so much for looking over this closely. Your suggestions are top notch and really appreciated!\n\nIn no particular order:\n- It would be pretty straightforward to do a class decorator that would translate the annotations for every method. (Or a metaclass, but I prefer class decorators when the extra features of metaclasses are not required). I will add this.\n- It should be possible to run the \"decorator\" on every function in a module, either by putting something at the bottom of the file that references `dir(sys.modules[__name__])` I've always felt like putting influential code at the bottom of a file is kind of hiding it -- it would be nicer at the top. Perhaps a sympy `__init__.py` could invoke the decorators before the functions are actually imported?\n\nThanks for mentioning SymPy and your use case, because I was thinking about the feature rather narrowly, since it was (in my head) just for my own uses.\n- `f(x).<TAB>` is a good idea. It would really be another feature, since the current PR only deals with lines that have an unclosed parentheses, but that's fine. Given that I've spent a few-tens-of-hours with the `completer` codebase, I know just how to do it (assuming that the syntax for passing in the type annotations is settled).\n- Building on the previous point, how should we handle `foo(<TAB>` when `foo`'s first argument is known to take a certain type and a function `bar` is known to return instances of that same type. Currently only objects that are instances of that type would be recommended -- should `bar` and other functions known to return the type also be recommended?\n- The current code works for methods on classes, but not for class constructors/initializers. I forgot about that and will add it.\n\n> When the keyword arguments are explicitly named in the function definition, the tab completer should be able to get that information straightaway\n- I think this is already done (e.g. `In[9`), but I agree that it could be better. This is the current behavior.\n\n```\nIn [7]: def foo(longname1=1, longname2=2):\n   ...:     pass\n   ...:    \n\nIn [8]: def bar(longname1, longname2):\n   ...:     pass\n   ...: \n\nIn [9]: foo(longn<TAB>\nlongname1=  longname2= \n\nIn [10]: bar(longn<TAB>\n[system bell rings and no completions offered]\n```\n\nPerhaps we could do better by adding keyword arg complete such that `In[10]` would complete with `longname1=`?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10930945",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10930945",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10930945,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTMwOTQ1",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T15:34:31Z",
    "updated_at": "2012-12-02T15:34:31Z",
    "author_association": "MEMBER",
    "body": "I'd be wary of anything that acts on all the functions in the module,\nbecause it sounds like spooky action at a distance. When I come across some\nodd behaviour, and I go to inspect the function, I want all the definition\nand transformations to be visible and obvious.\n\nOn 2 December 2012 09:59, Robert McGibbon notifications@github.com wrote:\n\n> Thanks so much for looking over this closely. Your suggestions are top\n> notch and really appreciated!\n> \n> In no particular order:\n> - It would be pretty straightforward to do a class decorator that\n>   would translate the annotations for every method. (Or a metaclass, but I\n>   prefer class decorators when the extra features of metaclasses are not\n>   required). I will add this.\n> - It should be possible to run the \"decorator\" on every function in a\n>   module, either by putting something at the bottom of the file that\n>   references dir(sys.modules[**name**]) I've always felt like putting\n>   influential code at the bottom of a file is kind of hiding it -- it would\n>   be nicer at the top. Perhaps a sympy **init**.py could invoke the\n>   decorators before the functions are actually imported?\n> \n> Thanks for mentioning SymPy and your use case, because I was thinking\n> about the feature rather narrowly, since it was (in my head) just for my\n> own uses.\n> - f(x).<TAB> is a good idea. It would really be another feature, since\n>   the current PR only deals with lines that have an unclosed parentheses, but\n>   that's fine. Given that I've spent a few-tens-of-hours with the\n>   completer codebase, I know just how to do it (assuming that the syntax\n>   for passing in the type annotations is settled).\n> - Building on the previous point, how should we handle foo(<TAB> when\n>   foo's first argument is known to take a certain type and a function baris known to return instances of that same type. Currently only objects that\n>   are instances of that type would be recommended -- should bar and\n>   other functions known to return the type also be recommended?\n> - The current code works for methods on classes, but not for class\n>   constructors/initializers. I forgot about that and will add it.\n> \n> When the keyword arguments are explicitly named in the function\n> definition, the tab completer should be able to get that information\n> straightaway\n> - I think this is already done (e.g. In[9), but I agree that it could\n>   be better. This is the current behavior.\n> \n> In [7]: def foo(longname1=1, longname2=2):\n>    ...:     pass\n>    ...:\n> \n> In [8]: def bar(longname1, longname2):\n>    ...:     pass\n>    ...:\n> \n> In [9]: foo(longn<TAB>\n> longname1=  longname2=\n> \n> In [10]: bar(longn<TAB>\n> [system bell rings and no completions offered]\n> \n> Perhaps we could do better by adding keyword arg complete such that In[10]would complete with\n> longname1=?\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/pull/2636#issuecomment-10927926.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10934519",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10934519",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10934519,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTM0NTE5",
    "user": {
      "login": "asmeurer",
      "id": 71486,
      "node_id": "MDQ6VXNlcjcxNDg2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/71486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asmeurer",
      "html_url": "https://github.com/asmeurer",
      "followers_url": "https://api.github.com/users/asmeurer/followers",
      "following_url": "https://api.github.com/users/asmeurer/following{/other_user}",
      "gists_url": "https://api.github.com/users/asmeurer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asmeurer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asmeurer/subscriptions",
      "organizations_url": "https://api.github.com/users/asmeurer/orgs",
      "repos_url": "https://api.github.com/users/asmeurer/repos",
      "events_url": "https://api.github.com/users/asmeurer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asmeurer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-02T20:20:42Z",
    "updated_at": "2012-12-02T23:13:58Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Thanks so much for looking over this closely. Your suggestions are top notch and really appreciated!\n\nActually, I didn't look over the code closely. I'm leaving that to the\nipython devs, who know what to look for. I am more concerned about the\npublic API, as that is how I would be using it.\n\n> In no particular order:\n> - It would be pretty straightforward to do a class decorator that would translate the annotations for every method. (Or a metaclass, but I prefer class decorators when the extra features of metaclasses are not required). I will add this.\n> - It should be possible to run the \"decorator\" on every function in a module, either by putting something at the bottom of the file that references dir(sys.modules[**name**]) I've always felt like putting influential code at the bottom of a file is kind of hiding it -- it would be nicer at the top. Perhaps a sympy **init**.py could invoke the decorators before the functions are actually imported?\n> \n> Thanks for mentioning SymPy and your use case, because I was thinking about the feature rather narrowly, since it was (in my head) just for my own uses.\n> - f(x).<TAB> is a good idea. It would really be another feature, since the current PR only deals with lines that have an unclosed parentheses, but that's fine. Given that I've spent a few-tens-of-hours with the completercodebase, I know just how to do it (assuming that the syntax for passing in the type annotations is settled).\n> - Building on the previous point, how should we handle foo(<TAB> when foo's first argument is known to take a certain type and a function bar is known to return instances of that same type. Currently only objects that are instances of that type would be recommended -- should bar and other functions known to return the type also be recommended?\n\nI didn't think of that. That would be clever (and potentially useful) indeed. This just goes to show that we do need to register the completion metadata globally.\n\n> - The current code works for methods on classes, but not for class constructors/initializers. I forgot about that and will add it.\n>   \n>   > When the keyword arguments are explicitly named in the function definition, the tab completer should be able to get that information straightaway\n> - I think this is already done (e.g. In[9), but I agree that it could be better. This is the current behavior.\n\nYou mean in this branch or in ipython master?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10938478",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10938478",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10938478,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTM4NDc4",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-03T01:03:26Z",
    "updated_at": "2012-12-03T01:03:26Z",
    "author_association": "CONTRIBUTOR",
    "body": "> > Thanks so much for looking over this closely. Your suggestions are top notch and really appreciated!\n> \n> Actually, I didn't look over the code closely. I'm leaving that to the\n> ipython devs, who know what to look for. I am more concerned about the\n> public API, as that is how I would be using it.\n\nBut frankly, the implementation is easy. Getting public API \"right\" is the hard part.\n\n---\n\n>  This just goes to show that we do need to register the completion metadata globally.\n\nI'm not really sure what you mean by this. It seems logical to me that any return value annotation / tab completion info will be stored in the same location the argument annotation is -- that is, attached to the function. Perhaps in `func.__annotations__`, or perhaps in `func.__tab_completions__` or perhaps in some other attribute.\n\nConceptually, I don't see much difference between the function arguments and the return value.\n\n---\n\nkeyword argument tab completion has been the behavior since at least 0.12.1\n\n```\n$ ipython\nPython 2.7.3 (default, Jun 29 2012, 17:56:12) \nType \"copyright\", \"credits\" or \"license\" for more information.\n\nIPython 0.12.1 -- An enhanced Interactive Python.\n?         -> Introduction and overview of IPython's features.\n%quickref -> Quick reference.\nhelp      -> Python's own help system.\nobject?   -> Details about 'object', use 'object??' for extra details.\n\nIn [1]: def bar(longname1=1, longname2=2):\n   ...:     pass\n   ...: \n\nIn [2]: bar(longn\nlongname1=  longname2=  \n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10938661",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10938661",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10938661,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTM4NjYx",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-03T01:15:18Z",
    "updated_at": "2012-12-03T01:15:18Z",
    "author_association": "CONTRIBUTOR",
    "body": "@takluyver yeah, you're right. I wasn't trying to say that it should be part of the IPython API. I just meant that if @asmeurer wanted to decorate all of his functions at once, he'd have options. \n\nThe decorator will be conceptually like:\n\n```\ndef tab_complete(func):\n     # move the tab completion annotations into an ipython specific location\n     func.__tab_completions = func.__annotations__\n```\n\nSo that the normal usage is\n\n```\nfrom IPython.core.annotations import tab_complete, tab_instance\n# I don't really like the name \"tab_instance\". I should think of something better\n@tab_complete\ndef sympy_addition(x : tab_instance(Expr), y : tab_instance(Expr)):\n    pass\n```\n\nBut if @asmeurer wants to, he can avoid manually decorating all of his functions and do a \"spooky\" action at a distance decorating at the end of his module like\n\n```\nfor fname in dir(sys.modules[__name__]):\n    # you wound need some more checking in practice...\n    # but you get the idea\n    tab_complete(eval(f))\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10938670",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10938670",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10938670,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTM4Njcw",
    "user": {
      "login": "asmeurer",
      "id": 71486,
      "node_id": "MDQ6VXNlcjcxNDg2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/71486?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/asmeurer",
      "html_url": "https://github.com/asmeurer",
      "followers_url": "https://api.github.com/users/asmeurer/followers",
      "following_url": "https://api.github.com/users/asmeurer/following{/other_user}",
      "gists_url": "https://api.github.com/users/asmeurer/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/asmeurer/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/asmeurer/subscriptions",
      "organizations_url": "https://api.github.com/users/asmeurer/orgs",
      "repos_url": "https://api.github.com/users/asmeurer/repos",
      "events_url": "https://api.github.com/users/asmeurer/events{/privacy}",
      "received_events_url": "https://api.github.com/users/asmeurer/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-03T01:15:59Z",
    "updated_at": "2012-12-03T01:15:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "> keyword argument tab completion has been the behavior since at least 0.12.1\n\nDid not know that.  I guess I should try pressing tab more often, and see what works.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10988430",
    "html_url": "https://github.com/ipython/ipython/pull/2636#issuecomment-10988430",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2636",
    "id": 10988430,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTg4NDMw",
    "user": {
      "login": "rmcgibbo",
      "id": 641278,
      "node_id": "MDQ6VXNlcjY0MTI3OA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/641278?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rmcgibbo",
      "html_url": "https://github.com/rmcgibbo",
      "followers_url": "https://api.github.com/users/rmcgibbo/followers",
      "following_url": "https://api.github.com/users/rmcgibbo/following{/other_user}",
      "gists_url": "https://api.github.com/users/rmcgibbo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rmcgibbo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rmcgibbo/subscriptions",
      "organizations_url": "https://api.github.com/users/rmcgibbo/orgs",
      "repos_url": "https://api.github.com/users/rmcgibbo/repos",
      "events_url": "https://api.github.com/users/rmcgibbo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rmcgibbo/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T08:39:59Z",
    "updated_at": "2012-12-04T08:39:59Z",
    "author_association": "CONTRIBUTOR",
    "body": "I've got a lot of good ideas from this thread and from the python-ideas emails. But I don't think this code is really ready yet. I'm going to work on it more, and then I'll resubmit the PR when it's ready.\n"
  }
]
