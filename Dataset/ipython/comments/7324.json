[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68174051",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68174051",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68174051,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTc0MDUx",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-27T09:51:05Z",
    "updated_at": "2014-12-27T09:51:05Z",
    "author_association": "MEMBER",
    "body": "Faillure seem unrelated, relaunching tests.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68184276",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68184276",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68184276,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTg0Mjc2",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-27T17:15:58Z",
    "updated_at": "2014-12-27T17:15:58Z",
    "author_association": "MEMBER",
    "body": "A couple notes after working on a RemoteCheckpointManager using this refactoring:\n- To be truly generic, CheckpointManager.create_checkpoint needs to be provided some way of converting a path into a model to store.  FileCheckpointManager happens to not need this when working with FileContentsManager, because it knows that it can just copy the file from point A to point B and be ignorant of the actual content, but it's necessary in the general case.  This can be circumvented in a slightly-hacky way by doing self.parent.get(path), but that means CheckpointManager can't be used without a ContentsManager as a parent, which feels like a bit of a code smell.\n- As this change currently stands, FileCheckpointManager can only really be used with FileContentsManager or a very similar manager, because it stores checkpoints for each notebook in a directory adjacent to that notebook, which means that there has to be a local filesystem path corresponding to the directory name of the notebook being checkpointed.  An alternative storage mechanism would be to have a single .ipynb_checkpoints directory that mirrors the directory structure of the files being stored.  \n\n```\n/root\n    nb1.ipynb\n    subdir/\n       nb2.ipynb\n       .ipynb_checkpoints/\n           nb2-checkpoint.ipynb\n    .ipynb_checkpoints/\n        nb1-checkpoint.ipynb\n```\n\nThis would work regardless of whether the actual working files were stored on disk, and would also clean up some awkward logic in FileContentsManager where it ignores the checkpoints directories under various circumstances.  It would also make the notebook produce less noise in version control.  The main downside of this alternate structure would be that you would lose track of checkpoints if you changed the root of your notebook server.  My guess would be that, when working on notebooks that are long-lived enough to checkpoint, most people tend to run the server from a particular directory.  \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68189273",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68189273",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68189273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTg5Mjcz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-27T20:27:33Z",
    "updated_at": "2014-12-27T20:27:33Z",
    "author_association": "MEMBER",
    "body": "I'm not sure I like splitting the class into two. Checkpoints seems pretty deeply integrated into the contents manager, and the two classes have to have a lot of shared state and/or parallel identical configuration in order to work correctly. Can you really re-use the FileCheckpointsManager with pgcontents unchanged?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68191072",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68191072",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68191072,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTkxMDcy",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-27T21:43:44Z",
    "updated_at": "2014-12-27T21:43:44Z",
    "author_association": "MEMBER",
    "body": "> and the two classes have to have a lot of shared state and/or parallel identical configuration in order to work correctly.\n\nThe only shared state that's required right now between FileContentsManager and FileCheckpointMnaager is `root_dir`.  There's a fair amount of shared _behavior_ that's been refactored into a mixin here, but almost all of it revolves around resolving API-style paths to OS paths, which makes sense given that both classes are mapping the Contents API into the filesystem.\n\n>  Can you really re-use the FileCheckpointsManager with pgcontents unchanged?\n\nI would have to make some tweaks to my existing `PostgresContentsManager` implementation to be compatible with this, but I think it would be straightforward to make it work.  The one hitch might be the issue outlined in my notes above; namely that the current expectation for file-based checkpoints is that they're stored in a directory next to their associated file.  Since no files/directories are ever created with the purely remote ContentsManager, you'd end up with a hierarchy of directories containing only `.ipynb_checkpoints` subdirectories.\n\nI'm actually more interested in enabling the other direction: using an alternative CheckpointsManager with `FileContentsManager`.  I had originally started working on a `FileContentsManager` subclass that just overrode the checkpointing logic, but I like the idea of being able to swap in remote checkpoint storage with **any** valid contents implementation.  More importantly, this provides a smaller target for implementing remote backups with various storage engines; writing a new `ContentsManager` is a bit of an endeavor, but the smaller Checkpoints API defined here can be mapped to your database or VCS of choice with a lot less effort.  When I've got everything working tonight I'll throw up a link to my pgcontents branch so that I can make this a bit more concrete.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68191685",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68191685",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68191685,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTkxNjg1",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-27T22:08:36Z",
    "updated_at": "2014-12-27T22:08:36Z",
    "author_association": "MEMBER",
    "body": "> There's a fair amount of shared behavior that's been refactored into a mixin here, but almost all of it revolves around resolving API-style paths to OS paths\n\nWhat if the behavior differs? Will it fail? If they require or assume the behavior is the same (e.g. creating a checkpoint on the filesystem when the notebooks are not there), I'm not sure there's a benefit to the two being distinct classes.\n\n> I'm actually more interested in enabling the other direction: using an alternative CheckpointsManager with FileContentsManager.\n\nThat's more compelling to me, though if CheckpointsManagers aren't really reusable across ContentsManagers with different storage models, there isn't a practical difference between subclassing ContentsManager and overriding checkpoint methods and subclassing CheckpointsManager and configuring ContentsManager to use it.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68194351",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68194351",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68194351,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTk0MzUx",
    "user": {
      "login": "dalejung",
      "id": 610115,
      "node_id": "MDQ6VXNlcjYxMDExNQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/610115?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dalejung",
      "html_url": "https://github.com/dalejung",
      "followers_url": "https://api.github.com/users/dalejung/followers",
      "following_url": "https://api.github.com/users/dalejung/following{/other_user}",
      "gists_url": "https://api.github.com/users/dalejung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dalejung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dalejung/subscriptions",
      "organizations_url": "https://api.github.com/users/dalejung/orgs",
      "repos_url": "https://api.github.com/users/dalejung/repos",
      "events_url": "https://api.github.com/users/dalejung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dalejung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-28T00:16:36Z",
    "updated_at": "2014-12-28T00:16:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "IMO, the checkpoint api would need to be changed to allow separation. The CheckpointManager would need to receive the notebook `model` when creating a checkpoint. The restoration of a checkpoint would be the ContentManager's responsibility. It would ask the CheckpointManager for a model by `checkpoint_id` and then replace its own copy. \n\nIf you treat the `path` as a quasi notebook id then a CheckpointManager looks a lot like ContentManager. I was going to say that there should be a 3rd API that represents a backend subsystem that is shared by ContentManager and CheckpointManager. The Mixin is a similar response. \n\nPersonally, I don't really use the checkpoint gui. I use either dropbox ratpack or gists as auto revisions and restore manually if needed. Which is analogous to having a separate checkpoint manager.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68198716",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68198716",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68198716,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MTk4NzE2",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-28T05:15:32Z",
    "updated_at": "2014-12-28T05:18:32Z",
    "author_association": "MEMBER",
    "body": "> IMO, the checkpoint api would need to be changed to allow separation. The CheckpointManager would need to receive the notebook model when creating a checkpoint. The restoration of a checkpoint would be the ContentManager's responsibility.\n\nI agree with this.  The primary benefit of the existing implementation is that it allows for optimizations in the common case that you know your CheckpointManager and your ContentsManager share the same storage backend, but conceptually it's much cleaner to think of CheckpointManager as implementing a key-value store where the keys are pairs of (api_path, checkpoint_id) and the values are the raw content of files.\n\nExpanding on the above ideas a bit, I think this PR is essentially about introducing a new abstraction to the existing Contents API.  Previously, the implicit assumption was that the working version of files were stored using the same backend as checkpoints for those files.  As such, it made sense to put management of both systems in a single class.\n\nWhat I'm proposing here is that we think of Contents and Checkpoints as implementing conceptually-distinct storage backends.  ContentsManagers are responsible for maintaining the working state of a hierarchical directory structure, while CheckpointsManagers essentially implement a key-value store where keys are pairs of (api_path, checkpoint_id).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68200733",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68200733",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68200733,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjAwNzMz",
    "user": {
      "login": "dalejung",
      "id": 610115,
      "node_id": "MDQ6VXNlcjYxMDExNQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/610115?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dalejung",
      "html_url": "https://github.com/dalejung",
      "followers_url": "https://api.github.com/users/dalejung/followers",
      "following_url": "https://api.github.com/users/dalejung/following{/other_user}",
      "gists_url": "https://api.github.com/users/dalejung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dalejung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dalejung/subscriptions",
      "organizations_url": "https://api.github.com/users/dalejung/orgs",
      "repos_url": "https://api.github.com/users/dalejung/repos",
      "events_url": "https://api.github.com/users/dalejung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dalejung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-28T07:49:21Z",
    "updated_at": "2014-12-28T07:49:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "Take a quick look at this pseudo code.\n\n``` python\nclass CompositeManager(object):\n\n    def __init__(self, content, checkpoint):\n        self.content = content # ContentManager\n        self.checkpoint = checkpoint # ContentManager or CheckpointManager\n\n    def get(self, path):\n        return self.content.get(path)\n\n    def save(self, model, path, checkpoint=True):\n        model = self.content.save(model, path)\n\n        if checkpoint:\n            self.create_checkpoint(model, path)\n\n    def create_checkpoint(self, model, path):\n        mgr = self.checkpoint\n\n        # create directory\n        mgr.save({'type': 'directory'}, path)\n\n        checkpoint_id = uuid()\n        checkpoint_path = os.path.join(path, checkpoint_id)\n        mgr.save(model, checkpoint_path)\n\n    def list_checkpoints(self, path):\n        # will return directory listing\n        model = self.checkpoint.get(path, type='directory')\n        return model['content']\n\n    def restore_checkpoint(self, checkpoint_path, path):\n        checkpoint_model = self.checkpoint.get(checkpoint_path)\n        self.save(checkpoint_model, path, checkpoint=False)\n\nclass CheckpointManager(object):\n\n    def save(self, model, path):\n        # only need to implement notebook and dir\n\n    def get(self, model, path):\n        # only need to support notebook and dir\n```\n\nNotice that CheckpointManager would just be a subset of Contents api. This means you could plug in any ContentManager and use it for checkpoint duties. \n\nI agree that checkpoint and content are conceptually different, but I don't know if that should be reflected in the managers themselves. \n\nThis might not make sense to me in the morning.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68201276",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68201276",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68201276,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjAxMjc2",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-28T08:24:39Z",
    "updated_at": "2014-12-28T08:24:39Z",
    "author_association": "MEMBER",
    "body": ">  # only need to implement notebook and dir\n\nI don't think checkpointing of directories is supported anywhere, and it's not obvious to me what that would mean.\n\nI think you also need `delete` and `rename` in the checkpoint API, because without the former you'd end up with checkpoints for files that no longer exist, and without the latter you'd get out of sync when files were renamed.\n\n> Notice that CheckpointManager would just be a subset of Contents API. This means you could plug in any ContentManager and use it for checkpoint duties.\n\nWhile the idea of using ContentsManagers **as** CheckpointManagers is interesting, I don't think it would end up working as cleanly as you think.  In particular, consider the case where you were using the same class for both: if you used the implementation of FileContentsManager.save in both locations, you'd end up just overwriting the same location twice instead of stashing the checkpoint in a separate location, which is sort of the whole point of having checkpoints.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68201578",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68201578",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68201578,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjAxNTc4",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-28T08:42:50Z",
    "updated_at": "2014-12-28T08:42:50Z",
    "author_association": "MEMBER",
    "body": "> That's more compelling to me, though if CheckpointsManagers aren't really reusable across ContentsManagers with different storage models, there isn't a practical difference between subclassing ContentsManager and overriding checkpoint methods and subclassing CheckpointsManager and configuring ContentsManager to use it.\n\nAgreed that separating these responsibilities is only really useful if they're actually truly separate.  \n\nAs things stand with my proposed split, I'm pretty confident I can make a remote CheckpointManager  that's 100% agnostic to the ContentsManager being used.  This is possible because the remote manager can guarantee that its storage backend is independent of the backend used by a ContentsManager.  \n\nOn the other hand, the current FileCheckpointManager expects that API paths correspond to OS paths via the same mapping used by FileContentsManager.  That assumption could be removed if FileCheckpointManager consolidated its checkpoints into a single directory as outlined above, but I also think it would be fine if FileCheckpointManager were only usable with FileContentsManager.  That constraint could easily be enforced at construction time.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68221530",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68221530",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68221530,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjIxNTMw",
    "user": {
      "login": "dalejung",
      "id": 610115,
      "node_id": "MDQ6VXNlcjYxMDExNQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/610115?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dalejung",
      "html_url": "https://github.com/dalejung",
      "followers_url": "https://api.github.com/users/dalejung/followers",
      "following_url": "https://api.github.com/users/dalejung/following{/other_user}",
      "gists_url": "https://api.github.com/users/dalejung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dalejung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dalejung/subscriptions",
      "organizations_url": "https://api.github.com/users/dalejung/orgs",
      "repos_url": "https://api.github.com/users/dalejung/repos",
      "events_url": "https://api.github.com/users/dalejung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dalejung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-28T22:19:28Z",
    "updated_at": "2014-12-28T22:19:28Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I don't think checkpointing of directories is supported anywhere, and it's not obvious to me what that would mean.\n\nOh sorry, I meant that it wouldn't have to support `file` types. Just saving/getting directories and notebooks. \n\n> if you used the implementation of FileContentsManager.save in both locations, you'd end up just overwriting the same location twice instead of stashing the checkpoint in a separate location, which is sort of the whole point of having checkpoints.\n\nIn the implementation, the checkpoint logic doesn't use the same path. It'll create a directory with the notebook path and then save the checkpoints there i.e. `/rootdir/hello_world.ipynb/{checkpont_id}`. Also, it was a half-asleep abbreviated example, so yeah, it would need `delete` / `rename`, which are also Content api methods. Also, I'd assume that one would have a different `root_dir`.\n\nMy point is that the checkpoint strategy doesn't have to be part of the Manager. Like imagine you had multiple `CheckpointStrategy` types like:\n1. Save one file per notebook\n2. Save every checkpoint\n3. Save one checkpoint per day\n\nSo if you wanted to enhance a `CheckpointManager` with `2` logic to `3`, you'd have to make a new manager. So I guess in my pseudo code, you'd separate it even further and have\n\n``` python\nclass CompositeManager(object):\n\n    def __init__(self, content, checkpoint_strategy, checkpoint_manager):\n        self.content = content # ContentManager\n        checkpoint_strategy.set_manager(checkpoint_manager)  # ContentManager or CheckpointManager\n        self.checkpoint = checkpoint_strategy\n\n    def save(self, model, path, checkpoint=True):\n        model = self.content.save(model, path)\n\n        if checkpoint:\n            self.checkpoint.create_checkpoint(model, path)\n\nclass CheckpointStrategy(object):\n    def set_manager(self, mgr):\n        self.mgr = mgr\n\n    def create_checkpoint(self, model, path):\n        mgr = self.mgr\n\n        # create directory\n        mgr.save({'type': 'directory'}, path)\n\n        checkpoint_id = uuid()\n        checkpoint_path = os.path.join(path, checkpoint_id + '.ipynb')\n        mgr.save(model, checkpoint_path)\n```\n\nNote that this doesn't preclude one from creating a checkpoint specific type of manager. I'm more interested in the side effect of being able to use different ContentManagers for checkpointing. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68249717",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68249717",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68249717,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjQ5NzE3",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-29T11:19:17Z",
    "updated_at": "2014-12-31T01:13:19Z",
    "author_association": "MEMBER",
    "body": "Updated this based on the conversation here after finishing my prototype remote manager for https://github.com/quantopian/pgcontents/pull/3.\n\nThis now defines a distinct \"Checkpoints API\" composed of the following operations:\n- `create_checkpoint(self, nb, path)`\n- `get_checkpoint_content(self, checkpoint_id, path)`\n- `rename_checkpoint(self, checkpoint_id, old_path, new_path)`\n- `delete_checkpoint(self, checkpoint_id, path)`\n- `list_checkpoints(self, path)`\n\nThere are also two optionally-overridable methods for cases where the file -> checkpoint mapping is many-to-one and can be implemented more efficiently in bulk:\n- `delete_all_checkpoints(self, path)`\n- `rename_all_checkpoints(self, old_path, new_path)`\n\nThe more interesting feature of this is that `create_checkpoint` now takes a notebook model in addition to a path, and it's the ContentsManager's responsibility to supply the model when a checkpoint is to be created.  Similarly, `get_checkpoint_content` is expected to return notebook content of the form emitted by nbformat.read.  \n\nWith these changes, it's straightforwardly possible to write a CheckpointManager that has no dependencies on its ContentsManager.  Both [PostgresCheckpointManager](https://github.com/quantopian/pgcontents/blob/checkpoint-manager/pgcontents/checkpoints.py#L27) and [FileCheckpointManager](https://github.com/ipython/ipython/pull/7324/files#diff-997f30deba0f3d048e2f3d9950a00fa3R144) implement the protocol with no parent dependencies.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68252285",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68252285",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68252285,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjUyMjg1",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-29T12:05:27Z",
    "updated_at": "2014-12-29T12:05:27Z",
    "author_association": "MEMBER",
    "body": "@minrk I added a test to this that runs `test_checkpoints` using separate root directories for FileCheckpointManager and FileContentsManager.  The CheckpointManager creates its own directory hierarchy that mirrors the paths it's being passed, but everything still works correctly as long as the CheckpointManager has appropriate privileges in its own root.  This more or less simulates what would happen if you wanted to use file-based checkpoints with an otherwise-remote ContentsManager.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68254304",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68254304",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68254304,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4MjU0MzA0",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-29T12:43:10Z",
    "updated_at": "2014-12-29T12:43:10Z",
    "author_association": "MEMBER",
    "body": "@dalejung I'm not sure I follow your last example.  Is the idea that you want to separate the concerns of \"**how** should I load/store checkpoints\" from \"**when** should I load/store checkpoints\"?  I'd buy that that could be useful, though I'm not sure I see a clean path to doing that without designing a third API.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68417113",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68417113",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68417113,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NDE3MTEz",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-31T01:35:40Z",
    "updated_at": "2014-12-31T01:35:40Z",
    "author_association": "MEMBER",
    "body": "@minrk @dalejung sorry to be a bit noisy here, but any more thoughts on this?  I'm hoping to ship some form of remote-checkpointing contents manager for the quanto research alpha in the next couple of days, so I'm trying to get a sense of whether this or something similar is likely to be merged (such a merge wouldn't have to happen within the next few days of course, but knowing your guys' leanings will inform how I go about putting together our next release).\n\nHaving spent a couple days working with this and thinking hard about it, this refactoring _feels_ like a substantial improvement to me.  It makes the implementation of a remote checkpoint manager extremely straightforward, because `create`, `get`, `delete`, and `rename` map 1-1 with `insert`, `select`, `delete`, and `update` in a database.\n\nEven ignoring the benefit of supporting third-party extensions, encapsulating the logic of mapping API Path -> Checkpoint Location has benefits for the core IPython architecture: for example, making the \"consolidate all checkpoints to a single directory\" change that I've proposed above would become a 3-4 line change touching only `CheckpointManager.get_checkpoint_path`, and moving to something like storing checkpoints in SQLite would be easy as well (you could actually just translate the sqlalchemy code from pgcontents into raw SQL to add this).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68455789",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68455789",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68455789,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NDU1Nzg5",
    "user": {
      "login": "dalejung",
      "id": 610115,
      "node_id": "MDQ6VXNlcjYxMDExNQ==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/610115?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dalejung",
      "html_url": "https://github.com/dalejung",
      "followers_url": "https://api.github.com/users/dalejung/followers",
      "following_url": "https://api.github.com/users/dalejung/following{/other_user}",
      "gists_url": "https://api.github.com/users/dalejung/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dalejung/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dalejung/subscriptions",
      "organizations_url": "https://api.github.com/users/dalejung/orgs",
      "repos_url": "https://api.github.com/users/dalejung/repos",
      "events_url": "https://api.github.com/users/dalejung/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dalejung/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-31T17:23:22Z",
    "updated_at": "2014-12-31T17:23:22Z",
    "author_association": "CONTRIBUTOR",
    "body": "@ssanderson The new commit addresses the API changes that were needed so I'm +1. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68505444",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68505444",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68505444,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NTA1NDQ0",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-02T01:57:24Z",
    "updated_at": "2015-01-02T01:57:24Z",
    "author_association": "MEMBER",
    "body": "@minrk I removed the unncessary notary calls you pointed out.  As long as trust information is preserved by round-tripping through nbformat.read and nbformat.write, there should be no change in trust behavior.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68506418",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68506418",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68506418,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4NTA2NDE4",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-02T02:47:36Z",
    "updated_at": "2015-01-02T02:47:36Z",
    "author_association": "MEMBER",
    "body": "I've also added support for making non-notebook text files first-class citizens in the checkpoint API.\n\nPreviously checkpointing of non-notebooks worked, (and, in fact, happened on save because we ensured that there was always a checkpoint defined for **any** file), but was left out of the Contents specification.  Checkpoints for non-notebooks seems a lot more useful now that the text editor has landed, so I figured I might as well make them actually supported.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68919911",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68919911",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68919911,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4OTE5OTEx",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-06T19:35:05Z",
    "updated_at": "2015-01-06T19:35:05Z",
    "author_association": "MEMBER",
    "body": "Pushed a minor tweak to the API here: `get_checkpoint` returns a model dict suitable for passing directly to `ContentsManager.save` now.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/68979465",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-68979465",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 68979465,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY4OTc5NDY1",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T05:06:13Z",
    "updated_at": "2015-01-07T05:06:13Z",
    "author_association": "MEMBER",
    "body": "Also added an analog of `os.walk` for arbitrary ContentsManagers.  I was using this to implement synchronization between contents backends and realized that it could be written entirely in terms of the contents API.  Normally I'd put that on a separate PR, but I'm basing an internal testing deployment on the PR branch here.\n\n@minrk any more thoughts on this direction for the Contents API?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69065699",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69065699",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69065699,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDY1Njk5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T18:18:53Z",
    "updated_at": "2015-01-07T18:18:53Z",
    "author_association": "MEMBER",
    "body": "@ssanderson why did you add walk? It's not used anywhere.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69066609",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69066609",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69066609,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDY2NjA5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T18:25:07Z",
    "updated_at": "2015-01-07T18:25:07Z",
    "author_association": "MEMBER",
    "body": "I think I'm okay with splitting Contents and Checkpoints, if it really helps. I really don't like the fact that there's a mixin required for the most basic case. I think we use far too many of them already, but I'm not sure of a better way other than leaving it as one class, since I think the two really are deeply coupled.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69067233",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69067233",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69067233,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDY3MjMz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T18:29:03Z",
    "updated_at": "2015-01-07T18:29:11Z",
    "author_association": "MEMBER",
    "body": "ContentsManagers are not generic APIs for performing all kinds of actions on any files, they are abstractions for use in the REST API, so there shouldn't be any functionality in ContentsManager that's not used by the REST API. With that in mind, I wouldn't add walk, since it's unused.\n\n@ssanderson is there a way for the basic case to still use shutil copy, move actions? I still think that's the right thing to do when both are on the filesystem. There doesn't need to be an abstraction separating the two, it just gets in the way.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69068004",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69068004",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69068004,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDY4MDA0",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T18:34:06Z",
    "updated_at": "2015-01-07T18:34:06Z",
    "author_association": "MEMBER",
    "body": "@minrk I'm using `walk` in pgcontents to implement synchronization between different contents backends.  The pseudocode is roughly:\n\n```\ndef sync(mgr_1, mgr_2):\n    \"\"\"Sync contents managed by mgr_1 to mgr_2.\"\"\"\n    for dirname, subdir, files in mgr_1.walk():\n        for path in files:\n            # In reality this is slightly more complicated because there's some munging\n            # of models.\n            content = mgr_1.get(file, content=True)\n            mgr_2.save(content)\n```\n\nI'm happy to pull out `walk` and have it live in pgcontents if you'd rather not support it here.  It seemed worthwhile to add since it's a useful operation that can be written entirely in terms of the existing API.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69068455",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69068455",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69068455,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDY4NDU1",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T18:36:44Z",
    "updated_at": "2015-01-07T18:40:15Z",
    "author_association": "MEMBER",
    "body": "As far as the existing mixin implementation goes, that could be removed by renaming that class to something like `FileSystemIO` and putting an instance of it on each Manager instead of making it a mixin.  That would help with the inheritance problem of \"where the hell is this method defined?\".\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69071755",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69071755",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69071755,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDcxNzU1",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T18:57:46Z",
    "updated_at": "2015-01-07T18:57:46Z",
    "author_association": "MEMBER",
    "body": "> @ssanderson is there a way for the basic case to still use shutil copy, move actions? I still think that's the right thing to do when both are on the filesystem. There doesn't need to be an abstraction separating the two, it just gets in the way.\n\nIn my mind, the essential benefit of splitting ContentsManager from CheckpointsManager is that, if you write ContentsManager without making any assumptions about the storage backend used by your CheckpointsManager, then you're guaranteed that your implementation is still correct if you swap in a different CheckpointsManager.  Any implementation that uses `shutil.copy` or similar would require either that ContentsManager know where to move files for use by CheckpointManager, or that CheckpointManager know where to move files for use by ContentsManager, which would effectively negate the benefit of the separation.\n\nYou could of course rewrite `FileCheckpointManager.create_checkpoint` to something like:\n\n```\ndef create_checkpoint(self, path):\n    if isinstance(self.checkpoint_manager, FileCheckpointManager):\n        # Do stuff that makes assumptions about shared filesystem.\n    else:\n        super(FileContentsManager, self).create_checkpoint(path)\n```\n\nMy worries with this would be that: 1.) You lose the benefits of abstraction outlined above, and 2.) The `else` path there becomes code that's likely to be unused in normal usage, which makes it easier to introduce bugs in future changes.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69076883",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69076883",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69076883,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDc2ODgz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T19:28:44Z",
    "updated_at": "2015-01-07T19:28:44Z",
    "author_association": "MEMBER",
    "body": "@ssanderson the issue with shutil vs model seems pretty generic to abstraction - using higher abstractions, it can be correct and reusable in more situations, but it eliminates the ability to do the simpler or preferable thing when the two storage mechanisms are the same - e.g. both on the filesystem or both in the same database. You have to read the whole notebook even when you could have created the checkpoint in an entirely remote operation without any potentially expensive reads.  This is why I think we _should_ make assumptions about the ContentsManager for a given checkpoint mechanism.\n\nFor that reason, I think maybe changing the API to take just a path, and letting the CheckpointsManager decide how to get the data from ContentsManager will allow Contents and Checkpoints to be implemented in a more intimate way, which I expect to be the way to go most of the time. I would expect the 'get the generic model' route to be takenl only when the CheckpointsManager is a poor choice for use with a given ContentsManager.\n\nAs for walk, when we ship stuff we don't use, it tends to go stale and break without us knowing about it (same applies to your point about special-casing FileContentsManager with one branch taken in ~all cases, so I'm arguing against myself a bit here). This happens all the time (in-process kernel, pure Python kernel, etc.), and I would like to avoid it when possible. So it would be great if you shipped walk with pgcontents where you actually use it, rather than here where we don't, even though it's a generically useful operation.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69087270",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69087270",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69087270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDg3Mjcw",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T20:34:21Z",
    "updated_at": "2015-01-07T20:38:20Z",
    "author_association": "MEMBER",
    "body": "> the issue with shutil vs model seems pretty generic to abstraction - using higher abstractions, it can be correct and reusable in more situations, but it eliminates the ability to do the simpler or preferable thing when the two storage mechanisms are the same\n\n@minrk yep, wholeheartedly agree that this is an inherent tradeoff.  It's also not unexpected that, as the author of a library that's interested in abstracting the differences between storage backends, I'm inclined to advocate for the interface that's more abstract (and consequently more implementation-constraining), whereas as the maintainer of the default implementation, you're inclined to advocate for the interface that makes the most common case more expedient.\n\n>  I would expect the 'get the generic model' route to be taken only when the CheckpointsManager is a poor choice for use with a given ContentsManager.\n\nI disagree with this characterization a bit.  The generic model route is going to be reasonable any time you're storing checkpoints in a different backend than the base contents.  In particular, I think it's appropriate for any setup where you want to use checkpoints as a remote backup system, which is essentially what I'm doing with PostgresCheckpointManager.  \n\nPart of the difficulty here is that there are very few cases where you'd want to use `FileCheckpointsManager` with anything but `FileContentsManager`, because if you have a compelling reason to not store notebooks as local files (e.g. because your filesystem is in the cloud and the cloud is made of lies), you probably don't want to store your checkpoints locally either.  More generally, you probably want your Checkpoint storage to be at least as durable as your Contents storage.\n\n> For that reason, I think maybe changing the API to take just a path, and letting the CheckpointsManager decide how to get the data from ContentsManager will allow Contents and Checkpoints to be implemented in a more intimate way\n\nI had tried this in an earlier revision and felt like it made the `CheckpointManager` implementation too convoluted, though I think that was when I still thought the CheckpointManager would have to care about notary signing, so it might be cleaner than I had originally thought.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69093274",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69093274",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69093274,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MDkzMjc0",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-07T21:15:13Z",
    "updated_at": "2015-01-07T21:15:13Z",
    "author_association": "MEMBER",
    "body": "Moved `walk` into a pgcontents utilities directory.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/69129753",
    "html_url": "https://github.com/ipython/ipython/pull/7324#issuecomment-69129753",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7324",
    "id": 69129753,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY5MTI5NzUz",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-01-08T03:05:09Z",
    "updated_at": "2015-01-08T03:14:33Z",
    "author_association": "MEMBER",
    "body": "@minrk adba75fe40d2bd8dedd0b98cfb5a4da6cb2772ee implements your proposal for an API that does a direct copy when possible.  I'm not sure I totally buy that it's an improvement; it's trading a performance gain on `create_checkpoint` and `restore_checkpoint` for code that's more complex (all the logic that was there before is still there, but now there's also an additional \"fast path\" that does a direct copy) and more tightly coupled (FileCheckpointsManager now has to make stronger assumptions about the attributes available on FileContentsManager).  Moreover, the perf win probably isn't noticeable unless you have really big notebooks, but if that's the case you're still pulling the whole thing into memory and parsing it on every save/load, so the additional cost of doing that one more time on create probably isn't going to be the difference between usable and unusable.\n\nFor the record, from the perspective of pgcontents, I don't have much of a preference between this implementation and the previous one; the code I already have will continue to work just the same.  My gut feeling is that the added complexity here isn't worth the performance improvement, but I'll defer to your judgment on that.\n"
  }
]
