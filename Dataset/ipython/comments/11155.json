[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391800344",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391800344",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391800344,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTgwMDM0NA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T17:42:14Z",
    "updated_at": "2018-05-24T17:42:14Z",
    "author_association": "MEMBER",
    "body": "Thanks for reviving that. \r\n\r\n1) I believe in 3.7 `await` at top level is valid; should we support that only for 3.7+, and get rid of all the AST munging and complexity of making the parsing work in 3.6 and below ?\r\n\r\n2) I'm baffled by the test faillures `iptest IPython.core.tests.test_application IPython.core.tests.test_async_helpers` fails, but each independently succeed."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391800953",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391800953",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391800953,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTgwMDk1Mw==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T17:44:22Z",
    "updated_at": "2018-05-24T17:44:22Z",
    "author_association": "MEMBER",
    "body": "> I'm baffled by the test faillures iptest IPython.core.tests.test_application IPython.core.tests.test_async_helpers fails, but each independently succeed.\r\n\r\nNo, my bad, just seem to be random. `test_async_helpers` fails on its own."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391851515",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391851515",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391851515,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTg1MTUxNQ==",
    "user": {
      "login": "njsmith",
      "id": 609896,
      "node_id": "MDQ6VXNlcjYwOTg5Ng==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/609896?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/njsmith",
      "html_url": "https://github.com/njsmith",
      "followers_url": "https://api.github.com/users/njsmith/followers",
      "following_url": "https://api.github.com/users/njsmith/following{/other_user}",
      "gists_url": "https://api.github.com/users/njsmith/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/njsmith/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/njsmith/subscriptions",
      "organizations_url": "https://api.github.com/users/njsmith/orgs",
      "repos_url": "https://api.github.com/users/njsmith/repos",
      "events_url": "https://api.github.com/users/njsmith/events{/privacy}",
      "received_events_url": "https://api.github.com/users/njsmith/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T20:38:06Z",
    "updated_at": "2018-05-24T20:38:06Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I believe in 3.7 await at top level is valid\r\n\r\nI don't think this is true, unfortunately. Maybe 3.8 if someone steps up to do it; I suspect the main asyncio maintainers will be too busy to get to it.\r\n\r\n@minrk obviously tornado is the natural place to start given how ipykernel works, but have you thought at all about how to support alternative event loops?"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391860768",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391860768",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391860768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTg2MDc2OA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T21:01:50Z",
    "updated_at": "2018-05-24T21:01:50Z",
    "author_association": "MEMBER",
    "body": "> I don't think this is true, unfortunately. Maybe 3.8 if someone steps up to do it; I suspect the main asyncio maintainers will be too busy to get to it.\r\n\r\nWell, ok, maybe 3.8, but in nightly at least `ast.parse` now allows async top level.\r\n`compile` does fail though. \r\n\r\n> @minrk obviously tornado is the natural place to start given how ipykernel works, but have you thought at all about how to support alternative event loops?\r\n\r\nThat is also my concern, but then I guess we have 2 questions: \r\nDo we allow to run trio/curio code by locally blocking for the current cell ?\r\nBecause when running in ipykernel, you obviously can't run using the trio or curio runner to run async_cells. Or can we ?\r\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391867853",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391867853",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391867853,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTg2Nzg1Mw==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T21:23:57Z",
    "updated_at": "2018-05-24T21:23:57Z",
    "author_association": "MEMBER",
    "body": "I've pushed a tiny fix to the `loop_runner` to ensure it is a callable, and that if `curio`,`trio` or `asyncio` string were passed they were mapped to the correct runner, and not to the module themselves after imports.\r\n\r\nWith this running IPython under trio does seem to work, with the asyncio loop not running. Not sure what that does in a notebook though. \r\n\r\n<img width=\"652\" alt=\"screen shot 2018-05-24 at 14 21 53\" src=\"https://user-images.githubusercontent.com/335567/40514399-d8fb4ba2-5f5d-11e8-89b7-e5b42aa86f7e.png\">\r\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391881977",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391881977",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391881977,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTg4MTk3Nw==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T22:11:13Z",
    "updated_at": "2018-05-24T22:11:13Z",
    "author_association": "MEMBER",
    "body": "Ok, one of the error left is in nesting IPython, as the event loop is already running:\r\n\r\n<details>\r\n\r\n```\r\n---------------------------------------------------------------------------\r\nRuntimeError                              Traceback (most recent call last)\r\n<ipython-input-3-0c5ef5f92d7e> in <module>\r\n----> 1 IPython.embed()\r\n\r\n~/dev/ipython/IPython/terminal/embed.py in embed(**kwargs)\r\n    384         frame.f_code.co_filename, frame.f_lineno), **kwargs)\r\n    385     shell(header=header, stack_depth=2, compile_flags=compile_flags,\r\n--> 386           _call_location_id='%s:%s' % (frame.f_code.co_filename, frame.f_lineno))\r\n    387     InteractiveShellEmbed.clear_instance()\r\n    388     #restore previous instance\r\n\r\n~/dev/ipython/IPython/terminal/embed.py in __call__(self, header, local_ns, module, dummy, stack_depth, global_ns, compile_flags, **kw)\r\n    227         # our call and get the original caller's namespaces.\r\n    228         self.mainloop(local_ns, module, stack_depth=stack_depth,\r\n--> 229                       global_ns=global_ns, compile_flags=compile_flags)\r\n    230\r\n    231         self.banner2 = self.old_banner2\r\n\r\n~/dev/ipython/IPython/terminal/embed.py in mainloop(self, local_ns, module, stack_depth, display_banner, global_ns, compile_,flags)\r\n    322\r\n    323         with self.builtin_trap, self.display_trap:\r\n--> 324             self.interact()\r\n    325\r\n    326         # now, purge out the local namespace of IPython's hidden variables.\r\n\r\n~/dev/ipython/IPython/terminal/interactiveshell.py in interact(self, display_banner)\r\n    474             else:\r\n    475                 if code:\r\n--> 476                     self.run_cell(code, store_history=True)\r\n    477\r\n    478     def mainloop(self, display_banner=DISPLAY_BANNER_DEPRECATED):\r\n\r\n~/dev/ipython/IPython/core/interactiveshell.py in run_cell(self, raw_cell, store_history, silent, shell_futures)\r\n   2794                 store_history=store_history,\r\n   2795                 silent=silent,\r\n-> 2796                 shell_futures=shell_futures,\r\n   2797             )\r\n   2798         )\r\n\r\n~/dev/ipython/IPython/core/async_helpers.py in _asyncio_runner(coro)\r\n     23     \"\"\"\r\n     24     import asyncio\r\n---> 25     return asyncio.get_event_loop().run_until_complete(coro)\r\n     26\r\n     27\r\n\r\n~/anaconda/lib/python3.6/asyncio/base_events.py in run_until_complete(self, future)\r\n    452         future.add_done_callback(_run_until_complete_cb)\r\n    453         try:\r\n--> 454             self.run_forever()\r\n    455         except:\r\n    456             if new_task and future.done() and not future.cancelled():\r\n\r\n~/anaconda/lib/python3.6/asyncio/base_events.py in run_forever(self)\r\n    406         self._check_closed()\r\n    407         if self.is_running():\r\n--> 408             raise RuntimeError('This event loop is already running')\r\n    409         if events._get_running_loop() is not None:\r\n    410             raise RuntimeError(\r\n\r\nRuntimeError: This event loop is already running\r\n\r\nIn [4]: ---------------------------------------------------------------------------\r\nNameError                                 Traceback (most recent call last)\r\n<ipython-input-4-428746cf6514> in <module>\r\n----> 1 print('true' if embed1 is not ip0 else 'false')\r\n\r\nNameError: name 'embed1' is not defined\r\n```\r\n\r\n</details>\r\n\r\nThat, I'm also not sure how to fix."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/391895066",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-391895066",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 391895066,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MTg5NTA2Ng==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-24T23:20:43Z",
    "updated_at": "2018-05-24T23:20:43Z",
    "author_association": "MEMBER",
    "body": "So one possibility is to run the nested instances using different event loop; or to drop the support for nested embed (for now?) until all is async and we can run an async embed."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/392023607",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-392023607",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 392023607,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MjAyMzYwNw==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-25T11:26:02Z",
    "updated_at": "2018-05-25T11:26:02Z",
    "author_association": "MEMBER",
    "body": "If I understood correctly, from the work @Carreau did with the loop_runners, this should work with any runner as long as that runner can run `async def` coroutines, which is a reasonable requirement, right?\r\n\r\nNow, what happens in a case like ipykernel where tornado (and therefore also asyncio) is already running, I'm not sure how to deal with that. Right now, https://github.com/ipython/ipykernel/pull/323 unconditionally uses `run_cell_async` and the existing asyncio runner. We could try to handle the cases where the requested runner is not the already-running one, and do a synchronous run with the chosen eventloop.\r\n\r\ni.e.  run_cell_async could do something like:\r\n\r\n```python\r\nif loop_running:\r\n    return coro() # will be awaited outside\r\nelse:\r\n    return loop_runner(coro())\r\n```\r\n\r\n@Carreau re: nested IPythons, I'm really not sure how to solve that one. I made this a blocking wrapper around a fundamentally async core because it was the only way to get it to work without duplicating all of the methods as async and non-async variants all the way down. asyncio explicitly doesn't do nested eventloops, so too allow nested IPythons with blocking calls, we would have to make sure that we never instantiate an eventloop. Similarly, to allow nested IPythons with async, we would need to allow embedding IPython in a running eventloop, which should be quite doable (ipykernel is already doing this by simply calling `run_cell_async` instead of `run_cell`).\r\n\r\nOr we can try to violate the \"no nested eventloops\" assumption of asyncio by handling our own stack of clearing/replacing the current loop."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/392115975",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-392115975",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 392115975,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MjExNTk3NQ==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-25T16:45:39Z",
    "updated_at": "2018-05-25T16:45:39Z",
    "author_association": "MEMBER",
    "body": "I'm happy to drop the necessity to have nested IPython's but we should likely ask on the mailing list first for how many users of this feature we have.\r\n\r\nI think the need for `embed()` have two sides:\r\n 1. Running in an existing eventloop \r\n 2. Blocking an event loop and inspecting current state.\r\n\r\nI don't believe in (2) we need a lot of async integrations so I'm happy to clear/replace eventloop.\r\n\r\n@njsmith how hard would it be to have a version of `trio.run` that can be reentered ? How negatively would you react to us wrapping `trio.run` in the following context manager ?\r\n\r\n```python\r\n@contextmanager\r\ndef new_context():\r\n    import trio._core._run as tcr\r\n    old_runner = getattr(tcr.GLOBAL_RUN_CONTEXT, 'runner', None)\r\n    old_task = getattr(tcr.GLOBAL_RUN_CONTEXT, 'task', None)\r\n    if old_runner:\r\n        del tcr.GLOBAL_RUN_CONTEXT.runner\r\n    if old_task:\r\n        del tcr.GLOBAL_RUN_CONTEXT.task\r\n    yield\r\n    if old_runner:\r\n        tcr.GLOBAL_RUN_CONTEXT.runner = old_runner\r\n    if old_task:\r\n        tcr.GLOBAL_RUN_CONTEXT.task = old_task\r\n```"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/392190974",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-392190974",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 392190974,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5MjE5MDk3NA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-25T21:24:02Z",
    "updated_at": "2018-05-25T21:24:02Z",
    "author_association": "MEMBER",
    "body": "AFAICT [this commit](https://github.com/Carreau/ipython/commit/f98805633c9a15f856ba793a10275bf462e3b227) make multiple nested embedded IPython's works (using trio, and above context manager, and relying on trio's internal). You can (of course) make IPython crash if you try to switch to asyncio loop in one of the nested embedded ones."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/392986772",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-392986772",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 392986772,
    "node_id": "MDEyOklzc3VlQ29tbWVudDM5Mjk4Njc3Mg==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-05-29T23:59:19Z",
    "updated_at": "2018-05-29T23:59:19Z",
    "author_association": "MEMBER",
    "body": "cc @mrocklin, would that be of any use when interacting with dask interactively ? See  ipython/ipykernel#323 as well when running that inside a notebook. "
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/412726108",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-412726108",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 412726108,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjcyNjEwOA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-14T01:50:16Z",
    "updated_at": "2018-08-14T01:50:16Z",
    "author_association": "MEMBER",
    "body": "There is a significant amount of difference with master now and rebase is tough. In order to keep some history I'm going to close and  open a PR where all the work as been merged into a single commit and the merge commits from this removed."
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/412731558",
    "html_url": "https://github.com/ipython/ipython/pull/11155#issuecomment-412731558",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/11155",
    "id": 412731558,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQxMjczMTU1OA==",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2018-08-14T02:21:19Z",
    "updated_at": "2018-08-14T02:21:19Z",
    "author_association": "MEMBER",
    "body": "see #11265"
  }
]
