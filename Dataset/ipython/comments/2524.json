[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10667628",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10667628",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10667628,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNjY3NjI4",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-23T19:10:01Z",
    "updated_at": "2012-11-23T19:10:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "At what point can we clear the queue?  After `execute_reply`?  It is unclear to me because IPython's `execute_request` can have multiple replies, which is different from normal RPC where you can clear the queue once you get the reply.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10788344",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10788344",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10788344,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNzg4MzQ0",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-28T03:29:24Z",
    "updated_at": "2012-11-28T03:29:24Z",
    "author_association": "MEMBER",
    "body": "Can you clarify this.  Is it a problem with just the Javascript side of things or the actual kernels queue.  Please give more details.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10794119",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10794119",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10794119,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwNzk0MTE5",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-28T08:20:24Z",
    "updated_at": "2012-11-28T08:20:24Z",
    "author_association": "MEMBER",
    "body": "Only JS IIRC. \nThe callbacks are registered, but never removed from the array once called. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10813600",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10813600",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10813600,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwODEzNjAw",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-28T18:06:12Z",
    "updated_at": "2012-11-28T18:06:12Z",
    "author_association": "CONTRIBUTOR",
    "body": "I looked up the source.  In terminal console, it seems there is no callback dict as request is done in a blocking manner.  In QT console, there is callback dict for execute reply etc., but not for iopub (e.g., inline pylab).  I guess this is because in QT console, result always appears linearly (after the already executed input prompt).  In contrast, in notebook you need to remember in which cell the reply goes.\n\nLooking at ZMQTerminalInteractiveShell.run_cell, it seems that you can remove the callback after execute reply.\nhttps://github.com/ipython/ipython/blob/master/IPython/frontend/terminal/console/interactiveshell.py#L138\n\nBut I am wondering if it is safe to assume that all iopub reply reaches at the client at the point execute reply arrives.  As both messages go through different channels on different ports, isn't it possible to execute_reply message to arrive before iopub messages?  Or ZMQ solves this problem wisely?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10819614",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10819614",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10819614,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwODE5NjE0",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-28T20:21:07Z",
    "updated_at": "2012-11-28T20:21:07Z",
    "author_association": "MEMBER",
    "body": "I was also wondering what would append if a js plugin would register a callback itself. \nPotentially if we slightly change the kernel logic to send 'idle' when the kernel-side-queue is empty we could considere clearing this. \nBut there should be another way like attaching callback to the object they are coming from and clearing on new execution request...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10835440",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10835440",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10835440,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwODM1NDQw",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-29T05:08:31Z",
    "updated_at": "2012-11-29T05:08:31Z",
    "author_association": "MEMBER",
    "body": "The traffic on iopub can arrive in any order, before or after the execute reply is received.  We can't make any assumptions about ordering.  Is the issue you are worrying about that the iopub callbacks never get cleared?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10869487",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10869487",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10869487,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwODY5NDg3",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-29T22:30:00Z",
    "updated_at": "2012-11-29T22:30:00Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Is the issue you are worrying about that the iopub callbacks never get cleared?\n\nIf \"you\" is me, yes :)\n\nHow about something like \"end of IO signal\" from kernel to tell clients that it is safe to clear callback queues.  This way, you don't need to assume sequential execution and it will be thread-friendly.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10897583",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10897583",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10897583,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwODk3NTgz",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-11-30T17:43:58Z",
    "updated_at": "2012-11-30T17:43:58Z",
    "author_association": "MEMBER",
    "body": "The problem is that the kernel doesn't know when code is done running for a cell.  Users can always start a thread and that thread could keep pushing output at later times.  But there is a problem with this right now - that output will be associated with the wrong cell.  So maybe it is not too bad to do what you suggest?  Thoughts?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/10918979",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-10918979",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 10918979,
    "node_id": "MDEyOklzc3VlQ29tbWVudDEwOTE4OTc5",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-01T16:41:01Z",
    "updated_at": "2012-12-01T16:41:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "Yes, it is hard for threads created by user.  Probably we can monkey patch threading module, or provide a cell magic command to temporally do monkey patch?  The monkey patch I have in mind wraps the target function so that it sends \"end of IO signal\" if it is the last thread started in the corresponding execution request.  At least, we can provide IPython-aware threading API so that it can be used in, for example, some magic functions such as `%%script --bg`.  But I guess it will need significant change in IPython kernel.  For example, we need to record threads started in execute request and check which thread it is in when sys.stdout (OutStream) is used.\n\nBut implementing \"end of IO signal\" does not require changes for making IPython thread-aware.\n\nOther way I can think of is to move `execute_reply` to iopub channel, so that client can be sure all of the related IO replies are reached to the client at the time it gets `execute_reply`.  It's like using `execute_reply` as \"end of IO signal\".  But \"broadcasting\" execution reply on IO pub probably does not make sense.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11007185",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11007185",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11007185,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDA3MTg1",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T17:47:48Z",
    "updated_at": "2012-12-04T17:47:48Z",
    "author_association": "MEMBER",
    "body": "It is a bit more complicated than this and I don't think it will work to muck with threads like this.  Here is how the logic works:\n- When a command is sent to the kernel, we grab the id of the request.\n- Any subsequent data being written to the iopub channel gets that request id.  This enables the frontend to know which cell the output is associated with.\n- That request id stays active on iopub until the next command arrives.\n\nWhat this means for threading is that if a thread lives beyond a single command, whenever it writes to iopub, it will use whatever request id is active at the time.  This means that the threading output will appear in multiple cells - all of those that are run while the thread lives.  I don't know of any way for the thread's output to be redirected to the current original cell.\n\nHere is one option:\n- Introduce a new \"output_finished\" message on iopub.\n- This message would be sent at the same time that execute_reply is sent.\n- The frontend could use this to know when output is done.\n\nBUT,threading or other long lived code (!mycode &) would still write output to iopub.  But the frontend simply wouldn't have a callback handler for it.  But maybe this is not any worse than the current situation where that output is written to multiple cells.  So here is the big question underlying all of this:\n\nHow do we want to handle output of long lived things (threads and !mycode &)?  @fperez @minrk ? \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11011311",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11011311",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11011311,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDExMzEx",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T19:23:47Z",
    "updated_at": "2012-12-04T19:23:47Z",
    "author_association": "CONTRIBUTOR",
    "body": "The iopub behavior you described is more less the same as what I think it would be (actually I thought request id will be cleared after execute_reply).  And output_finished message you suggested is the same as what I thought it should be for the first implementation (i.e., no thread support).\n\nFor the thread support, I am imagining doing something like the following in `OutStream.flush()`:\n\n``` python\ndef flush(self):\n    data = self._buffer.getvalue()\n    content = {u'name': self.name, u'data': data}\n    parent_header = THREAD_HEADER_MAP[threading.current_thread()]\n    self.session.send(\n        self.pub_socket, u'stream', content=content,\n        parent=parent_header, ident=self.topic)\n```\n\nHere `THREAD_HEADER_MAP` is a hypothetical dict which maps a thread object to the message header object.  Then, you can use something like the following for thread target function to register the thread to this dict.\n\n``` python\ndef target_wrapper(parent_header, real_target):\n    THREAD_HEADER_MAP[threading.current_thread()] = parent_header\n    try:\n        real_target()\n    finally:\n        THREAD_HEADER_MAP.pop(threading.current_thread())\n        for (thread, header) in THREAD_HEADER_MAP.items():\n            if header == parent_header:\n                break\n        else:\n            get_session().send(self.pub_socket, u'output_finished',\n                              parent=parent_header)\n```\n\n(please imagine that `THREAD_HEADER_MAP` is a thread-safe dict)\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11015603",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11015603",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11015603,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDE1NjAz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T21:02:56Z",
    "updated_at": "2012-12-04T21:02:56Z",
    "author_association": "MEMBER",
    "body": "> Introduce a new \"output_finished\" message on iopub.\n\nThis makes sense.  The `status=idle` message already serves exactly this purpose (it is the last message of an execute_request, and on iopub channel), and IPython.parallel is using it to indicate that output is complete.  Adjusting the message spec to make this clearer and/or more explicit would probably be beneficial.  Basically an EOF-type message.\n\nRight now, we have 'status=busy / idle' messages, which _imply_ that the kernel has started / finished working on a task.  It makes a bit more sense to me to have 'started / finished task' messages that _imply_ that the kernel is busy / idle.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11015908",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11015908",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11015908,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDE1OTA4",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T21:12:54Z",
    "updated_at": "2012-12-04T21:12:54Z",
    "author_association": "MEMBER",
    "body": "@minrk makes a great point.  We already send a message at exactly the right\npoint.  Let's think about that.  In order to clear the queue, the frontend\nsimply needs to know which request just finished.  What if we extend both\nthe status busy|idle message to include the id of the request that just\nstarted.  We could rename these message types to something like\nexecute_start/execute_stop?  Maybe task_start/stop?  But I am a little\nhesitant to go changing the message spec in a way that will break\nfrontends, so may be keep the same names, just add the request id to the\nmessage content?\n\nOn Tue, Dec 4, 2012 at 1:03 PM, Min RK notifications@github.com wrote:\n\n> Introduce a new \"output_finished\" message on iopub.\n> \n> This makes sense. The status=idle message already serves exactly this\n> purpose (it is the last message of an execute_request, and on iopub\n> channel), and IPython.parallel is using it to indicate that output is\n> complete. Adjusting the message spec to make this clearer and/or more\n> explicit would probably be beneficial. Basically an EOF-type message.\n> \n> Right now, we have 'status=busy / idle' messages, which _imply_ that the\n> kernel has started / finished working on a task. It makes a bit more sense\n> to me to have 'started / finished task' messages that _imply_ that the\n> kernel is busy / idle.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11015603.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11015928",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11015928",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11015928,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDE1OTI4",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T21:13:14Z",
    "updated_at": "2012-12-04T21:13:14Z",
    "author_association": "MEMBER",
    "body": "@tkf I really don't want to hack threads like this.  We will face the same issues when users background processes using popen or `!mycode &`, so we should have a general approach to the problem.  Also, using threads in the notebook is rare, but backgrounding processes is more common.  We just need to figure out where to put the output that comes back and is not associated with a particular cell.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11016943",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11016943",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11016943,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDE2OTQz",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-04T21:41:21Z",
    "updated_at": "2012-12-04T21:41:21Z",
    "author_association": "CONTRIBUTOR",
    "body": "What do you mean by general?  If that means \"it can be applied to many cases\", I think my example is general enough.  You can write the magic to execute command in background using the thread target function I mentioned.  But of course I agree we should not do this by default.\n\nAlso I agree that the magic to execute shell command does not need to use `sys.stdout` so that there is no need for THREAD_HEADER_MAP.  But that's a specialized case which is possible only within IPython module, right?  I'd like to know how to support general code emitting iopub (sys.stdout, plot, etc...) in thread without something like THREAD_HEADER_MAP.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11068211",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11068211",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11068211,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDY4MjEx",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-06T00:35:30Z",
    "updated_at": "2012-12-06T00:35:30Z",
    "author_association": "MEMBER",
    "body": "By general, I mean that there are many ways of running external processes:\npopen, pexpect, os.system in a thread, etc.  It is too complex of a problem\nto try to handle all of these cases with this threading trick.\n\nI also don't want to build anything into the ipython core that requires\nmucking with threads and thread safe dicts, etc.\n\nOn Tue, Dec 4, 2012 at 1:41 PM, Takafumi Arakaki\nnotifications@github.comwrote:\n\n> What do you mean by general? If that means \"it can be applied to many\n> cases\", I think my example is general enough. You can write the magic to\n> execute command in background using the thread target function I mentioned.\n> But of course I agree we should not do this by default.\n> \n> Also I agree that the magic to execute shell command does not need to use\n> sys.stdout so that there is no need for THREAD_HEADER_MAP. But that's a\n> specialized case which is possible only within IPython module, right? I'd\n> like to know how to support general code emitting iopub (sys.stdout, plot,\n> etc...) in thread without something like THREAD_HEADER_MAP.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11016943.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11068247",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11068247",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11068247,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMDY4MjQ3",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-06T00:36:46Z",
    "updated_at": "2012-12-06T00:36:46Z",
    "author_association": "MEMBER",
    "body": "I also don't want to create the expectation that output from threads will\nbehave in a sensible manner.  We are better off to simply say \"that is not\nsupported\".\n\nOn Wed, Dec 5, 2012 at 4:35 PM, Brian Granger ellisonbg@gmail.com wrote:\n\n> By general, I mean that there are many ways of running external processes:\n> popen, pexpect, os.system in a thread, etc.  It is too complex of a problem\n> to try to handle all of these cases with this threading trick.\n> \n> I also don't want to build anything into the ipython core that requires\n> mucking with threads and thread safe dicts, etc.\n> \n> On Tue, Dec 4, 2012 at 1:41 PM, Takafumi Arakaki <notifications@github.com\n> \n> > wrote:\n> > \n> > What do you mean by general? If that means \"it can be applied to many\n> > cases\", I think my example is general enough. You can write the magic to\n> > execute command in background using the thread target function I mentioned.\n> > But of course I agree we should not do this by default.\n> > \n> > Also I agree that the magic to execute shell command does not need to use\n> > sys.stdout so that there is no need for THREAD_HEADER_MAP. But that's a\n> > specialized case which is possible only within IPython module, right? I'd\n> > like to know how to support general code emitting iopub (sys.stdout, plot,\n> > etc...) in thread without something like THREAD_HEADER_MAP.\n> > \n> > —\n> > Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11016943.\n> \n> ## \n> \n> Brian E. Granger\n> Cal Poly State University, San Luis Obispo\n> bgranger@calpoly.edu and ellisonbg@gmail.com\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11142506",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11142506",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11142506,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMTQyNTA2",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-07T19:17:23Z",
    "updated_at": "2012-12-07T19:17:23Z",
    "author_association": "CONTRIBUTOR",
    "body": "If you want thread support only for calling command line program, why do you need to support popen, pexpect and os.system?  If there is no thread API, what user can do is to run command line program through magic command or _subprocess_ API, right?  Then, there is no need for any general way to support thread.  And I don't uderstand why my threading trick cannot handle all these ways of running subprocess, if the trick actually works as intended.  It's not like I am 100% sure about my approach.  I am just puzzled that why you just want to restrict threading support to subprocess related stuff while talking about generality. Supporting _any_ subprocess related programming in thread is as difficult as supporting everything you can do in thread.  It's a stupid example, but you can execute any python code after running some external command.  If you are interested only in running external command, I guess it's better to just provide a magic command to do that.\n\nHaving said that, it would be really nice if IPython provide thread API.  For example, as ctypes releases GIL, you can call c function in a thread and update its output as a graph once in a while.  Most of the time (i.e. computation is done in C), you can execute code in the same notebook.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11208034",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11208034",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11208034,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjA4MDM0",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-10T17:29:40Z",
    "updated_at": "2012-12-10T17:29:40Z",
    "author_association": "MEMBER",
    "body": "But if we add a new message to the iopub channel that clears the iopub\ncallback for a cell once the execute_reply has been sent, it doesn't matter\nwhat we do with subsequent threaded output.  Even if we are clever and able\nto tag the output with the right message id, there won't be a callback to\nhandle the output.  We simply should figure out a way to handle output\nwithout a message id and not worry about trying to tag threaded output\ncorrectly at this point.\n\nOn Fri, Dec 7, 2012 at 11:17 AM, Takafumi Arakaki\nnotifications@github.comwrote:\n\n> If you want thread support only for calling command line program, why do\n> you need to support popen, pexpect and os.system? If there is no thread\n> API, what user can do is to run command line program through magic command\n> or _subprocess_ API, right? Then, there is no need for any general way to\n> support thread. And I don't uderstand why my threading trick cannot handle\n> all these ways of running subprocess, if the trick actually works as\n> intended. It's not like I am 100% sure about my approach. I am just puzzled\n> that why you just want to restrict threading support to subprocess related\n> stuff while talking about generality. Supporting _any_ subprocess related\n> programming in thread is as difficult as supporting everything you can do\n> in thread. It's a stupid example, but you can execute any python code after\n> running some external command. If you are interested only in running\n> external command, I guess it's better to just provide a magic command to do\n> that.\n> \n> Having said that, it would be really nice if IPython provide thread API.\n> For example, as ctypes releases GIL, you can call c function in a thread\n> and update its output as a graph once in a while. Most of the time (i.e.\n> computation is done in C), you can execute code in the same notebook.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11142506.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11208110",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11208110",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11208110,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjA4MTEw",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-10T17:31:31Z",
    "updated_at": "2012-12-10T17:31:31Z",
    "author_association": "MEMBER",
    "body": "But all of this is much less important than simply clearing the JS\ncallbacks, so let's focus on that.\n\nOn Mon, Dec 10, 2012 at 9:29 AM, Brian Granger ellisonbg@gmail.com wrote:\n\n> But if we add a new message to the iopub channel that clears the iopub\n> callback for a cell once the execute_reply has been sent, it doesn't matter\n> what we do with subsequent threaded output.  Even if we are clever and able\n> to tag the output with the right message id, there won't be a callback to\n> handle the output.  We simply should figure out a way to handle output\n> without a message id and not worry about trying to tag threaded output\n> correctly at this point.\n> \n> On Fri, Dec 7, 2012 at 11:17 AM, Takafumi Arakaki <\n> notifications@github.com> wrote:\n> \n> > If you want thread support only for calling command line program, why do\n> > you need to support popen, pexpect and os.system? If there is no thread\n> > API, what user can do is to run command line program through magic command\n> > or _subprocess_ API, right? Then, there is no need for any general way\n> > to support thread. And I don't uderstand why my threading trick cannot\n> > handle all these ways of running subprocess, if the trick actually works as\n> > intended. It's not like I am 100% sure about my approach. I am just puzzled\n> > that why you just want to restrict threading support to subprocess related\n> > stuff while talking about generality. Supporting _any_ subprocess\n> > related programming in thread is as difficult as supporting everything you\n> > can do in thread. It's a stupid example, but you can execute any python\n> > code after running some external command. If you are interested only in\n> > running external command, I guess it's better to just provide a magic\n> > command to do that.\n> > \n> > Having said that, it would be really nice if IPython provide thread API.\n> > For example, as ctypes releases GIL, you can call c function in a thread\n> > and update its output as a graph once in a while. Most of the time (i.e.\n> > computation is done in C), you can execute code in the same notebook.\n> > \n> > —\n> > Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11142506.\n> \n> ## \n> \n> Brian E. Granger\n> Cal Poly State University, San Luis Obispo\n> bgranger@calpoly.edu and ellisonbg@gmail.com\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11209843",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11209843",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11209843,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjA5ODQz",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-10T18:11:57Z",
    "updated_at": "2012-12-10T18:11:57Z",
    "author_association": "MEMBER",
    "body": "I propose Attaching cell id to callbacks (as callbacks are function one can attach other attributes to it) \nand remove them when the cell is re-executed/deleted. \nThis will at least add an upper-limit to the number of stored callback. \n\nNote that this will only be an issue for really long running notebook.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11219525",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11219525",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11219525,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjE5NTI1",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-10T21:46:31Z",
    "updated_at": "2012-12-10T21:46:31Z",
    "author_association": "MEMBER",
    "body": "This is a pretty simple way of going about it, but I still think we want to\nclear the queue more aggressively for long notebooks.  I am also not\nconvinced we need cell ids yet.  But I am seeing more reason to introduce\nthem.\n\nOn Mon, Dec 10, 2012 at 10:12 AM, Bussonnier Matthias <\nnotifications@github.com> wrote:\n\n> I propose Attaching cell id to callbacks (as callbacks are function one\n> can attach other attributes to it)\n> and remove them when the cell is re-executed/deleted.\n> This will at least add an upper-limit to the number of stored callback.\n> \n> Note that this will only be an issue for really long running notebook.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11209843.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11223754",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11223754",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11223754,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjIzNzU0",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-10T23:25:35Z",
    "updated_at": "2012-12-10T23:25:35Z",
    "author_association": "MEMBER",
    "body": "the request id is already in the parent_header field.  That's what parent_header has always been for - identifying the request that caused the reply / side-effect.  What's missing?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11225510",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11225510",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11225510,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjI1NTEw",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-11T00:24:13Z",
    "updated_at": "2012-12-11T00:24:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "@minrk, What @Carreau suggested was cell id.  Currently it is not in the message, right?  And I guess he is suggesting for adding JS callback queues, not message.\n\nI think once output_finished is implemented there will be no left over in the message queue.  There is no need for extra care to clear the queue, no?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11225714",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11225714",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11225714,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjI1NzE0",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-11T00:30:36Z",
    "updated_at": "2012-12-11T00:30:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "@ellisonbg \n\n> what we do with subsequent threaded output.  Even if we are clever and able\n> to tag the output with the right message id, there won't be a callback to\n> handle the output.  We simply should figure out a way to handle output\n\nThat's why I send output_finished in the last remaining thread.  That\nway, callback is not cleared until all the created threads are finished.\nBut I agree this discussion should go to other issue.  I just want to\nmake the solution for the queue more extensible.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11227140",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11227140",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11227140,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjI3MTQw",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-11T01:22:48Z",
    "updated_at": "2012-12-11T01:22:48Z",
    "author_association": "MEMBER",
    "body": "> What @Carreau suggested was cell id. Currently it is not in the message, right? And I guess he is suggesting for adding JS callback queues, not message.\n\nGotcha, I misunderstood - that was about the callback itself, not any addition to message content.\n\nSo, I guess here's the question getting back to the issue at hand: In what way does the current status=idle message not address this issue, other than being poorly named?  When status=idle is received, the iopub callback should be unregistered.  I expect that the situation is a bit different for aborted tasks, so that will need to be looked at.  Further, the callbacks can't be keyed by cell_id, because that won't work for widget-type requests, which are not associated with any cell.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11227805",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11227805",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11227805,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjI3ODA1",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-11T01:51:44Z",
    "updated_at": "2012-12-11T01:51:44Z",
    "author_association": "CONTRIBUTOR",
    "body": "I thought if you send 100 execution request at once there will be only one status=idle after the last execution reply.  But I just found out that there will be 100 replies with msg_id in its parent_header.  So I think status=idle is functionally same as output_finished I was talking about.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/11232538",
    "html_url": "https://github.com/ipython/ipython/issues/2524#issuecomment-11232538",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/2524",
    "id": 11232538,
    "node_id": "MDEyOklzc3VlQ29tbWVudDExMjMyNTM4",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-12-11T06:14:57Z",
    "updated_at": "2012-12-11T06:14:57Z",
    "author_association": "MEMBER",
    "body": "Yes, I don't think we need another message to be sent.\n\nOn Mon, Dec 10, 2012 at 5:51 PM, Takafumi Arakaki\nnotifications@github.comwrote:\n\n> I thought if you send 100 execution request at once there will be only one\n> status=idle after the last execution reply. But I just found out that there\n> will be 100 replies with msg_id in its parent_header. So I think\n> status=idle is functionally same as output_finished I was talking about.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/2524#issuecomment-11227805.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  }
]
