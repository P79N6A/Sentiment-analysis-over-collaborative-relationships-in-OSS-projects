[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67122328",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67122328",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67122328,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MTIyMzI4",
    "user": {
      "login": "ahmadia",
      "id": 512293,
      "node_id": "MDQ6VXNlcjUxMjI5Mw==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/512293?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ahmadia",
      "html_url": "https://github.com/ahmadia",
      "followers_url": "https://api.github.com/users/ahmadia/followers",
      "following_url": "https://api.github.com/users/ahmadia/following{/other_user}",
      "gists_url": "https://api.github.com/users/ahmadia/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ahmadia/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ahmadia/subscriptions",
      "organizations_url": "https://api.github.com/users/ahmadia/orgs",
      "repos_url": "https://api.github.com/users/ahmadia/repos",
      "events_url": "https://api.github.com/users/ahmadia/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ahmadia/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T07:31:33Z",
    "updated_at": "2014-12-16T07:31:33Z",
    "author_association": "CONTRIBUTOR",
    "body": "Wow!  I owe you as many beers as you can drink Thursday.  This is not a bribe at all.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67123689",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67123689",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67123689,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MTIzNjg5",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T07:49:57Z",
    "updated_at": "2014-12-16T07:49:57Z",
    "author_association": "MEMBER",
    "body": "(I am -1, not strongly but still)\n\nI saw the ML discussion so you already pointed out the problem with repo shared across machines.\nRemoving signature won't help. Json is already conflicting a lot, and clean-smudge filter\ncan take care of signature that in git. \n\nThe embeded signature with custom notary can be used for 2 things, ensuring that you trust the notebook, and insuring it's provenance with the public part of the secret. \n\nThis defeated that. \n\nIIRC the db/side file/side directory is a discussion we had a year ago at the dev meeting and we decided not to go that route, i'm concern of changing it at the last moment.\n\nWhy not make just an alternative notary ? \n\nShould we store the old v3 sig on convert to v4 ? (I guess not cause you pop the sig and write a new file which sig is stored)\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67195794",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67195794",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67195794,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MTk1Nzk0",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T17:18:37Z",
    "updated_at": "2014-12-16T17:18:37Z",
    "author_association": "MEMBER",
    "body": "> The embedded signature with custom notary can be used for 2 things, ensuring that you trust the notebook, and ensuring it's provenance with the public part of the secret.\n> Why not make just an alternative notary?\n\nThe default notary only provides the first part, and whether a notebook is trusted isn't part of the notebook itself, so storing that value in the notebook doesn't make sense. If you want to track provenance by adding info to the notebook, that should be the job of custom code, not the default behavior.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67198789",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67198789",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67198789,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MTk4Nzg5",
    "user": {
      "login": "ahmadia",
      "id": 512293,
      "node_id": "MDQ6VXNlcjUxMjI5Mw==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/512293?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ahmadia",
      "html_url": "https://github.com/ahmadia",
      "followers_url": "https://api.github.com/users/ahmadia/followers",
      "following_url": "https://api.github.com/users/ahmadia/following{/other_user}",
      "gists_url": "https://api.github.com/users/ahmadia/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ahmadia/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ahmadia/subscriptions",
      "organizations_url": "https://api.github.com/users/ahmadia/orgs",
      "repos_url": "https://api.github.com/users/ahmadia/repos",
      "events_url": "https://api.github.com/users/ahmadia/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ahmadia/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T17:37:01Z",
    "updated_at": "2014-12-16T17:37:01Z",
    "author_association": "CONTRIBUTOR",
    "body": "First, thanks again for considering this PR.  I don't fully understand the discussion between Min and Mattias here, but I want to make sure the reasons why I brought it up are elucidated if need be:\n\nThis pull request came from a short rant I made while visiting BIDS yesterday afternoon (but I have made this rant in the past to whichever Jupyter developers I've been able to corner over the last year).  The key points I tried to make were:\n- The signature unnecessarily complicates merging for the notebooks.  The signature change always forced a merge conflict, and is always saved into the notebook by default.  This significantly increases the learning curve for learners picking up the notebook and version control.  I know that the pre-commit hooks mitigate this, but the sort of users who will be flummoxed by this will be further flummoxed by needing to set up pre-commit hooks.  This is not a task that we should make hard.\n- The signature is \"local\" information, and it's usually only relevant to a user on a given system.  It's much easier to exclude if it lives in a directory or file that is easily interpreted to be ignored.\n\nI'm happy to expand upon this point or ping a few people for their opinions on this if it will help convince the developers that this is a \"real\" issue.  \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67200641",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67200641",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67200641,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjAwNjQx",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T17:48:33Z",
    "updated_at": "2014-12-16T17:48:33Z",
    "author_association": "MEMBER",
    "body": "I mostly agree with Aron's analysis of this and am overall supportive of\nthe approach Min has taken.\n\nOn Tue, Dec 16, 2014 at 9:37 AM, Aron Ahmadia notifications@github.com\nwrote:\n\n> First, thanks again for considering this PR. I don't fully understand the\n> discussion between Min and Mattias here, but I want to make sure the\n> reasons why I brought it up are elucidated if need be:\n> \n> This pull request came from a short rant I made while visiting BIDS\n> yesterday afternoon (but I have made this rant in the past to whichever\n> Jupyter developers I've been able to corner over the last year). The key\n> points I tried to make were:\n> \n>    -\n> \n>    The signature unnecessarily complicates merging for the notebooks. The\n>    signature change always forced a merge conflict, and is always saved into\n>    the notebook by default. This significantly increases the learning curve\n>    for learners picking up the notebook and version control. I know that the\n>    pre-commit hooks mitigate this, but the sort of users who will be flummoxed\n>    by this will be further flummoxed by needing to set up pre-commit hooks.\n>    This is not a task that we should make hard.\n>    -\n> \n>    The signature is \"local\" information, and it's usually only relevant\n>    to a user on a given system. It's much easier to exclude if it lives in a\n>    directory or file that is easily interpreted to be ignored.\n> \n> I'm happy to expand upon this point or ping a few people for their\n> opinions on this if it will help convince the developers that this is a\n> \"real\" issue.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/ipython/ipython/pull/7244#issuecomment-67198789.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\n@ellisonbg on Twitter and GitHub\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67202542",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67202542",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67202542,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjAyNTQy",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T18:00:05Z",
    "updated_at": "2014-12-16T18:00:05Z",
    "author_association": "MEMBER",
    "body": "- If the key for trust is the presence of a value in a user-only-writable DB, we don't actually need a secret, I believe. An attacker can produce a valid signature, but if they can't put it in the database, that doesn't matter. Of course, it doesn't technically hurt to have the secret as well - except that it makes it less clear what the security model is.\n- Do we want to provide anything for users whose home directories are on NFS mounts, or who sync this directory by one means or another? We know from experience with history that both of those can cause problems for SQLite databases, although thankfully it doesn't seem to affect too many people. Windows concept of local vs roaming user data would be handy here.\n- Profile directories can be in the cwd where the notebook server is launched - should we do anything to protect against someone unpacking a tarball with a notebook and a profile directory which trusts that notebook, and then launching the server in that directory?\n- I'm not suggesting we implement it, but I'd like to mentally sketch out what it would look like to extend this to allow shared trust databases, so that we can check the abstractions. @minrk , if you're in for lunch, maybe we can discuss this.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67215060",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67215060",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67215060,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjE1MDYw",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T19:17:35Z",
    "updated_at": "2014-12-16T19:17:35Z",
    "author_association": "MEMBER",
    "body": "> If the key for trust is the presence of a value in a user-only-writable DB, we don't actually need a secret, I believe.\n\nThat's a good point, we could just store the hash of the notebook if the database is already in the private location the key used to be.\n\n> Do we want to provide anything for users whose home directories are on NFS mounts, or who sync this directory by one means or another\n\nInstead of sqlite, we could store hashes in a tree of files a la git. It would make culling more difficult/expensive, but conflicts would be harder to cause. Putting the sqlite file on the scratch disk works for those users as well.\n\n> Profile directories can be in the cwd where the notebook server is launched \n\nThe same is true if you put a `random.py` file, so I wouldn't be too concerned about it. Alternately, we could put signatures in IPYTHONDIR instead of profile, since trust is a per-user, not per-profile concept. There just isn't already a .ipython/security directory, so I took the shortest route.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67218457",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67218457",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67218457,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjE4NDU3",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T19:39:14Z",
    "updated_at": "2014-12-16T19:39:14Z",
    "author_association": "MEMBER",
    "body": "> Instead of sqlite, we could store hashes in a tree of files a la git. It would make culling more difficult/expensive, but conflicts would be harder to cause. Putting the sqlite file on the scratch disk works for those users as well.\n\nProviding a simple recipe to put the db in /tmp or equivalent may well be sufficient. We need to be careful to ensure that only the user gets to write to it, though - for instance, we shouldn't just tell people to set it to `/tmp/nbtrust.sqlite`.\n\n> Alternately, we could put signatures in IPYTHONDIR instead of profile, since trust is a per-user, not per-profile concept. \n\nOf course, depending on what we do with profiles in the Jupyter/IPython split, this may end up happening anyway.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67221361",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67221361",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67221361,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjIxMzYx",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T19:57:56Z",
    "updated_at": "2014-12-16T19:57:56Z",
    "author_association": "MEMBER",
    "body": "> Of course, depending on what we do with profiles in the Jupyter/IPython split, this may end up happening anyway.\n\nI expect/hope profiles will not be inherited by Jupyter, that's part of why I didn't bother to add a .ipython/security dir.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67221643",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67221643",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67221643,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjIxNjQz",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T19:59:36Z",
    "updated_at": "2014-12-16T19:59:36Z",
    "author_association": "MEMBER",
    "body": "Thinking about the implications of this for services that are hosting notebooks for users:\n\nIn the current state of affairs, if I want to transfer a user's notebooks between machines, I need to ensure that their secret key is transferred between machines if I want to maintain trust.  \n\nAs of these changes, I would also have to ensure that their nbtrust.sqlite file was similarly transferred.  Is there anything else I'm missing about this?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67222659",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67222659",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67222659,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjIyNjU5",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T20:05:55Z",
    "updated_at": "2014-12-16T20:05:55Z",
    "author_association": "MEMBER",
    "body": "Also, with the upcoming release of jupyterhub, running notebooks on systems\nwith shared NFS home directories is going to be more common, so we have to\nhave to offer a solution that will work well there.\n\nOn Tue, Dec 16, 2014 at 11:59 AM, Scott Sanderson notifications@github.com\nwrote:\n\n> Thinking about the implications of this for services that are hosting\n> notebooks for users:\n> \n> In the current state of affairs, if I want to transfer a user's notebooks\n> between machines, I need to ensure that their secret key is transferred\n> between machines if I want to maintain trust.\n> \n> As of these changes, I would also have to ensure that their nbtrust.sqlite\n> file was similarly transferred. Is there anything else I'm missing about\n> this?\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/ipython/ipython/pull/7244#issuecomment-67221643.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\n@ellisonbg on Twitter and GitHub\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67224499",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67224499",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67224499,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjI0NDk5",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T20:17:24Z",
    "updated_at": "2014-12-16T20:18:14Z",
    "author_association": "MEMBER",
    "body": "One upside of this approach is that it's easily generalized to storage in a remote database.  I could imagine a world where [pgcontents](https://github.com/quantopian/pgcontents) grew a `PostgresNotebookNotary` so that trust could be persisted with no sensitive state stored on disk.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67231774",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67231774",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67231774,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjMxNzc0",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T21:05:46Z",
    "updated_at": "2014-12-16T21:05:46Z",
    "author_association": "MEMBER",
    "body": "@ellisonbg the NFS issues are generally related to concurrent access to the database from multiple NFS clients. That doesn't apply to JupyterHub, where only one notebook server is running per user.\n\n@ssanderson yup, a PostgresNotary would make sense in your case. It's also possible that you have a security environment where the needs are totally different, e.g. always untrusted, etc. or you already know who authored a notebook, in which case signing might be irrelevant.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67232161",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67232161",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67232161,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjMyMTYx",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T21:08:15Z",
    "updated_at": "2014-12-16T21:08:15Z",
    "author_association": "MEMBER",
    "body": "That's true, and it also points to a way out for the Jupyterhub case - Jupyterhub could run IPython with a notebook notary that stores signatures in a centralised place rather than each user's home directory (even if it still knows about different users, it can go into a centralised DB). That could also come in handy if e.g. an instructor wants to give students a notebook and have it open with immediate trust, because admins could have permission to trust notebooks on users' behalf.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67235337",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67235337",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67235337,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjM1MzM3",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T21:28:53Z",
    "updated_at": "2014-12-16T21:28:53Z",
    "author_association": "MEMBER",
    "body": "> even if it still knows about different users, it can go into a centralised DB\n\nI think it's tricky to make this work securely with SQLite.  If both users can access the same `.sqlite` database file, then they could modify each other's trusted signatures. afaik sqlite doesn't have any notion of row-level permissions.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67235439",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67235439",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67235439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjM1NDM5",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T21:29:27Z",
    "updated_at": "2014-12-16T21:30:27Z",
    "author_association": "MEMBER",
    "body": "I guess you could create a table for each user on the system though, which is probably fine for jupyterhub-sized deployments.\n\n**EDIT:** Even this doesn't work.\n\n> Since SQLite reads and writes an ordinary disk file, the only access permissions that can be applied are the normal file access permissions of the underlying operating system. The GRANT and REVOKE commands commonly found on client/server RDBMSes are not implemented because they would be meaningless for an embedded database engine.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67239210",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67239210",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67239210,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjM5MjEw",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T21:53:20Z",
    "updated_at": "2014-12-16T21:53:20Z",
    "author_association": "MEMBER",
    "body": "@ssanderson yes, I think implicit in the central db idea is not using sqlite, or making the requests from single-user servers via http, etc.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67242944",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67242944",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67242944,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjQyOTQ0",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T22:16:52Z",
    "updated_at": "2014-12-16T22:16:52Z",
    "author_association": "MEMBER",
    "body": "Yep, I was roughly thinking there would be a separate trust database server in that case.\n\nIs it easy to make signature checking async, so that if there has to be a request+reply to another server involved, the webserver is not blocked on that?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67250859",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67250859",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67250859,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MjUwODU5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-16T23:14:35Z",
    "updated_at": "2014-12-16T23:14:35Z",
    "author_association": "MEMBER",
    "body": "> Is it easy to make signature checking async, so that if there has to be a request+reply to another server involved, the webserver is not blocked on that?\n\nYes-ish. I can allow sign to return a Future, but to make it really work in a sensible way I would need to make ~all ContentsManager methods tornado coroutines, which is probably a can of worms we don't really want to be opening right now. I opened #7253, which _allows_ ContentsManagers to return Futures, but doesn't return any in the default case.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67361923",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67361923",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67361923,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzYxOTIz",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T17:45:54Z",
    "updated_at": "2014-12-17T17:46:01Z",
    "author_association": "MEMBER",
    "body": "Definitely like this approach for the sake of version control. My quick outline of threat vectors that came to mind on immediate skimming:\n\n##### Not having SQLite3 available at all\n\nDon't they need this anyway for ipython anyway? sqlite3 has been bundled since Python 2.5\n\n##### If an attacker wants to introduce a malicious notebook across N users now, they need not know N keys but they do need to be able to modify the signature database on N hosts (or shared storage).\n\nI'm assuming the permissions on that notebook database are the same as the secret was, so they're write in line except one requires only read access while the other requires write access. Strange sequence of steps to get a malicious notebook trusted and onto a machine in either case. Either way, still targeting an individual rather than a swath of users (unless they share a database).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67362290",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67362290",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67362290,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzYyMjkw",
    "user": {
      "login": "ahmadia",
      "id": 512293,
      "node_id": "MDQ6VXNlcjUxMjI5Mw==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/512293?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ahmadia",
      "html_url": "https://github.com/ahmadia",
      "followers_url": "https://api.github.com/users/ahmadia/followers",
      "following_url": "https://api.github.com/users/ahmadia/following{/other_user}",
      "gists_url": "https://api.github.com/users/ahmadia/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ahmadia/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ahmadia/subscriptions",
      "organizations_url": "https://api.github.com/users/ahmadia/orgs",
      "repos_url": "https://api.github.com/users/ahmadia/repos",
      "events_url": "https://api.github.com/users/ahmadia/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ahmadia/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T17:48:29Z",
    "updated_at": "2014-12-17T17:48:29Z",
    "author_association": "CONTRIBUTOR",
    "body": "On Wed, Dec 17, 2014 at 9:45 AM, Kyle Kelley notifications@github.com\nwrote:\n\n> sqlite3 has been bundled since Python 2.\n\nIt's certainly built by default if its available on the underlying system.\nThere are a number of systems that don't have sqlite installed on them by\ndefault, however.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67362729",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67362729",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67362729,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzYyNzI5",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T17:51:15Z",
    "updated_at": "2014-12-17T17:51:15Z",
    "author_association": "MEMBER",
    "body": "Also problem is that if you have a DB with 64k sig, then is 64k time easier to fid a notebook with sig that conflict. So even getting read access to db is dangerous.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67367021",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67367021",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67367021,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzY3MDIx",
    "user": {
      "login": "rgbkrk",
      "id": 836375,
      "node_id": "MDQ6VXNlcjgzNjM3NQ==",
      "avatar_url": "https://avatars0.githubusercontent.com/u/836375?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rgbkrk",
      "html_url": "https://github.com/rgbkrk",
      "followers_url": "https://api.github.com/users/rgbkrk/followers",
      "following_url": "https://api.github.com/users/rgbkrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/rgbkrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rgbkrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rgbkrk/subscriptions",
      "organizations_url": "https://api.github.com/users/rgbkrk/orgs",
      "repos_url": "https://api.github.com/users/rgbkrk/repos",
      "events_url": "https://api.github.com/users/rgbkrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rgbkrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T18:19:31Z",
    "updated_at": "2014-12-17T18:19:31Z",
    "author_association": "MEMBER",
    "body": "Oh come now, 64k is nothing compared to 2**512. In addition, even if you find a conflict, is it actually a valid notebook?\n\nAlright, you got me thinking. Lets say your payload that runs javascript is at the top of the notebook. You then change the output cell searching for the hash you want. Build a big ol' table. I think that's well beyond our domain of protection, but still appropriate to think about. In fact, the one notebook I as an attacker would want collide signatures with is a single cell blank notebook.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67367987",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67367987",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67367987,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzY3OTg3",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T18:26:11Z",
    "updated_at": "2014-12-17T18:26:11Z",
    "author_association": "MEMBER",
    "body": "Sqlite is needed for the notebook server, if I remember correctly (for storing the connections between kernels, sessions and notebooks). Plain terminal IPython will work without sqlite, though you lose history persistence.\n\n> Also problem is that if you have a DB with 64k sig, then is 64k time easier to fid a notebook with sig that conflict\n\n```\nIn [5]: 2**256 / (64e3)\nOut[5]: 1.8092513943330656e+72\n```\n\nI don't think we need to worry about that. Even if a user has trusted a trillion notebooks, the chances of getting a collision without an attack on the hash function are still infinitesimal. And if someone successfully attacks SHA-2, there are probably much more interesting exploits than generating malicious trusted notebooks. I see the logic in keeping a per-user salt, though.\n\nAside: someone should build a website where you can enter a probability, and it will randomly select from a catalogue of unlikely occurrences and combine them to tell you \"this is more unlikely that getting struck by lightning twice on the same day, on the day you are elected president\".\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67382427",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67382427",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67382427,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzgyNDI3",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T19:53:16Z",
    "updated_at": "2014-12-17T19:53:16Z",
    "author_association": "MEMBER",
    "body": "The point is not about the number, the point is that security is something hard and we are not expert in it.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67387497",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67387497",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67387497,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3Mzg3NDk3",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T20:26:56Z",
    "updated_at": "2014-12-17T20:26:56Z",
    "author_association": "MEMBER",
    "body": "Side question, how does that affect no filesystem backend ? \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67388231",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67388231",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67388231,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3Mzg4MjMx",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T20:31:27Z",
    "updated_at": "2014-12-17T20:31:27Z",
    "author_association": "MEMBER",
    "body": "It shouldn't be a problem: we expect the IPython directory to exist as a real filesystem location anyway, for config files etc., so this should work even if contents are stored elsewhere. As @ssanderson mentioned, ContentsManager authors could also implement a corresponding notary that stores signatures in the same database or location.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67390718",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67390718",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67390718,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3MzkwNzE4",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T20:46:46Z",
    "updated_at": "2014-12-17T20:46:46Z",
    "author_association": "MEMBER",
    "body": "I'm just wondering if the db could be moved to the manager itself and if sign shouldn't be only responsible to actually sign/verify and return then the content manager checks. Then content manager authors \"just\" have to store the signature, not actually re implement a Notary.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67394362",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67394362",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67394362,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3Mzk0MzYy",
    "user": {
      "login": "ssanderson",
      "id": 1588357,
      "node_id": "MDQ6VXNlcjE1ODgzNTc=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1588357?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ssanderson",
      "html_url": "https://github.com/ssanderson",
      "followers_url": "https://api.github.com/users/ssanderson/followers",
      "following_url": "https://api.github.com/users/ssanderson/following{/other_user}",
      "gists_url": "https://api.github.com/users/ssanderson/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ssanderson/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ssanderson/subscriptions",
      "organizations_url": "https://api.github.com/users/ssanderson/orgs",
      "repos_url": "https://api.github.com/users/ssanderson/repos",
      "events_url": "https://api.github.com/users/ssanderson/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ssanderson/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T21:07:43Z",
    "updated_at": "2014-12-17T21:07:43Z",
    "author_association": "MEMBER",
    "body": "Insofar as the ContentsManager's provenance includes \"permanently store things when the user changes a file\", I think it makes sense for storage of notebook hashes to fall within its responsibilities.  \n\nI **don't** ContentsManagers should be responsible for actually computing those hashes or for enforcing security restrictions based on those hashes.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/67395853",
    "html_url": "https://github.com/ipython/ipython/pull/7244#issuecomment-67395853",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/7244",
    "id": 67395853,
    "node_id": "MDEyOklzc3VlQ29tbWVudDY3Mzk1ODUz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-12-17T21:17:22Z",
    "updated_at": "2014-12-17T21:17:22Z",
    "author_association": "MEMBER",
    "body": "The storage and content of the signature are not part of the spec. All that's required is that Notary.sign puts _something somewhere_ that it can find when Notary.check_signature is called. All of this can be overridden in a ContentsManager, even to the point of removing the use of any Notary instance. A custom Notary could certainly store the information in the Contents service, but I wouldn't do that by default unless we decide that the notebook-adjacent hidden file is the way to go in the default case.\n\nIf we move signature storage to the ContentsManager, that would also mean moving signature lookup. Notary would only be responsible for computing the current signature, and ContentsManager would be responsible for identifying whether it's trusted or not. Essentially, it means removing `Notary.sign` and `Notary.check_signature`, making those ContentsManager methods, leaving `Notary.compute_signature` as the main public API.\n"
  }
]
