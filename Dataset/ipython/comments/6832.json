[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/61381927",
    "html_url": "https://github.com/ipython/ipython/pull/6832#issuecomment-61381927",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6832",
    "id": 61381927,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzgxOTI3",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-11-01T20:23:54Z",
    "updated_at": "2014-11-01T20:23:54Z",
    "author_association": "MEMBER",
    "body": "This feels like it's getting overly complex - now, as I understand it, each connection has a future, and the one which is actually getting the reply propagates it to the others through a future on the kernelmanager, which then turns into a regular attribute later.\n\nCan we arrange matters so that when a kernel is started, the server sends a kernel info request, and sets up a single future on the kernelmanager which will be fulfilled when it gets the reply. Then all websocket connections to that kernel can wait on that single future. If I understand futures correctly, they should preserve the result after use, so if later connections try to wait on an already-completed future, they will get the result straight away.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/61382381",
    "html_url": "https://github.com/ipython/ipython/pull/6832#issuecomment-61382381",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6832",
    "id": 61382381,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzgyMzgx",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-11-01T20:37:54Z",
    "updated_at": "2014-11-01T21:27:28Z",
    "author_association": "MEMBER",
    "body": "Storing just the Future does indeed make things simpler. `Future.add_done_callback()` fires the callback immediately if the Future was already done, so there's no reason handle the case that the original request was completed differently. The only difference between this PR now and what you proposed is that the request happens on first connect, rather than on kernel start.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/61382981",
    "html_url": "https://github.com/ipython/ipython/pull/6832#issuecomment-61382981",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6832",
    "id": 61382981,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzgyOTgx",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-11-01T20:55:31Z",
    "updated_at": "2014-11-01T20:55:31Z",
    "author_association": "MEMBER",
    "body": "Thanks, that seems better.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/61383315",
    "html_url": "https://github.com/ipython/ipython/pull/6832#issuecomment-61383315",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6832",
    "id": 61383315,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzgzMzE1",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-11-01T21:04:09Z",
    "updated_at": "2014-11-01T21:04:09Z",
    "author_association": "MEMBER",
    "body": "I wanted the request to be sent on start as well when I first started on this, but I wasn't able to figure out how to make that happen cleanly. I think that can be investigated separately.\n"
  }
]
