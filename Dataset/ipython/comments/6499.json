[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56205879",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56205879",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56205879,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2MjA1ODc5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-19T17:10:01Z",
    "updated_at": "2014-09-19T17:10:28Z",
    "author_association": "MEMBER",
    "body": "> This is an issue for me because the input sequence can potentially be very long.\n\nIndeed, it can be infinite with generators like `itertools.repeat`.\n\n> Is it a feature or a bug?\n\nBoth! The DirectView map needs to use the whole thing because it does work assignment based on how many elements there are. The LoadBalancedView version doesn't do this, but uses the same code, so it has the same limitation. This doesn't need to be the case.\n\nCan you clarify exactly what you mean by \"maximally lazy\"? Do you mean that work on any given element never even begins until its result is requested? If so, this doesn't make a huge amount of sense to be the default behavior in IPython.parallel, due to the incurred latency of task submission. By submitting all of the tasks together, latency of all tasks but the first and last is hidden behind the computation time.\n\nYou can _write_ a perfectly lazy imap, with vanilla calls to apply:\n\n``` python\ntry:\n    from itertools import izip\nexcept ImportError:\n    izip = zip # py3\n    from functools import reduce\n\ndef pimap(view, f, *sequences):\n    for args in izip(*sequences):\n         yield view.apply_sync(f, *args)\n\ndef lazy_parallel_map_reduce(view, n):\n    reduce(reduce_fun, pimap(view, map_fun, gen_list_lazy(4)))\n```\n\nThis version isn't super useful, though, because the 'perfect laziness' actually prevents any concurrency. This should be strictly slower than doing the same thing locally.  But it should be easily modified to do chunks at a time, so that you trade a certain degree of laziness for some concurrency.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56223354",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56223354",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56223354,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2MjIzMzU0",
    "user": {
      "login": "rabernat",
      "id": 1197350,
      "node_id": "MDQ6VXNlcjExOTczNTA=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1197350?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rabernat",
      "html_url": "https://github.com/rabernat",
      "followers_url": "https://api.github.com/users/rabernat/followers",
      "following_url": "https://api.github.com/users/rabernat/following{/other_user}",
      "gists_url": "https://api.github.com/users/rabernat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rabernat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rabernat/subscriptions",
      "organizations_url": "https://api.github.com/users/rabernat/orgs",
      "repos_url": "https://api.github.com/users/rabernat/repos",
      "events_url": "https://api.github.com/users/rabernat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rabernat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-19T19:28:00Z",
    "updated_at": "2014-09-19T19:28:00Z",
    "author_association": "NONE",
    "body": "Thanks for your reply. I see your point. Let me try to clarify.\n\nI just want the map call not to wait until the generator is completely done before it starts sending the tasks out, as in my first (non parallel) example. Is this possible with IPython parallel?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56229273",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56229273",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56229273,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2MjI5Mjcz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-19T20:17:49Z",
    "updated_at": "2014-09-19T20:17:49Z",
    "author_association": "MEMBER",
    "body": "Ah, sure:\n\n``` python\ndef pmap(view, f, *sequences):\n    \"\"\"parallel map that submits tasks immediately\"\"\"\n    ars = []\n    for args in izip(*sequences):\n        ars.append(view.apply_async(f, *args))\n    for ar in ars:\n        yield ar.get()\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56272256",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56272256",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56272256,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2MjcyMjU2",
    "user": {
      "login": "rabernat",
      "id": 1197350,
      "node_id": "MDQ6VXNlcjExOTczNTA=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1197350?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rabernat",
      "html_url": "https://github.com/rabernat",
      "followers_url": "https://api.github.com/users/rabernat/followers",
      "following_url": "https://api.github.com/users/rabernat/following{/other_user}",
      "gists_url": "https://api.github.com/users/rabernat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rabernat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rabernat/subscriptions",
      "organizations_url": "https://api.github.com/users/rabernat/orgs",
      "repos_url": "https://api.github.com/users/rabernat/repos",
      "events_url": "https://api.github.com/users/rabernat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rabernat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-20T16:14:41Z",
    "updated_at": "2014-09-20T16:14:41Z",
    "author_association": "NONE",
    "body": "Ok, that solution definitely does what I asked for. BUT it comes at a bigger price: it doesn't ever yeild until the whole input sequence has been iterated over. So pmap would internally build a [potentially infinitely] long sequence before it starts to yield to map. (Similar to python map; different from itertools.imap). This is still not scalable.\n\nI guess what I am looking for is a map that is continuously feeding inputs to be mapped and yielding outputs when they are ready in such a way that it keeps all of the engines busy but never builds a list of all the work items. I have been playing around with some ideas but haven't gotten any of them to work.\n\nThanks again for your work and your informative replies. I am learning a lot from this.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56272708",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56272708",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56272708,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2MjcyNzA4",
    "user": {
      "login": "rabernat",
      "id": 1197350,
      "node_id": "MDQ6VXNlcjExOTczNTA=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1197350?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rabernat",
      "html_url": "https://github.com/rabernat",
      "followers_url": "https://api.github.com/users/rabernat/followers",
      "following_url": "https://api.github.com/users/rabernat/following{/other_user}",
      "gists_url": "https://api.github.com/users/rabernat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rabernat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rabernat/subscriptions",
      "organizations_url": "https://api.github.com/users/rabernat/orgs",
      "repos_url": "https://api.github.com/users/rabernat/repos",
      "events_url": "https://api.github.com/users/rabernat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rabernat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-20T16:30:19Z",
    "updated_at": "2014-09-20T16:30:19Z",
    "author_association": "NONE",
    "body": "p.s. Here was my attempt to make your function work the way I wanted. The problem is that none of the asyncresults ever appear as ready.  I guess they don't get applied until get() is called?\n\n``` python\ndef pmap(view, f, *sequences):\n    \"\"\"parallel map that submits tasks immediately\"\"\"\n    ars = []\n    for args in izip(*sequences):\n        for i in xrange(len(ars) - 1, -1, -1):\n            if ars[i].ready():\n                yield ars.pop(i).get()\n        print 'sending', args, 'to map'\n        ars.append(view.apply_async(f, *args))\n    for ar in ars:\n        yield ar.get()\n\nreduce(verbose_reducer, pmap(lview, lambda x: x**2, verbose_generator(5)))\n```\n\nThe output is\n\n```\ngenerating 0\nsending (0,) to map\ngenerating 1\nsending (1,) to map\ngenerating 2\nsending (2,) to map\ngenerating 3\nsending (3,) to map\ngenerating 4\nsending (4,) to map\ngenerator finished\nreducing 0 1\nreducing 1 4\nreducing 5 9\nreducing 14 16\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56277643",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56277643",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56277643,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2Mjc3NjQz",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-20T19:23:13Z",
    "updated_at": "2014-09-20T19:23:13Z",
    "author_association": "MEMBER",
    "body": "> The problem is that none of the asyncresults ever appear as ready.\n\nThat isn't my experience. Can you provide actual code that demonstrates this?\n\n>  I guess they don't get applied until get() is called?\n\nNo, messages are sent by the time `apply_async` returns. `get` just pulls the result off of the local in-memory zmq queue. It has no influence on execution.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56277744",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56277744",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56277744,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2Mjc3NzQ0",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-20T19:26:44Z",
    "updated_at": "2014-09-20T19:26:44Z",
    "author_association": "MEMBER",
    "body": "My output from your function:\n\n```\ngenerating 0\nsending (0,) to map\ngenerating 1\nsending (1,) to map\ngenerating 2\nsending (2,) to map\ngenerating 3\nreducing 0 1\nsending (3,) to map\ngenerating 4\nreducing 1 4\nsending (4,) to map\ngen_list_lazy finished\nreducing 5 9\nreducing 14 16\n```\n\nI suspect when you call it, it's just done submitting before the first result has finished. Try with a larger sequence.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56321535",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56321535",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56321535,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2MzIxNTM1",
    "user": {
      "login": "rabernat",
      "id": 1197350,
      "node_id": "MDQ6VXNlcjExOTczNTA=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/1197350?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/rabernat",
      "html_url": "https://github.com/rabernat",
      "followers_url": "https://api.github.com/users/rabernat/followers",
      "following_url": "https://api.github.com/users/rabernat/following{/other_user}",
      "gists_url": "https://api.github.com/users/rabernat/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/rabernat/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/rabernat/subscriptions",
      "organizations_url": "https://api.github.com/users/rabernat/orgs",
      "repos_url": "https://api.github.com/users/rabernat/repos",
      "events_url": "https://api.github.com/users/rabernat/events{/privacy}",
      "received_events_url": "https://api.github.com/users/rabernat/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-22T01:56:54Z",
    "updated_at": "2014-09-22T01:56:54Z",
    "author_association": "NONE",
    "body": "You're right! I tried with larger sequence (verbose_generator(25)). It does start reducing before the generator finishes.\n\nThanks again for helping me understand how this works! I am using this for some big data processing, and I am really excited about it.\n\nFWIW, I think this pmap function (as defined most recently above) is very useful because of its scalability. Is this a feature that you would consider worth adding to IPython.parallel? Or is it too specialized?\n\np.s. The output of reduce(verbose_reducer, pmap(lview, lambda x: x**2, verbose_generator(25)))\n\n```\ngenerating 0\nsending (0,) to map\ngenerating 1\nsending (1,) to map\ngenerating 2\nsending (2,) to map\ngenerating 3\nsending (3,) to map\ngenerating 4\nsending (4,) to map\ngenerating 5\nsending (5,) to map\ngenerating 6\nsending (6,) to map\ngenerating 7\nsending (7,) to map\ngenerating 8\nreducing 1 0\nsending (8,) to map\ngenerating 9\nsending (9,) to map\ngenerating 10\nsending (10,) to map\ngenerating 11\nsending (11,) to map\ngenerating 12\nreducing 1 4\nsending (12,) to map\ngenerating 13\nsending (13,) to map\ngenerating 14\nsending (14,) to map\ngenerating 15\nsending (15,) to map\ngenerating 16\nreducing 5 9\nsending (16,) to map\ngenerating 17\nreducing 14 16\nsending (17,) to map\ngenerating 18\nreducing 30 25\nsending (18,) to map\ngenerating 19\nreducing 55 36\nsending (19,) to map\ngenerating 20\nreducing 91 49\nsending (20,) to map\ngenerating 21\nsending (21,) to map\ngenerating 22\nreducing 140 81\nreducing 221 64\nsending (22,) to map\ngenerating 23\nsending (23,) to map\ngenerating 24\nreducing 285 121\nreducing 406 100\nsending (24,) to map\ngenerator finished\nreducing 506 144\nreducing 650 169\nreducing 819 196\nreducing 1015 225\nreducing 1240 256\nreducing 1496 289\nreducing 1785 324\nreducing 2109 361\nreducing 2470 400\nreducing 2870 441\nreducing 3311 484\nreducing 3795 529\nreducing 4324 576\n```\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/56427807",
    "html_url": "https://github.com/ipython/ipython/issues/6499#issuecomment-56427807",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/6499",
    "id": 56427807,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU2NDI3ODA3",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-22T19:33:16Z",
    "updated_at": "2014-09-22T19:33:16Z",
    "author_association": "MEMBER",
    "body": "> Is this a feature that you would consider worth adding to IPython.parallel? Or is it too specialized?\n\nI think this makes sense as `view.lazy_map`. I was going to say that it should be `view.map`, but the fact that work doesn't get submitted as fast as possible is counter to the latency-hiding priorities of map, so a new API makes sense.\n"
  }
]
