[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26206792",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26206792",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26206792,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjA2Nzky",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-12T21:49:55Z",
    "updated_at": "2013-10-12T21:49:55Z",
    "author_association": "MEMBER",
    "body": "No, I don't think we will ever support multiple kernels in a single notebook.\nPlus, this would mean the addition of a frontend-side notion of magics (doesn't exist), which I think is also unlikely.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26209839",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26209839",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26209839,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjA5ODM5",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T01:47:06Z",
    "updated_at": "2013-10-13T01:48:49Z",
    "author_association": "NONE",
    "body": "Yes, I know it contradicts the current design. But I am thinking about implementing some kind of super-kernel which distributes to the language specific kernels and only handles the cell-magic. Something like this shouldn't be a problem with 0MQ, right? Additionally I would like to have a possibility to share variables between the kernels. But this could only be done by adding a protocol extension, e.g. a message like publish_variable. The language kernels could then publish a variable as json and the super-kernel would distribute the variable, with a message update_variable to the running language-kernels.\n\nThe only thing one would have to add to the language kernels is the handling of the variable publication protocol (Compared to the current impl). In the ipython kernel this could be a line magic (%publish/%export, ...). In other kernels like iruby this would be a simple method like IRuby.publish.\n\nLine magics are something completly independent of what I am describing here. For example in Ruby there is no necessity for such a thing at all since the Ruby syntax contains already enough magic ;) There are also some cell-magics which are kernel specific. Those could be passed through unhandled to the underlying kernel.\n\nCurrently you support octave and R as additional languages in the main kernel using some weird oct2py, r2py bridge. Imho it would be much better to implement these also as separate kernel and use such a super-kernel approach.\n\nWell finally you could change everything to add the cell-magic handling to the frontend (What you seem to dislike). So for now this could be solved easily using an additional kernel layer. But at the end I would maybe still go to the frontend solution. I am not into the IPython architecture but I assume that there exists already some intermediate layer, like\n\n```\nnotebook/qtconsole/console <---> kernel api <--0mq--> kernel\n```\n\nThis would become:\n\n```\n                                                              <--0mq--> kernel\nnotebook/qtconsole/console <---> kernel api <--> magic kernel <--0mq--> kernel\n                                                              <--0mq--> kernel\n```\n\n```\n                                                             <--0mq--> kernel\nnotebook/qtconsole/console <---> kernel api + magic handling <--0mq--> kernel\n                                                             <--0mq--> kernel\n```\n\nThe only thing I am worried about is the ipython console without 0MQ. I know you don't want to require 0mq for using only the simple console. But I think it would be acceptable to require it if multiple kernels are used.\n\n```\n                                                 <--0mq--> Julia kernel\nsimple console <---> kernel api + magic handling <--> ipython kernel/octave kernel/R kernel (direct calls since implemented in Python)\n                                                 <--0mq--> Ruby ernel\n```\n\nSo as I see it this is quite possible to be implemented without much hassle since you could transparently add the handling of the magic. I am not really sure about this protocol addition but I think something like this is really needed if you decide to make the move to a multi-language system.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26209942",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26209942",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26209942,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjA5OTQy",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T01:57:06Z",
    "updated_at": "2013-10-13T01:57:06Z",
    "author_association": "MEMBER",
    "body": "The weird oct2py/rpy2 approach has one big advantage over a clever scheme with multiple kernels: you can easily bring data across from one language to the other and back, without having to write it to disk or set up inter process communications. This is especially valuable with the R magics, because a typical pattern is to prepare a pandas DataFrame in Python, and then do some analysis on it in R.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26209964",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26209964",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26209964,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjA5OTY0",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T01:59:43Z",
    "updated_at": "2013-10-13T02:00:38Z",
    "author_association": "NONE",
    "body": "Well the variable exchange is solved by this simple protocol addition in a much more generic way.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26213039",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26213039",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26213039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjEzMDM5",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T07:40:18Z",
    "updated_at": "2013-10-13T07:40:18Z",
    "author_association": "MEMBER",
    "body": "If you wanted to build a special kernel for doing this sort of thing, that's an interesting project. That would still keep the magic implementation at the Kernel level as far as IPython is concerned. According to IPython, the kernel is your überkernel, but your überkernel has its own kernels, to which it dispatches execution.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26214464",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26214464",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26214464,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjE0NDY0",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T09:40:25Z",
    "updated_at": "2013-10-13T09:40:25Z",
    "author_association": "MEMBER",
    "body": "Agreed with Min, that was my first thought before reading the all thread.\n\n I also don't feel like \n\n> \"Well the variable exchange is solved by this simple protocol addition in a much more generic way.\"\n\nIs as simple as it seem.\n\nAlso what syntax do you use for magics ? The same ? Is it compatible with all the languages ?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26217295",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26217295",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26217295,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjE3Mjk1",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T12:55:29Z",
    "updated_at": "2013-10-13T12:55:29Z",
    "author_association": "NONE",
    "body": "@Carreau Yes, I think it can be implemented in such a way to be backward compatible and compatible with all languages.\n- The %%python, %%octave, %%julia, %%ruby magics are used to select the kernel which has to interpret the cell. This dispatch could either happen in an \"überkernel\" or in the frontend\n- The variable sharing could be implemented using a map in the \"überkernel\" or frontent and with 0MQ messages like get_variable_request/get_variable_reply and put_variable_request/put_variable_reply.\n\n``` python\n# In IPython\nvarname = 123\n%put varname\n# Variable available now in the global map\n%get varname\n# Variable received from the global map\n```\n\n``` ruby\n# In IRuby\nvarname = 123\nIRuby.put :varname\n# Variable available now in the global map\nIRuby.get :varname\n# Variable received from the global map\n```\n- An alternative would be to implement only a export_variable_request/export_variable_reply which is send from one kernel. The other kernel adds the variable to his namespace. Additionally one could implement import_variable_request/import_variable_reply to receive a variable from other kernels.\n\n``` python\n# In IPython\nvarname = 123\n%export otherkernel varname\n# Variable available in other kernel\n%import otherkernel varname\n# Variable received from other kernel\n```\n\n``` ruby\n# In IRuby\nvarname = 123\nIRuby.export otherkernel, :varname\n# Variable available in other kernel\nIRuby.import otherkernel, :varname\n# Variable received from other kernel\n```\n\nUsing the %import and %export magic one could emulate easly the `%Rpush = %export R`, `%Rpop = import R` and `%octave_push = %export octave`, `%octave_pop = %import octave` magics.\n\nI have seen that you implemented magics to call the subprocesses for some computation, like\n\n```\n%octave_push a\n%octave a = a * 2;\n%octave_pull a\n```\n\nThe %octave magic should then be mapped by the python kernel to a execute_request to the octave kernel and the octave_kernel replies with the execute_reply.\n\nSo could you please explain me your reasoning why you want to avoid multiple kernels? I think this would lead to a cleaner design. At the end it comes down to some question of philosophy, what kind of workflow you like more. Either you want to allow the move to a heterogeneous environment or you don't want to do that. From my experience as a phd student in physics I am using all kinds of different tools if IPython opens up in this way :)\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26217953",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26217953",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26217953,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjE3OTUz",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T13:38:09Z",
    "updated_at": "2013-10-13T13:38:09Z",
    "author_association": "MEMBER",
    "body": "1st thing is you need a parser that will decide to which kernel send the request. This will not be done in the frontend, or you **have to** rewrite the logic in each frontend, which believe me is far from beeing easy. If you are following discussion with IJulia, we are more trying to push things away from the frontend, because you do not want to re-write your language parser in javascript. Also people might want to plug other kernels, and you try not to have assumption in your kernel about that.\n\n2cd I think that sending variable across kernel is **far more** that sending simple types.\n\nhow would you send  x in the following cases : \n\n```\nx = lambda t:sin(t)\nclass x(object):\n     pass\nu = 1\nx = lambda t=t+u\n```\n\nHave a look at [Julia/Python layercake](http://nbviewer.ipython.org/urls/raw.github.com/JuliaLang/IJulia.jl/master/python/doc/JuliaMagic.ipynb) that call Python from Julia and vice-versa, you'll see that this might be more complicated than just passing simple variable types. \n\n> So could you please explain me your reasoning why you want to avoid multiple kernels? \n\nHaving multiple kernel would be nice, I don't disagree with that. \nFrom a design perspective I do think if it is done it shouldn't be in one part of the current architecture.\nAn additional überkernel like Min is speeking about can perfectly do what you ask, and would be a really nice project that would insert just between frontend and current kernel.\nI guess it can start with only a small proxy that inspect the messages and decide to only forward it to one sub-kernel\nand later grow into something that is more complex and maps variable across kernel.\n\nTo slightly expand on your `export_variable_request/export_variable_reply` it is something that as been discussed durring EuroSciPy for parallel architecture and have distributed variable/data, and the idea of using torrent across machines to dispatch variable was evoqued to avoid having a bottleneck to the dispatcher (that in your case is the überkernel)\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26218598",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26218598",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26218598,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjE4NTk4",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T14:13:00Z",
    "updated_at": "2013-10-13T14:13:00Z",
    "author_association": "NONE",
    "body": "1. The parsing is really trivial using regex, it is just a check if the cell starts with %%octave. The other magic must be handled by the kernel. It doesn't matter if it is done in the überkernel or the frontend.\n2. Sending complex types should not be supported in my proposal, only sending json-like objects which is perfectly fine for exchanging data between different systems. This is also what you do between R, Octave and Python. There is no need for something more complex. In case you need it you can always implement a real binding like Python/Julia but I am looking more for something to easily integrate existing systems without much effort.\n3. The solution using an über/superkernel makes sense as an intermediate step or as a proof-of-concept (I wrote that in my first comment). But I haven't seen an argument why \"it shouldn't be in one part of the current architecture\". I think it is only because you don't want to change the current architecture to support multiple kernels per notebook/console. It is definitely not \"too difficult\".\n4. Ok, if you really have a largly parallel system my proposal doesn't work for variable exchange. But then you should define an easy way how different kernels could exchange data (using torrent or whatsoever) and it should be possible to implement that in all kernels. But I think parallel computing and data exchange is something which could be implemented in a language-dependent fashion. If you run a cluster it is highly probable that you have a lot of python nodes running and want to exchange between them but not between different language boundaries. The problem I am trying to solve here is a different one.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26220155",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26220155",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26220155,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjIwMTU1",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T15:36:35Z",
    "updated_at": "2013-10-13T15:36:35Z",
    "author_association": "MEMBER",
    "body": "> This is also what you do between R, Octave and Python.\n\nWe send numpy arrays and pandas data frames, so I don't think that's true. Serializing these to JSON is rather inefficient.  I think that almost all data that current users send across language boundaries is actually low-level arrays, not simple JSONable objects.\n\n>  I haven't seen an argument why \"it shouldn't be in one part of the current architecture\"\n\nI don't think pushing IPython's syntax extensions onto non-Python programmers is something we should do. Adding magics to the message spec also makes minimum kernels more complicated, not less. It also adds more logic required in a basic frontend. Remember, there are many frontends (emacs-notebook, vim-ipython, Sublime Text, terminal console, QtConsole, Notebook, etc.), not just multiple kernels.\n\nRelaxing the 1 notebook : 1 execution space assumption is a pretty big deal. It has value, but the simplicity afforded by the assumption is valuable as well. I don't think it's an unreasonable thing to build, but I do think it is not something that should be the default state of IPython.\n\nI don't see anything that building this into IPython would actually provide that a separate über-kernel project would not, other than exposure.\n\nThe magics message and multi-workspace kernel are actually two unrelated questions.  There are real problems today that would be addressed by frontend magic awareness (e.g. a %restart magic, which wants to trigger a _frontend_ action, not a backend one).  The multi-kernel model is, as you said, not an especially difficult model,\nit's just a choice, and I'm not sure it's one we should make.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26222117",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26222117",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26222117,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjIyMTE3",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-13T17:22:17Z",
    "updated_at": "2013-10-13T17:22:17Z",
    "author_association": "NONE",
    "body": "> We send numpy arrays and pandas data frames, so I don't think that's\n> true. Serializing these to JSON is rather inefficient.  I think that\n> almost all data that current users send across language boundaries is\n> actually low-level arrays, not simple JSONable objects.\n\nWell, but this is really only a matter of definition of your\nserialization scheme. You could always use something more efficient\n(Msgpack/...). I don't think that you want to implement some kind\nof RPC scheme. You always want to pass plain data.\n\n> I don't think pushing IPython's syntax extensions onto non-Python\n> programmers is something we should do. Adding magics to the message\n> spec also makes minimum kernels more complicated, not less. It also\n> adds more logic required in a basic frontend. Remember, there are\n> many frontends (emacs-notebook, vim-ipython, Sublime Text, terminal\n> console, QtConsole, Notebook, etc.), not just multiple kernels.\n\nNo, this is not what I propose. The way you define the cell-language is\nby specifing %%language in the beginning. You could also add a metadata\nfield where you could set the language of the cell.\n\n> Relaxing the 1 notebook : 1 execution space assumption is a pretty\n> big deal. It has value, but the simplicity afforded by the assumption\n> is valuable as well. I don't think it's an unreasonable thing to\n> build, but I do think it is not something that should be the default\n> state of IPython.\n\nI don't agree. Your implementation or the integration of R and Octave\nalso shows otherwise. You already have something like 1:1:N. But\ninstead of implementing it shomehow cleanly, so that other language\nkernels could profit from the already existing kernels they have to\nimplement the integration of other systems by themselves. Language\nagnostic looks different to me.\n\n> I don't see anything that building this into IPython would actually\n> provide that a separate über-kernel project would not, other than\n> exposure.\n\nThis is true. I can implement a proof of concept but the point is that\nI don't want to implement something which you dislike in general. So it\nwill never become part of the project...\n\n> The magics message and multi-workspace kernel are actually two\n> unrelated questions.  There are real problems today that would be\n> addressed by frontend magic awareness (e.g. a %restart magic, which\n> wants to trigger a _frontend_ action, not a backend one).  The\n> multi-kernel model is, as you said, not an especially difficult\n> model, it's just a choice, and I'm not sure it's one we should make.\n\nYou decide. Imho it is completely transparent and there wouldn't be any\ndifference to the user.\n\nI think there are four main problems:\n1. How to work with multiple kernels/backends/systems at the same\n   time (Python/Octave/R/Maxima/...)?\n2. How to reduce the amount of code duplication in the backends?\n   (Loosely coupled components, not every kernel should have to implement\n   the integration of subsystems, the kernel should be the smallest unit).\n3. Howto decide which kernel to run? (Either cell magic or more cleanly\n   using cell metadata).\n4. Howto pass data from one kernel to another? (Communication via the\n   frontent/überkernel or more complex direct communication between the\n   kernels).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26237527",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26237527",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26237527,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjM3NTI3",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T06:21:16Z",
    "updated_at": "2013-10-14T06:27:52Z",
    "author_association": "MEMBER",
    "body": "> this is not what I propose.\n\nSorry, I had injected my own interpretation of the Issue title.\n\n> 1. How to work with multiple kernels/backends/systems at the same\n>    time (Python/Octave/R/Maxima/...)?\n\nNote that the more sophisticated language magics extensions (R, octave, cython) are all actually _leaving_ the IPython code base, rather than becoming the status quo. These are considered library functionality, as they are a magic wrapping existing libraries (rpy2, oct2py, and cython).\n\n> 1. How to reduce the amount of code duplication in the backends?\n\nThis is a real issue, and keeping this simple is important.\n\n> 1. How to decide which kernel to run?\n\nThe current plan is to put this information into the Notebook-level metadata, because of the 1:1 kernel:notebook relationship, and have a menu item for choosing which one.\n\n> 1. How to pass data from one kernel to another?\n\nI think that implementing and maintaining inter-language communication might be out of scope for IPython (it probably wouldn't be if we adopt your multi-kernel model). Note that IPython _does not_ implement this for R or Octave - the libraries rpy2 and oct2py do this. We would not have any support for passing objects across the boundary if the libraries did not provide this functionality.\n\nP.S. Your IRuby work was very well received at RuPy this morning, thanks for doing all of that!\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26238291",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26238291",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26238291,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjM4Mjkx",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T06:51:11Z",
    "updated_at": "2013-10-14T06:51:11Z",
    "author_association": "MEMBER",
    "body": "> This is true. I can implement a proof of concept but the point is that\n> I don't want to implement something which you dislike in general. So it\n> will never become part of the project...\n\nYou shouldn't think like that, IPython is a big project and we have a lot of legacy to support. Trying to get anything into the core will be really hard especially if it is new. You will be slow down by the review process and the 6 month between releases.\n\nIn the other end, project like your IRuby and IJulia can have a really fast iteration process. Also if you go with an uber-kernel you can modify the protocol that faces sub-kernel if you need and still interface with the frontends. \nAgreed that you might need to modify the subkernel... If There is interest in the project and it it matures enough we can consider merging it into the core. Lots of small things in IPython started like that and merging too early always was painfull. \n\nTry also to get closer to Sage that have multi language support to see how they do that in the sage notebook.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26249134",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26249134",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26249134,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjQ5MTM0",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T11:23:19Z",
    "updated_at": "2013-10-14T11:23:19Z",
    "author_association": "NONE",
    "body": "Hi!\n\n> > this is not what I propose.\n> \n> Sorry, I had injected my own interpretation of the Issue title.\n\nYes, I wrote the title when I thought about implementing R and Octave\netc in the Ruby kernel. But then I thought that this leads to a large\ncode duplication. I changed the title now.\n\n> > 1. How to work with multiple kernels/backends/systems at the same\n> >    time (Python/Octave/R/Maxima/...)?\n> \n> Note that the more sophisticated language magics extensions (R,\n> octave, cython) are all actually _leaving_ the IPython code base,\n> rather than becoming the status quo. These are considered library\n> functionality, as they are a magic wrapping existing libraries (rpy2,\n> oct2py, and cython).\n\nSo why not make them a kernel?\n\n> > 1. How to reduce the amount of code duplication in the backends?\n> \n> This is a real issue, and keeping this simple is important.\n\nWhat do you propose? The multikernel model seems to be the best\nsolution to avoid duplication.\n\n> > 1. How to decide which kernel to run?\n> \n> The current plan is to put this information into the Notebook-level\n> metadata, because of the 1:1 kernel:notebook relationship, and have a\n> menu item for choosing which one.\n\nYes, I know that this is the current plan but I think you should go to\na multikernel model :)\n\nI haven't seen real arguments against it except for the dogmatic ones\nthat you want to keep it simple etc. But actually you are complicating\nall kernels at the same time.\n\n> > 1. How to pass data from one kernel to another?\n> \n> I think that implementing and maintaining inter-language\n> communication might be out of scope for IPython (it probably wouldn't\n> be if we adopted your multi-kernel model). Note that IPython _does\n> not_ implement this for R or Octave - the libraries rpy2 and oct2py\n> do this. We would not have any support for passing objects across the\n> boundary if the libraries did not provide this functionality.\n\nYes, the libraries provide that. But in the same way you could write an\noctave and an R kernel. Since we already have an R/Octave\nimplementation the resulting kernel would just be a thin Python kernel\ndelegating to R and Octave.\n\nThe problem with the multikernel model is that you cannot avoid\nadding the variable passing functionality to the kernel, what you also\ndislike. However you implemented it somehow already in R and Octave. I\nreally don't get why you already implemented most of the stuff that we\ndiscussed but in a way which prevents code reuse. Also the\nfunctionality to kill Octave/R independent of the kernel is something\nweird. Why not just implement a function to kill a specific kernel if\nyou have multiple running. Everything seems to map better to the\nmultikernel model. So why not?\n\n> P.S. Your IRuby work was very well received at RuPy this morning,\n> thanks for doing all of that!\n\nCool! Thanks for presenting it!\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26249708",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26249708",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26249708,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjQ5NzA4",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T11:36:31Z",
    "updated_at": "2013-10-14T11:36:31Z",
    "author_association": "NONE",
    "body": "> You shouldn't think like that, IPython is a big project and we have a\n> lot of legacy to support. Trying to get anything into the core will\n> be really hard especially if it is new. You will be slow down by the\n> review process and the 6 month between releases.\n\nYes, but that is usually frustrating. And if some feature is not\naccepted from the beginning it is very improbable to get in.\n\n> In the other end, project like your IRuby and IJulia can have a\n> really fast iteration process. Also if you go with an uber-kernel you\n> can modify the protocol that faces sub-kernel if you need and still\n> interface with the frontends. Agreed that you might need to modify\n> the subkernel... If There is interest in the project and it it\n> matures enough we can consider merging it into the core.\n\nThis sounds better. However you are NOW switching to a language agnostic\nsystem. You are NOW redesigning the frontend to select a kernel etc.\nAll those things would need to be changed if you would go through with\na multikernel model at the end. Without adding some way to exchange\nvariables the model is also dead (since this would require changes to\nall kernels).\n\n> Try also to get closer to Sage that have multi language support to\n> see how they do that in the sage notebook.\n\nYes but I also don't understand why they have their own notebook. I\nwould rather prefer one which is better. But in general I like the way\nsage goes (embedding existing systems, reusing things).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26252789",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26252789",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26252789,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjUyNzg5",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T12:47:02Z",
    "updated_at": "2013-10-14T12:47:02Z",
    "author_association": "MEMBER",
    "body": "> So why not make them a kernel?\n\nBecause nobody wrote the kernel. Writing a kernel is significantly more work that just wrapping an existing library and lib works outside of IPython.\n\n> I haven't seen real arguments against it [multikernel] except for the dogmatic ones\n> that you want to keep it simple etc. But actually you are complicating\n> all kernels at the same time.\n\nIt is a significant overhead to support multikernel in the same notebook. \nWe do not have bandwidth to do it. If we could, I guess we would (as long\nas we are happy with implementation). \nI don't think we are complicating all kernels. Having access\nfrom one language to another is a choice of the kernel implementors. \nHaving a layer to conform to would be great, but I'm not sure \ncross-language computation is used by everyone. \n\nWe abolutely should not ask on every cell user to type a line with the language, the \nvariable they want in and the one they want out.\n\n> The problem with the multikernel model is that you cannot avoid\n> adding the variable passing functionality to the kernel, what you also\n> dislike.\n\nI don't dislike variable passing. I just don't think it is as easy as it seem. \nI would really like having transparent use of variable across languages.\nBut Imho this is not something that should use the current protocol, \nit should be design as maybe a metalanguage that should also be usable \nnot in notebook. Multi/über-kernel would be a way to do that, and you should be able to run headless\n\n```\n$ iUber myScript.übk\n```\n\n> Also the\n> functionality to kill Octave/R independent of the kernel is something\n> weird. Why not just implement a function to kill a specific kernel if\n> you have multiple running. Everything seems to map better to the\n> multikernel model. So why not?\n\nI think there is a significant miss understanding in how we consider the %%lang magics.\nthoses magics are for me, a way to delegate work to another subprocess and get the result back\ninto python. Which is **way** less than having an actual interactive session.\nAnd except for octave, none of the other magic persist.\n\n> Yes, but that is usually frustrating. And if some feature is not\n> accepted from the beginning it is very improbable to get in.\n\nI don't think this is true. We might be in pretty reluctant right now because the next 1 year and a half \nare fully booked. And the core team have not grown much in quite some time. I think we are already more\nor less at the limit of what we can maintain but hopefully things will go better.\n\n> However you are NOW switching to a language agnostic\n> system.\n>  You are NOW redesigning the frontend to select a kernel etc.\n\nNot really, we **are** ( as much as possible) agnostic to language. \nAdding a switch to select kernel/notebook will be a **minimal** change compared \nto tracking many kernel at once.\n\nMoreover you seem to absolutely want to have the reflect of the kernel**s** in the frontend, \nbut I don't see what this would change actually.\n\nAssuming you are speeking to 1 kernel make perfect sens, nothing even suppose the kernel you are speaking to \nonly understand one language. And from what I am concern, the überkenel could be a tree. (Say  `überk` could pass `matlab`  to  `haskell` kernel that himself decide give it to `java` or `node`.)\n\n> Yes but I also don't understand why they have their own notebook\n\nThey are migrating to IPython. We have strong interaction and feedback from them.\n\nI would just finish by saying that we are not deeply agains multikernel (heck each cell had a language flag).\nBut as long as we do not have the bandwith and enough people from each language to **maintain** and develop\nsuch a thing, I don't Think we would do it.\n\nMulti language cross compatibility is also something that need to be though in a scope bigger than IPython one.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26258112",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26258112",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26258112,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjU4MTEy",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T14:20:11Z",
    "updated_at": "2013-10-14T14:20:11Z",
    "author_association": "NONE",
    "body": "> Because nobody wrote the kernel. Writing a kernel is significantly more work that just wrapping an existing library and lib works outside of IPython.\n\nThis is the valid standard argument. However much depends on your choices and your guidance.\n\n> It is a significant overhead to support multikernel in the same notebook. We do not have bandwidth to do it. If we could, I guess we would (as long as we are happy with implementation). I don't think we are complicating all kernels. Having access from one language to another is a choice of the kernel implementors.\n\nYes, you might have not enough developers. But what you say about complicating the kernels is obviously wrong. You require that every kernel implements the cross-language integration by itself. This leads to code duplication and complication.\n\n> Having a layer to conform to would be great, but I'm not sure cross-language computation is used by everyone.\n\nIt is right that this cross-computation is not be used by anyone. However I would really like to have a general interactive scientific/programming platform supporting everything that you can think of :grinning: I think this is also somehow the goal of projects like IPython and Sage.\n\n> We abolutely should not ask on every cell user to type a line with the language, the variable they want in and the one they want out.\n\nYes, but this is not required. A notebook would have a standard language. But it would be possible to embed use other languages too. As it is the case currently with the magics.\n\n> I don't dislike variable passing. I just don't think it is as easy as it seem. I would really like having transparent use of variable across languages. But Imho this is not something that should use the current protocol,\n> it should be design as maybe a metalanguage that should also be usable not in notebook. Multi/über-kernel would be a way to do that, and you should be able to run headless\n\nFor sure it would be possible to run this headless. Why is variable passing not as easy as it seems? You say that it should not be done using the current protocol. So how should it be done? Please propose something, don't just state your opinion without an argument.\n\n> I think there is a significant miss understanding in how we consider the %%lang magics. thoses magics are for me, a way to delegate work to another subprocess and get the result back into python. Which is way less than having an actual interactive session. And except for octave, none of the other magic persist.\n\nNo, there is no misunderstanding. I might lack the knowledge of your code internals but what we are discussing here is design on a higher level. I am just thinking that it would be better to replace the current adhoc implementation (which pushes the responsibility to the kernel developers) with something more general.\n\n> I don't think this is true. We might be in pretty reluctant right now because the next 1 year and a half are fully booked. And the core team have not grown much in quite some time. I think we are already more or less at the limit of what we can maintain but hopefully things will go better.\n\nI see the problems. But please - what are you talking about? On one hand you agree with me and on the other hand you say that you are reluctant to add new ideas. You are booked for the next 18 months, WTF? I mean this roadmap seems crazy. This is not rocket science.\n\n> Not really, we are ( as much as possible) agnostic to language. Adding a switch to select kernel/notebook will be a minimal change compared to tracking many kernel at once.\n\nYes, but I mean that you are currently making the transition to a multi-language architecture. I really appreciate that. Doing it right is important here instead of doing a half-hearted approach.\n\n> Moreover you seem to absolutely want to have the reflect of the kernel**s** in the frontend, but I don't see what this would change actually.\n\nNothing really. My problem is more that I want to have a framework which tells me how to pass variables and I don't want to implement the magics (like octave and R) myself in the kernel. The IJulia guys are also discussing that in https://github.com/JuliaLang/IJulia.jl/issues/12\n\n> Assuming you are speeking to 1 kernel make perfect sens, nothing even suppose the kernel you are speaking to only understand one language. And from what I am concern, the überkenel could be a tree. (Say überk could pass matlab to haskell kernel that himself decide give it to java or node.)\n\nYes, for sure it could be a tree. But this überkernel idea doesn't work without a protocol addition for variable exchange and also extracting things like octave/R into a separate kernel. But this requires core code changes.\n\n> They are migrating to IPython. We have strong interaction and feedback from them.\n\nI haven't observed that. The IPython integration of sage is far from perfect (plots, interactive elements, etc). They also work more on this cloud thing.\n\n> I would just finish by saying that we are not deeply agains multikernel (heck each cell had a language flag). But as long as we do not have the bandwith and enough people from each language to maintain and develop such a thing, I don't Think we would do it.\n\nI see that \"developer bandwidth\" argument. I will take a look into it and try to write a prototype. My argumentation is based on the assumption that it could be done without much effort and without sacrificing backward compatibility. We will see...\n\n> Multi language cross compatibility is also something that need to be though in a scope bigger than IPython one.\n\nWhat do you mean by that? As I said before it would be nice to have a general scientific platform which allows the integration of existing tools.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26269185",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26269185",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26269185,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjY5MTg1",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T16:36:09Z",
    "updated_at": "2013-10-14T16:36:09Z",
    "author_association": "MEMBER",
    "body": "> This is the valid standard argument. However much depends on your choices and\n> your guidance.\n\nAgreed, several time people came and said \"great i'm going to write an R\nkernel\", we are still waiting. In the meantime someone wrote a Rmagic. Julia\nGuys did both. \n\n> Yes, you might have not enough developers. But what you say about complicating\n> the kernels is obviously wrong. You require that every kernel implements the\n> cross-language integration by itself. This leads to code duplication and\n> complication.\n\nIf someone want kernel without cross language and have one less protocol to\nconform to then the protocol seem simpler to adhere to. Re-implementing magics\nis a IMHO a choice each kernels shoudl decide. The variable protocol exchange\nseem (to me) like a huge burden. All token are not valid in all languages.\nJulia have fll support for unicode and `-` is allowd in R (IIRC).  Julia does\nnot support overload of the `.`. So even if sharing might seem easy between\nsome languages you have the issues of cross naming things, and decide what\nshould/shoudl'n be exposed. In any case the code to deal with the language\nL/variable type V will have to be written somewhere. The protocol to do so \nshoudl IMHO not be specific to IPython. Once such a protocol exist we might \nthink of having kernel implementing it.\n\n> It is right that this cross-computation is not be used by anyone. However I\n> would really like to have a general interactive scientific/programming platform\n> supporting everything that you can think of :grinning: I think this is also\n> somehow the goal of projects like IPython and Sage.\n\nCompletly agree. But I think we shoudl go one step at a time.\n\n> Yes, but this is not required. A notebook would have a standard language. But\n> it would be possible to embed use other languages too. As it is the case\n> currently with the magics.\n\nSeem resonable, try to think of dooing the same in a notebook less environemnt\nwith pure text.  (let's try to avoid unicode also). You need a way do delimit\nthe usage of each language and define a clear way for things to interact\nwithout having a implementaition as standard. (will all know what happend\notherwise). It would require the design of something wich will involve **lots** \nof thinking to avoid syntax conflict. I\n\n> For sure it would be possible to run this headless. Why is variable passing\n> not as easy as it seems? You say that it should not be done using the current\n> protocol. So how should it be done? Please propose something, don't just\n> state your opinion without an argument.\n\nCurrent protocol is not design to share varaible, it is hackish to do so. It\nwork in IPython parallel because it is python python. You need to take care of\nnaming conflict, of feature that does not exist in all languages (like\nnamespace). Error handling, un writable variable, actually getting an handler\non memeory for soem varaible type. What abbout mangling of double underscore in\npython? Does the round trip make the object untouched ? Let's say you have an\nüberkernel that manage 2 kernel X and Y, does exchanging variable between X and\nY imply gooing through Ü ?  What if kernel are/are not on same machine ? What\nabout concurency ? Type conversion ? Dynamic vs strongly type languages ?\n\nI don't think there is a single answer, some language could even support lazy acces...\n\n> No, there is no misunderstanding. I might lack the knowledge of your code\n> internals but what we are discussing here is design on a higher level. I am\n> just thinking that it would be better to replace the current adhoc\n> implementation (which pushes the responsibility to the kernel developers)\n> with something more general.\n\nWhich is not that easy, I mean lets say I do in Julia kernel :\n\n```\n%%ruby -in X,Y -out Z\nZ = X*Y\n```\n\nDo you have any clue of what Z is ? Int/Uint/Int32/64/BigInt ?  You will really\nhit a hard wall which is that people will want that to work whatever the\nvaraible type are.\n\n> > I don't think this is true. We might be in pretty reluctant right now because\n> > the next 1 year and a half are fully booked. And the core team have not grown\n> > much in quite some time. I think we are already more or less at the limit of\n> > what we can maintain but hopefully things will go better.\n> \n> I see the problems. But please - what are you talking about? On one hand you\n> agree with me and on the other hand you say that you are reluctant to add new\n> ideas. You are booked for the next 18 months, WTF? I mean this roadmap seems\n> crazy. This is not rocket science.\n- I, as a hacker/scientist, agree that woudl be awesome.\n- I, as a IPython core dev think it shoudl mature outside the core. \n- I am not funded by the Sloan Grant, but IPython have 2 years funding \n  with deliverable. The Sloan fundation has already done an **awesome,\n  and incredible** job and give is a lot of flexibility in what we can do. \n  We cannot just decide to do something else, or it should be done by dev not \n  paid by money of the sloan grant, either on their free time, or by\n  getting another grant. Even if it does not seem rocket science, some company \n  rely on what we are dooing, we cannot afford to screw up. \n- I, as a PhD student would love to spend my days on things like that.\n\n> Nothing really. My problem is more that I want to have a framework which\n> tells me how to pass variables and I don't want to implement the magics (like\n> octave and R) myself in the kernel. The IJulia guys are also discussing that\n> in https://github.com/JuliaLang/IJulia.jl/issues/12\n> \n> Yes, for sure it could be a tree. But this überkernel idea doesn't work without\n> a protocol addition for variable exchange and also extracting things like\n> octave/R into a separate kernel. But this requires core code changes.\n\nYes, sure from the back part that woudl be facing the überK.\nYou could probaly implement it as a library first. At least \nonce it work manually between to kernel that load library you\ncan try to increase the magics at a higher level. But even with some IPython magics\nyou will not be able to avoid some implementation in each kernel to serialise/deserialise.\nI would try to have a look at IPython parallel to see how how it push/pull data. \nyou could probably use a serialiser which is X-lang compatible.\n\nAnd you can make a IPep to propose an additional protocol to kernel. \ntry to see also with Julia if they are interested. \n\n> I see that \"developer bandwidth\" argument. I will take a look into it and try\n> to write a prototype. My argumentation is based on the assumption that it could\n> be done without much effort and without sacrificing backward compatibility. We\n> will see...\n> \n> Multi language cross compatibility is also something that need to be though\n> in a scope bigger than IPython one.\n\nWhat do you mean by that? As I said before it would be nice to have a general\nscientific platform which allows the integration of existing tools.\n\nI mean a protocol to exchange varaible between languages without IPython assumption.\nSomething you can unse on a plain ruby/python/julia cluser with just a lib\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26269654",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26269654",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26269654,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjY5NjU0",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T16:42:44Z",
    "updated_at": "2013-10-14T16:42:44Z",
    "author_association": "MEMBER",
    "body": "Just a few points:\n- I do understand that as more kernels are developed, those other kernels\n  will have to make decisions about if/how to handle talking to other\n  languages. It is not clear to me how this will proceed and I think it is\n  too early in the game for this type of development to happen inside of\n  IPython.\n- The scope limiting that we do as a project is not just about man power.\n  It is about focus, maintenance, quality and users' mental bandwidth.\n  Already, the concepts of running code in different languages push the\n  limits of what most users can follow.\n- If you write a prototype, we will probably still say it is out of scope\n  and not integrate it into IPython.  What you are proposing is not a minor\n  increase in scope - you are proposing to solve the N^2 language\n  interoperation problem. Many a projects have shipwrecked on those rocks. I\n  don't think IPython should be about that, regardless of manpower. I know\n  this probably sounds like a downer, but I don't want you to spend your time\n  on this and then get angry at us for not integrating it into IPython.\n\nOn Mon, Oct 14, 2013 at 7:20 AM, Daniel Mendler notifications@github.comwrote:\n\n> Because nobody wrote the kernel. Writing a kernel is significantly more\n> work that just wrapping an existing library and lib works outside of\n> IPython.\n> \n> This is the valid standard argument. However much depends on your choices\n> and your guidance.\n> \n> It is a significant overhead to support multikernel in the same notebook.\n> We do not have bandwidth to do it. If we could, I guess we would (as long\n> as we are happy with implementation). I don't think we are complicating all\n> kernels. Having access from one language to another is a choice of the\n> kernel implementors.\n> \n> Yes, you might have not enough developers. But what you say about\n> complicating the kernels is obviously wrong. You require that every kernel\n> implements the cross-language integration by itself. This leads to code\n> duplication and complication.\n> \n> Having a layer to conform to would be great, but I'm not sure\n> cross-language computation is used by everyone.\n> \n> It is right that this cross-computation is not be used by anyone. However\n> I would really like to have a general interactive scientific/programming\n> platform supporting everything that you can think of [image: :grinning:]I think this is also somehow the goal of projects like IPython and Sage.\n> \n> We abolutely should not ask on every cell user to type a line with the\n> language, the variable they want in and the one they want out.\n> \n> Yes, but this is not required. A notebook would have a standard language.\n> But it would be possible to embed use other languages too. As it is the\n> case currently with the magics.\n> \n> I don't dislike variable passing. I just don't think it is as easy as it\n> seem. I would really like having transparent use of variable across\n> languages. But Imho this is not something that should use the current\n> protocol,\n> it should be design as maybe a metalanguage that should also be usable not\n> in notebook. Multi/über-kernel would be a way to do that, and you should be\n> able to run headless\n> \n> For sure it would be possible to run this headless. Why is variable\n> passing not as easy as it seems? You say that it should not be done using\n> the current protocol. So how should it be done? Please propose something,\n> don't just state your opinion without an argument.\n> \n> I think there is a significant miss understanding in how we consider the\n> %%lang magics. thoses magics are for me, a way to delegate work to another\n> subprocess and get the result back into python. Which is way less than\n> having an actual interactive session. And except for octave, none of the\n> other magic persist.\n> \n> No, there is no misunderstanding. I might lack the knowledge of your code\n> internals but what we are discussing here is design on a higher level. I am\n> just thinking that it would be better to replace the current adhoc\n> implementation (which pushes the responsibility to the kernel developers)\n> with something more general.\n> \n> I don't think this is true. We might be in pretty reluctant right now\n> because the next 1 year and a half are fully booked. And the core team have\n> not grown much in quite some time. I think we are already more or less at\n> the limit of what we can maintain but hopefully things will go better.\n> \n> I see the problems. But please - what are you talking about? On one hand\n> you agree with me and on the other hand you say that you are reluctant to\n> add new ideas. You are booked for the next 18 months, WTF? I mean this\n> roadmap seems crazy. This is not rocket science.\n> \n> Not really, we are ( as much as possible) agnostic to language. Adding a\n> switch to select kernel/notebook will be a minimal change compared to\n> tracking many kernel at once.\n> \n> Yes, but I mean that you are currently making the transition to a\n> multi-language architecture. I really appreciate that. Doing it right is\n> important here instead of doing a half-hearted approach.\n> \n> Moreover you seem to absolutely want to have the reflect of the\n> kernel**s** in the frontend, but I don't see what this would change\n> actually.\n> \n> Nothing really. My problem is more that I want to have a framework which\n> tells me how to pass variables and I don't want to implement the magics\n> (like octave and R) myself in the kernel. The IJulia guys are also\n> discussing that in JuliaLang/IJulia.jl#12https://github.com/JuliaLang/IJulia.jl/issues/12\n> \n> Assuming you are speeking to 1 kernel make perfect sens, nothing even\n> suppose the kernel you are speaking to only understand one language. And\n> from what I am concern, the überkenel could be a tree. (Say überk could\n> pass matlab to haskell kernel that himself decide give it to java or node.)\n> \n> Yes, for sure it could be a tree. But this überkernel idea doesn't work\n> without a protocol addition for variable exchange and also extracting\n> things like octave/R into a separate kernel. But this requires core code\n> changes.\n> \n> They are migrating to IPython. We have strong interaction and feedback\n> from them.\n> \n> I haven't observed that. The IPython integration of sage is far from\n> perfect (plots, interactive elements, etc). They also work more on this\n> cloud thing.\n> \n> I would just finish by saying that we are not deeply agains multikernel\n> (heck each cell had a language flag). But as long as we do not have the\n> bandwith and enough people from each language to maintain and develop such\n> a thing, I don't Think we would do it.\n> \n> I see that \"developer bandwidth\" argument. I will take a look into it and\n> try to write a prototype. My argumentation is based on the assumption that\n> it could be done without much effort and without sacrificing backward\n> compatibility. We will see...\n> \n> Multi language cross compatibility is also something that need to be\n> though in a scope bigger than IPython one.\n> \n> What do you mean by that? As I said before it would be nice to have a\n> general scientific platform which allows the integration of existing tools.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/4386#issuecomment-26258112\n> .\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26270561",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26270561",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26270561,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MjcwNTYx",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T16:54:44Z",
    "updated_at": "2013-10-14T16:54:44Z",
    "author_association": "NONE",
    "body": "> Agreed, several time people came and said \"great i'm going to write\n> an R kernel\", we are still waiting. In the meantime someone wrote a\n> Rmagic. Julia Guys did both. \n\n:)\n\n> If someone want kernel without cross language and have one less\n> protocol to conform to then the protocol seem simpler to adhere to.\n> Re-implementing magics is a IMHO a choice each kernels shoudl decide.\n\nYes, but assuming that the kernel developers want to have the\nmulti-language features it would be nice if the wouldn't have to\nimplement it. You are just shifting the responsibility to the kernel\ndevelopers. The Julia guys are thinking to implement it, I am thinking\nto implement it for IRuby. So it would already make sense to have a\ngeneral solution.\n\n> The variable protocol exchange seem (to me) like a huge burden. All\n> token are not valid in all languages. Julia have fll support for\n> unicode and `-` is allowd in R (IIRC).  Julia does not support\n> overload of the `.`. So even if sharing might seem easy between some\n> languages you have the issues of cross naming things, and decide what\n> should/shoudl'n be exposed. In any case the code to deal with the\n> language L/variable type V will have to be written somewhere.\n\nWell I consider this a minor problem. Allow only \\w+ names, this should\nwork everywhere.\n\n> The protocol to do so shoudl IMHO not be specific to IPython. Once\n> such a protocol exist we might think of having kernel implementing it.\n\nThe kernels communiate via the IPython 0MQ protocol? What kind of\nprotocol do you think of independant of IPython. I want something for\nIPython kernels to communicate with each other, not some general data\nexchange/RPC mechanism.\n\n> Seem resonable, try to think of dooing the same in a notebook less\n> environemnt with pure text.  (let's try to avoid unicode also). You\n> need a way do delimit the usage of each language and define a clear\n> way for things to interact without having a implementaition as\n> standard. (will all know what happend otherwise). It would require\n> the design of something wich will involve **lots** of thinking to\n> avoid syntax conflict. I\n\nI think allowing %%language in the first line of a code block (string\nwhich gets evaluated separately) doesn't lead to problems. This works\nin the notebook and the repl.\n\n> Current protocol is not design to share varaible, it is hackish to do\n> so. It work in IPython parallel because it is python python. You need\n> to take care of naming conflict, of feature that does not exist in\n> all languages (like namespace). Error handling, un writable variable,\n> actually getting an handler on memeory for soem varaible type. What\n> abbout mangling of double underscore in python? Does the round trip\n> make the object untouched ? Let's say you have an überkernel that\n> manage 2 kernel X and Y, does exchanging variable between X and Y\n> imply gooing through Ü ?  What if kernel are/are not on same\n> machine ? What about concurency ? Type conversion ? Dynamic vs\n> strongly type languages ?\n\nNo you think too complicated. Keep it very simple, just allow the\nexchange of some marshallable objects like arrays, maps, numbers,\nstrings, ... A kernel doesn't have to handle the message if there is no\nway to support it.\n\n> Which is not that easy, I mean lets say I do in Julia kernel :\n> \n> ```\n> %%ruby -in X,Y -out Z\n> Z = X*Y\n> ```\n> \n> Do you have any clue of what Z is ? Int/Uint/Int32/64/BigInt ?  You\n> will really hit a hard wall which is that people will want that to\n> work whatever the varaible type are.\n\nSo why should it not work?\n\n> - I, as a hacker/scientist, agree that woudl be awesome.\n> - I, as a IPython core dev think it shoudl mature outside the core. \n> - I am not funded by the Sloan Grant, but IPython have 2 years\n>   funding with deliverable. The Sloan fundation has already done an\n>   **awesome, and incredible** job and give is a lot of flexibility in\n>   what we can do. We cannot just decide to do something else, or it\n>   should be done by dev not paid by money of the sloan grant, either on\n>   their free time, or by getting another grant. Even if it does not\n>   seem rocket science, some company rely on what we are dooing, we\n>   cannot afford to screw up. \n> - I, as a PhD student would love to spend my days on things like\n>   that.\n\nWhat do you have to deliver to whom? This doesn't make any sense. Sure\nyou should not screw up - but not because of some companies.\n\n> Yes, sure from the back part that woudl be facing the überK.\n> You could probaly implement it as a library first. At least \n> once it work manually between to kernel that load library you\n> can try to increase the magics at a higher level. But even with some\n> IPython magics you will not be able to avoid some implementation in\n> each kernel to serialise/deserialise. I would try to have a look at\n> IPython parallel to see how how it push/pull data. you could probably\n> use a serialiser which is X-lang compatible.\n> \n> And you can make a IPep to propose an additional protocol to kernel. \n> try to see also with Julia if they are interested.\n\nOk.\n\n> I mean a protocol to exchange varaible between languages without\n> IPython assumption. Something you can unse on a plain\n> ruby/python/julia cluser with just a lib\n\nYes, it would be nice.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26275538",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26275538",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26275538,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2Mjc1NTM4",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-14T18:02:17Z",
    "updated_at": "2013-10-14T18:02:17Z",
    "author_association": "MEMBER",
    "body": "I haven't read all of the long discussion above, but I want to back up what Brian said: yes, smooth interoperability between multiple languages would be lovely, but that is a really hard task, and it is not in scope for IPython. We have some convenience wrappers for existing libraries connecting Python and R/Octave/Julia, but creating a good general solution is orders of magnitude harder.\n\nIf you want to write a general system for transferring data between different language runtimes, by all means do so. Many people, ourselves included, would be very interested in such a thing. But I don't think it should be, or needs to be, part of IPython.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26310039",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26310039",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26310039,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzEwMDM5",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-15T05:22:27Z",
    "updated_at": "2013-10-15T05:22:27Z",
    "author_association": "MEMBER",
    "body": "> What do you have to deliver to whom? This doesn't make any sense. Sure \n\nIPython does not get money out if thin air. We write grants for project with deliverables, and sometime got the money:\nhttp://ipython.org/sloan-grant.html\n\nThe the next year and a half are funded as long as we work in a delimited zone.\n\nMost if Ipython come from that. Qtconsole was founded by enthought, parallel was funded by NIH...etc. the rest we do on the side, or are done on free time/by volunteers.\n\nEnvoyé de mon iPhone\n\n> Le 14 oct. 2013 à 18:54, Daniel Mendler notifications@github.com a écrit :\n> \n> What do you have to deliver to whom? This doesn't make any sense. Sure\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26356195",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26356195",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26356195,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzU2MTk1",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-15T17:44:06Z",
    "updated_at": "2013-10-15T17:44:06Z",
    "author_association": "MEMBER",
    "body": "To give a bit more background about scope creep and IPython, here are a\ncouple of blog posts I wrote:\n\nhttp://brianegranger.com/?p=249\nhttp://brianegranger.com/?p=261\n\nI know it probably won't make you feel any better, but we regularly tell\npeople \"sorry that is out of IPython's scope.\"  We even tell that to\n_ourselves_ on a regular basis. Summary: I respect your decision to not\ncontribute to the project, but please don't take this personally...\n\nOn Tue, Oct 15, 2013 at 4:18 AM, Daniel Mendler notifications@github.comwrote:\n\n> Ok, I don't care. I won't contribute to such a project then.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/4386#issuecomment-26326075\n> .\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26362147",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26362147",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26362147,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzYyMTQ3",
    "user": {
      "login": "minad",
      "id": 50754,
      "node_id": "MDQ6VXNlcjUwNzU0",
      "avatar_url": "https://avatars0.githubusercontent.com/u/50754?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minad",
      "html_url": "https://github.com/minad",
      "followers_url": "https://api.github.com/users/minad/followers",
      "following_url": "https://api.github.com/users/minad/following{/other_user}",
      "gists_url": "https://api.github.com/users/minad/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minad/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minad/subscriptions",
      "organizations_url": "https://api.github.com/users/minad/orgs",
      "repos_url": "https://api.github.com/users/minad/repos",
      "events_url": "https://api.github.com/users/minad/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minad/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-15T18:55:50Z",
    "updated_at": "2013-10-15T18:55:50Z",
    "author_association": "NONE",
    "body": "No, I don't take that personally and I also don't have any hard feelings about this. I am thankful for your clear statement. It is fine with me if you have the opinion that the scope of your software should be restricted because your users are not up to something more complex. But my interest to contribute drops rapidly.\n\nMaybe we should discuss at some point what the scope of such a project for scientific use should be (I will read your blog post later). I think it should be quite unrestricted if scientists want to use it. But I also disagree with the Python philosophy that there should be only one way to do something. I want to have the possibility to use the computer to its full extent without being restricted. I see a lot of use for IPython in education and I think this is also what it is made for. The question is how complex can the system be but still allowing beginners to use it directly without much knowledge. To me this is a question of clever software design.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26366077",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26366077",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26366077,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2MzY2MDc3",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-15T19:46:48Z",
    "updated_at": "2013-10-15T19:46:48Z",
    "author_association": "MEMBER",
    "body": "Usually we try to make it possible for other people to at least do the\nthings that we consider to be outside of scope.  We try to build in\nextension points to make this possible.  But in areas related to the\nmessage spec itself, that is more difficult.\n\nOn Tue, Oct 15, 2013 at 11:55 AM, Daniel Mendler\nnotifications@github.comwrote:\n\n> No, I don't take that personally and I also don't have any hard feelings\n> about this. I am thankful for your clear statement. It is fine with me if\n> you have the opinion that the scope of your software should be restricted\n> because your users are not up to something more complex. But my interest to\n> contribute drops rapidly.\n> \n> Maybe we should discuss at some point what the scope of such a project for\n> scientific use should be (I will read your blog post later). I think it\n> should be quite unrestricted if scientists want to use it. But I also\n> disagree with the Python philosophy that there should be only one way to do\n> something. I want to have the possibility to use the computer to its full\n> extent without being restricted. I see a lot of use for IPython in\n> education and I think this is also what it is made for. The question is how\n> complex can the system be but still allowing beginners to use it directly\n> without much knowledge. To me this is a question of clever software design.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/4386#issuecomment-26362147\n> .\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26376951",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26376951",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26376951,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2Mzc2OTUx",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-15T22:10:25Z",
    "updated_at": "2013-10-15T22:10:25Z",
    "author_association": "MEMBER",
    "body": "The scope issue isn't primarily about what users are capable of\nunderstanding, it's about what we're capable of building and maintaining.\nEven if someone shows up, as you have, ready to contribute something, the\naddition of extra tests, bug reports, feature requests, co-ordination for\nreleases and so on is an extra weight on the project, and we have to weigh\nup whether the features proposed are worth that cost. I think building a\ngood multi-language interoperation system is a project at least as complex\nas the whole of IPython at present, and possibly several times more\ncomplex. Our procedures can't really absorb that.\n\nOn 15 October 2013 11:55, Daniel Mendler notifications@github.com wrote:\n\n> No, I don't take that personally and I also don't have any hard feelings\n> about this. I am thankful for your clear statement. It is fine with me if\n> you have the opinion that the scope of your software should be restricted\n> because your users are not up to something more complex. But my interest to\n> contribute drops rapidly.\n> \n> Maybe we should discuss at some point what the scope of such a project for\n> scientific use should be (I will read your blog post later). I think it\n> should be quite unrestricted if scientists want to use it. But I also\n> disagree with the Python philosophy that there should be only one way to do\n> something. I want to have the possibility to use the computer to its full\n> extent without being restricted. I see a lot of use for IPython in\n> education and I think this is also what it is made for. The question is how\n> complex can the system be but still allowing beginners to use it directly\n> without much knowledge. To me this is a question of clever software design.\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/4386#issuecomment-26362147\n> .\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26377904",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26377904",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26377904,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2Mzc3OTA0",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-15T22:24:14Z",
    "updated_at": "2013-10-15T22:24:14Z",
    "author_association": "MEMBER",
    "body": "> The scope issue isn't primarily about what users are capable of\n> understanding, it's about what we're capable of building and maintaining.\n\nI mostly agree with you, but with two caveats:\n- One could interpret this to mean that if only we could find more\n  developers/$$$ we would increase our scope. I don't think that is the case.\n- There is an aspect that relates to user experience: increased scope leads\n  to increased complexity, which increases users' cognitive load. That is\n  something we are very sensitive to and is another source of inward pressure\n  on the scope.\n\n> Even if someone shows up, as you have, ready to contribute something, the\n> addition of extra tests, bug reports, feature requests, co-ordination for\n> releases and so on is an extra weight on the project, and we have to weigh\n> up whether the features proposed are worth that cost. I think building a\n> good multi-language interoperation system is a project at least as complex\n> as the whole of IPython at present, and possibly several times more\n> complex. Our procedures can't really absorb that.\n> \n> On 15 October 2013 11:55, Daniel Mendler notifications@github.com\n> wrote:\n> \n> > No, I don't take that personally and I also don't have any hard feelings\n> > about this. I am thankful for your clear statement. It is fine with me\n> > if\n> > you have the opinion that the scope of your software should be\n> > restricted\n> > because your users are not up to something more complex. But my interest\n> > to\n> > contribute drops rapidly.\n> > \n> > Maybe we should discuss at some point what the scope of such a project\n> > for\n> > scientific use should be (I will read your blog post later). I think it\n> > should be quite unrestricted if scientists want to use it. But I also\n> > disagree with the Python philosophy that there should be only one way to\n> > do\n> > something. I want to have the possibility to use the computer to its\n> > full\n> > extent without being restricted. I see a lot of use for IPython in\n> > education and I think this is also what it is made for. The question is\n> > how\n> > complex can the system be but still allowing beginners to use it\n> > directly\n> > without much knowledge. To me this is a question of clever software\n> > design.\n> > \n> > —\n> > Reply to this email directly or view it on GitHub<\n> > https://github.com/ipython/ipython/issues/4386#issuecomment-26362147>\n> > .\n> \n> —\n> Reply to this email directly or view it on GitHubhttps://github.com/ipython/ipython/issues/4386#issuecomment-26376951\n> .\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/26395209",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-26395209",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 26395209,
    "node_id": "MDEyOklzc3VlQ29tbWVudDI2Mzk1MjA5",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2013-10-16T06:18:25Z",
    "updated_at": "2013-10-16T06:18:25Z",
    "author_association": "MEMBER",
    "body": "> - One could interpret this to mean that if only we could find more\n>   developers/$$$ we would increase our scope. I don't think that is the case.\n> - There is an aspect that relates to user experience: increased scope leads\n>   to increased complexity, which increases users' cognitive load. That is\n>   something we are very sensitive to and is another source of inward pressure\n>   on the scope.\n\nAt some point we will have to make a distinction between IPython (as a software) scope, and IPython (as an organisation/groupe) scope. We would have Apple fortune we would probably increase our scope with subproject right ?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/57400866",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-57400866",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 57400866,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NDAwODY2",
    "user": {
      "login": "dsblank",
      "id": 168568,
      "node_id": "MDQ6VXNlcjE2ODU2OA==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/168568?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dsblank",
      "html_url": "https://github.com/dsblank",
      "followers_url": "https://api.github.com/users/dsblank/followers",
      "following_url": "https://api.github.com/users/dsblank/following{/other_user}",
      "gists_url": "https://api.github.com/users/dsblank/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dsblank/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dsblank/subscriptions",
      "organizations_url": "https://api.github.com/users/dsblank/orgs",
      "repos_url": "https://api.github.com/users/dsblank/repos",
      "events_url": "https://api.github.com/users/dsblank/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dsblank/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-09-30T23:53:54Z",
    "updated_at": "2014-09-30T23:53:54Z",
    "author_association": "CONTRIBUTOR",
    "body": "Just found this thread and thought that I'd let you know about the language-independent magics that Steven Silvester (of octave_kernel) and I have been working on for the last few months, using the Python wrapperkernel. The repository is here:\n\nhttps://github.com/blink1073/jupyter_kernel\n\nWe have addressed a few of the issues mentioned here, but not the main issue of language-to-language data transfer. We aren't quite to version 1.0 yet, but getting close. We have magics that are obviously language independent (shell, time, file, edit, etc) but also some that allow capabilities beyond that (ability to use the IPython cluster infrastructure, for example). There is a lot of potential here, I think, for additional research and experimentation for multi-language inter-op.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/57403247",
    "html_url": "https://github.com/ipython/ipython/issues/4386#issuecomment-57403247",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/4386",
    "id": 57403247,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU3NDAzMjQ3",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2014-10-01T00:24:07Z",
    "updated_at": "2014-10-01T00:24:07Z",
    "author_association": "MEMBER",
    "body": "From a technical perspective I think this is great, thanks for sharing this.\n\nHowever, I find the name to be confusing and doesn't quite reflect what it\nactually is and does. I don't have a better idea, but are you open to\nchanging the name?\n\nOn Tue, Sep 30, 2014 at 4:54 PM, Doug Blank notifications@github.com\nwrote:\n\n> Just found this thread and thought that I'd let you know about the\n> language-independent magics that Steven Silvester (of octave_kernel) and I\n> have been working on for the last few months, using the Python\n> wrapperkernel. The repository is here:\n> \n> https://github.com/blink1073/jupyter_kernel\n> \n> We have addressed a few of the issues mentioned here, but not the main\n> issue of language-to-language data transfer. We aren't quite to version 1.0\n> yet, but getting close. We have magics that are obviously language\n> independent (shell, time, file, edit, etc) but also some that allow\n> capabilities beyond that (ability to use the IPython cluster\n> infrastructure, for example). There is a lot of potential here, I think,\n> for additional research and experimentation for multi-language inter-op.\n> \n> —\n> Reply to this email directly or view it on GitHub\n> https://github.com/ipython/ipython/issues/4386#issuecomment-57400866.\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\n@ellisonbg on Twitter and GitHub\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  }
]
