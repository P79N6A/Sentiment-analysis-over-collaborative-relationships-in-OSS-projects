[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5576594",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5576594",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5576594,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzY1OTQ=",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T14:56:36Z",
    "updated_at": "2012-05-08T14:56:36Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for the comment on #977, @ellisonbg.\n\nHow about going to worksheet-level sync before going to cell-level sync?  As each cell has id (on client side), you can send a sequence of cell-id and newly created/modified cell data.  I think it should decrease traffic a lot.  And on top of that, you can (1) cache output data on server, (2) send text diff of cell input, (3) send diff of cell-id sequence.  These three points are independent so it will make easier to work on.  Well, that means you need to create cell-ids on server side but it is a tiny change, I guess.\n\nAbout your first point, doesn't sending url for images increase traffic?  For example, sometimes web developer combine multiple images to one big image to reduce number of connections (using [CSS Sprites](http://coding.smashingmagazine.com/2009/04/27/the-mystery-of-css-sprites-techniques-tools-and-tutorials/)).  So, I thought less number of connections is good in general.  Isn't that mean current base64 method better for sending than http?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5576641",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5576641",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5576641,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzY2NDE=",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T14:58:31Z",
    "updated_at": "2012-05-08T14:58:31Z",
    "author_association": "CONTRIBUTOR",
    "body": "Hmm, maybe\n- worksheet-level => cell-level\n- cell-level => text-level\n\nwere better choice of term...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5577270",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5577270",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5577270,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1NzcyNzA=",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T15:23:23Z",
    "updated_at": "2012-05-08T15:23:23Z",
    "author_association": "MEMBER",
    "body": "Problem with image in base64 embedded in message are :\n- they can't be cached in the browser/reused in several place for the notebook. Hence the increase of traffic. \n- base 64 is [not optimal](http://en.wikipedia.org/wiki/Base64#Padding) (33% overhead)\n- you can send a message with the image embedded, and you're not even sure the image will be displayed. (if I remember correctly all '_repr_*' are computed and chosen in the frontend ? Or is it the server itself that choose the rerp to send to browser ?)\n\nSecond is that yo can totally imagine that files with URL are served by a totally different server than the notebook server, or at least something optimize to 'just' deliver content. Now each time a plot have to be send to the notebook, it have to go through the server and be encoded into base64.\n\nAs for css sprite, I think it is mostly to avoid latency when switching images, because an image is most of the time not loaded as long as it is not visible.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5579687",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5579687",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5579687,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Nzk2ODc=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T16:50:26Z",
    "updated_at": "2012-05-08T16:50:26Z",
    "author_association": "MEMBER",
    "body": "On Tue, May 8, 2012 at 7:56 AM, Takafumi Arakaki\nreply@reply.github.com\nwrote:\n\n> Thanks for the comment on #977, @ellisonbg.\n> \n> How about going to worksheet-level sync before going to cell-level sync?  As each cell has id (on client side), you can send a sequence of cell-id and newly created/modified cell data.  I think it should decrease traffic a lot.  And on top of that, you can (1) cache output data on server, (2) send text diff of cell input, (3) send diff of cell-id sequence.  These three points are independent so it will make easier to work on.  Well, that means you need to create cell-ids on server side but it is a tiny change, I guess.\n\nI am not sure what you mean by a worksheet.  That is not language we\nhave been using.  It is more complicated than just sending newly\nupdated/created cells.  Cell can be moved, deleted, split, merged,\netc.  We would have to expose all of these actions in the server's web\nservice.  It amounts to a complete redesign of everything.\n\n> About your first point, doesn't sending url for images increase traffic?  For example, sometimes web developer combine multiple images to one big image to reduce number of connections (using [CSS Sprites](http://coding.smashingmagazine.com/2009/04/27/the-mystery-of-css-sprites-techniques-tools-and-tutorials/)).  So, I thought less number of connections is good in general.  Isn't that mean current base64 method better for sending than http?\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/issues/1583#issuecomment-5576594\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5579768",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5579768",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5579768,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1Nzk3Njg=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T16:52:47Z",
    "updated_at": "2012-05-08T16:52:47Z",
    "author_association": "MEMBER",
    "body": "On Tue, May 8, 2012 at 8:23 AM, Bussonnier Matthias\nreply@reply.github.com\nwrote:\n\n> Problem with image in base64 embedded in message are :\n> - they can't be cached in the browser/reused in several place for the notebook. Hence the increase of traffic.\n> - base 64 is [not optimal](http://en.wikipedia.org/wiki/Base64#Padding) (33% overhead)\n> - you can send a message with the image embedded, and you're not even sure the image will be displayed. (if I remember correctly all '_repr_*' are computed and chosen in the frontend ? Or is it the server itself that choose the rerp to send to browser ?)\n\nYes, these are good points about the current display protocol.  All\noutput is sent to all clients - it has to be up to the client to\nchoose which they want to display.\n\n> Second is that yo can totally imagine that files with URL are served by a totally different server than the notebook server, or at least something optimize to 'just' deliver content. Now each time a plot have to be send to the notebook, it have to go through the server and be encoded into base64.\n\nNot quite clear on what you mean by this.  Do you mean that images\nreturned in the display protocol could be hosted on a different server\nand exposed to the notebook as URL's?  We might end up going in that\ndirection, but we need to think carefully about this as that other\nserver wouldn't currently have access to those images.\n\n> As for css sprite, I think it is mostly to avoid latency when switching images, because an image is most of the time not loaded as long as it is not visible.\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/issues/1583#issuecomment-5577270\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5581036",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5581036",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5581036,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODEwMzY=",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T17:34:35Z",
    "updated_at": "2012-05-08T17:35:56Z",
    "author_association": "CONTRIBUTOR",
    "body": "> I am not sure what you mean by a worksheet.  That is not language we have been using.\n\nI thought worksheet has a clear meaning because it is the word used in the messaging protocol.:\nhttps://github.com/ipython/ipython/blob/2b6643e2c09b5dff9d45f0cb51f065111a816729/IPython/frontend/html/notebook/static/js/notebook.js#L1224\n\nWhat I mean by worksheet is \"a sequence of cells\".\n\n> It is more complicated than just sending newly updated/created cells.  Cell can be moved, deleted, split, merged, etc.\n\nI know.  You can completely retrieve notebook contents if you have a sequence of cell-id and created/updated cells.  If you have moved cell, the sequence of cell-id tells that because the order of the cell-ids is changed.  If you have deleted cell, the sequence of cell-id has missing id so that you can remove that cell.  If you have a split cell, that means client creates new two cells and removed the original cell.  The server can know that by one missing cell-id and two new cell-id.  If you have a merged cell, you have two missing cell-ids and one new cell-id.\n\nIn the current implementation, cell-id is created at client side.  You will need to create cell-ids on the server instead when opening a notebook.\n\nhttps://github.com/ipython/ipython/blob/2b6643e2c09b5dff9d45f0cb51f065111a816729/IPython/frontend/html/notebook/static/js/cell.js#L31\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5581912",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5581912",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5581912,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODE5MTI=",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T18:07:14Z",
    "updated_at": "2012-05-08T18:07:14Z",
    "author_association": "CONTRIBUTOR",
    "body": "Thanks for pointing out the problem of base 64, @Carreau.\n\n> - they can't be cached in the browser/reused in several place for the notebook. Hence the increase of traffic.\n\nRight, it will speedup loading pint view, for example.  That would help us loading notebook until we have client synchronization.\n\nHaving an URL per image enables to refer image from outside of the notebook (e.g., wiki).  I guess it is a good idea.\n\n> - base 64 is [not optimal](http://en.wikipedia.org/wiki/Base64#Padding) (33% overhead)\n\nWow, that's a lot!  I didn't know that.\n\n> - you can send a message with the image embedded, and you're not even sure the image will be displayed. (if I remember correctly all '_repr_*' are computed and chosen in the frontend ? Or is it the server itself that choose the rerp to send to browser ?)\n\nI thought notebook server _is_ the frontend.  Are there any way to choose (tell server to what-to-send) _repr_ at client side, or are there any plan to do that?  Currently, I think it is hard coded on client side:\n\nhttps://github.com/ipython/ipython/blob/2b6643e2c09b5dff9d45f0cb51f065111a816729/IPython/frontend/html/notebook/static/js/codecell.js#L663\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5582862",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5582862",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5582862,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODI4NjI=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T18:44:08Z",
    "updated_at": "2012-05-08T18:44:08Z",
    "author_association": "MEMBER",
    "body": "On Tue, May 8, 2012 at 10:34 AM, Takafumi Arakaki\nreply@reply.github.com\nwrote:\n\n> > I am not sure what you mean by a worksheet.  That is not language we have been using.\n> \n> I thought worksheet has a clear meaning because it is the word used in the messaging protocol.:\n> https://github.com/ipython/ipython/blob/2b6643e2c09b5dff9d45f0cb51f065111a816729/IPython/frontend/html/notebook/static/js/notebook.js#L1224\n> \n> What I mean by worksheet is \"a sequence of cells\".\n> \n> > It is more complicated than just sending newly updated/created cells.  Cell can be moved, deleted, split, merged, etc.\n> \n> I know.  You can completely retrieve notebook contents if you have a sequence of cell-id and created/updated cells.  If you have moved, cell, the sequence of cell-id tells that.  If you have deleted cell, the sequence of cell-id has missing id so that you can remove that cell.  If you have a split cell, that means client creates new two cells and removed the original cell.  The server can know that by one missing cell-id and two new cell-id.  If you have a merged cell, you have two missing cell-ids and one new cell-id.\n> \n> In the current implementation, cell-id is created at client side.  You will need to create cell-ids on the server instead when opening a notebook.\n\nYes, this is exactly the type of thing we will have to do to get cell\nlevel synching.  Currently our notebook web service only knows about\nentire notebooks, which we then store as flat files on disk.  We would\nhave to teach the web service about cells and cell sequences and then\nfigure out an efficient way of saving the notebooks.  Saving as a flat\nJSON file would be horrible because it would have to be read from\ndisk, parsed, manipulated, dumped and saved each time the notebook is\nchanged = very inefficient.\n\n> https://github.com/ipython/ipython/blob/2b6643e2c09b5dff9d45f0cb51f065111a816729/IPython/frontend/html/notebook/static/js/cell.js#L31\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/issues/1583#issuecomment-5581036\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5584531",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5584531",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5584531,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODQ1MzE=",
    "user": {
      "login": "Carreau",
      "id": 335567,
      "node_id": "MDQ6VXNlcjMzNTU2Nw==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/335567?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carreau",
      "html_url": "https://github.com/Carreau",
      "followers_url": "https://api.github.com/users/Carreau/followers",
      "following_url": "https://api.github.com/users/Carreau/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carreau/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carreau/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carreau/subscriptions",
      "organizations_url": "https://api.github.com/users/Carreau/orgs",
      "repos_url": "https://api.github.com/users/Carreau/repos",
      "events_url": "https://api.github.com/users/Carreau/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carreau/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T19:49:46Z",
    "updated_at": "2012-05-08T19:49:46Z",
    "author_association": "MEMBER",
    "body": "> Not quite clear on what you mean by this. Do you mean that images returned in the display protocol could be hosted on a different server and exposed to the notebook as URL's? We might end up going in that direction, but we need to think carefully about this as that other server wouldn't currently have access to those images.\n\nWe could perfectly have an url pattern as a trait when serving files, as well as the location to were the files are saved. \nNothing prevent advance users/admin to setup the correct Rigths on the filesytem and have another kind of wevbserver serving the files, as long as the url is the fullpath URL. Of course then you don't have credentials if you want thoses ressources to be accessible only by logged in users...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5585163",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5585163",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5585163,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1ODUxNjM=",
    "user": {
      "login": "tkf",
      "id": 29282,
      "node_id": "MDQ6VXNlcjI5Mjgy",
      "avatar_url": "https://avatars3.githubusercontent.com/u/29282?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tkf",
      "html_url": "https://github.com/tkf",
      "followers_url": "https://api.github.com/users/tkf/followers",
      "following_url": "https://api.github.com/users/tkf/following{/other_user}",
      "gists_url": "https://api.github.com/users/tkf/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tkf/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tkf/subscriptions",
      "organizations_url": "https://api.github.com/users/tkf/orgs",
      "repos_url": "https://api.github.com/users/tkf/repos",
      "events_url": "https://api.github.com/users/tkf/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tkf/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-08T20:17:13Z",
    "updated_at": "2012-05-08T20:17:13Z",
    "author_association": "CONTRIBUTOR",
    "body": "> Yes, this is exactly the type of thing we will have to do to get cell\n> level synching.  Currently our notebook web service only knows about\n> entire notebooks, which we then store as flat files on disk.  We would\n> have to teach the web service about cells and cell sequences and then\n> figure out an efficient way of saving the notebooks.\n\nWell, my first question was suggesting a little bit more detailed protocol.  I thought what you had in mind was to implement sending diff of, for example, input text data, _from the very first implementation_.  My suggestion was sending whole cell data (if it is change/created) but not whole sequence of cells (= current saving mechanism), for at least for the first step of improvement.  And I suggested how you can gradually improve the protocol to reach text level.  I wanted to know what you think about my suggestion of gradual improvement.\n\nAlso, I guess you can separate the issue of the format for holding data from the server-client messaging protocol.  Right, JSON file is inefficient, but you can implement caching system or other backend afterward anytime you need.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5591602",
    "html_url": "https://github.com/ipython/ipython/issues/1583#issuecomment-5591602",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1583",
    "id": 5591602,
    "node_id": "MDEyOklzc3VlQ29tbWVudDU1OTE2MDI=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-05-09T02:43:53Z",
    "updated_at": "2012-05-09T02:43:53Z",
    "author_association": "MEMBER",
    "body": "On Tue, May 8, 2012 at 1:17 PM, Takafumi Arakaki\nreply@reply.github.com\nwrote:\n\n> > Yes, this is exactly the type of thing we will have to do to get cell\n> > level synching.  Currently our notebook web service only knows about\n> > entire notebooks, which we then store as flat files on disk.  We would\n> > have to teach the web service about cells and cell sequences and then\n> > figure out an efficient way of saving the notebooks.\n> \n> Well, my first question was suggesting a little bit more detailed protocol.  I thought what you had in mind was to implement sending diff of, for example, input text data, _from the very first implementation_.  My suggestion was sending whole cell data (if it is change/created) but not whole sequence of cells (= current saving mechanism), for at least for the first step of improvement.  And I suggested how you can gradually improve the protocol to reach text level.  I wanted to know what you think about my suggestion of gradual improvement.\n\nI was probably unclear then.  I don't think we will ever try sending\nsub-cell-level diffs (for example sending changed input or parts of\nthe input).  The cell is a very nice level of granularity for\nsharing/synching.  So I think we would start there and probably stay\nthere.\n\n> Also, I guess you can separate the issue of the format for holding data from the server-client messaging protocol.  Right, JSON file is inefficient, but you can implement caching system or other backend afterward anytime you need.\n\nI think we would need to figure this out from the start because of how\nintimately we rely on the filesystem in the notebook.\n\n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/issues/1583#issuecomment-5585163\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  }
]
