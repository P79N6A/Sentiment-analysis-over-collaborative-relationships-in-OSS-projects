[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/161106000",
    "html_url": "https://github.com/ipython/ipython/issues/9061#issuecomment-161106000",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/9061",
    "id": 161106000,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MTEwNjAwMA==",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-01T21:47:56Z",
    "updated_at": "2015-12-01T21:47:56Z",
    "author_association": "MEMBER",
    "body": "It may be a race condition - when the notebook server shuts down kernels, it gives them a short time to shut down gracefully before it forcibly terminates them. Though I would have thought it would be enough time for that to run.\n\nIn general, however, there's no way to reliably run code just before a process exits - if it segfaults, or receives an unexpected SIGKILL, you have no chance to run code at all.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/161230845",
    "html_url": "https://github.com/ipython/ipython/issues/9061#issuecomment-161230845",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/9061",
    "id": 161230845,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MTIzMDg0NQ==",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-02T09:16:23Z",
    "updated_at": "2015-12-02T09:16:23Z",
    "author_association": "MEMBER",
    "body": "@Py4JQuestionAsker can you create a situation where this reliably fails? How many kernels do you typically have? Does this fail with only one kernel that is not busy? I could imagine having many and/or busy kernels could increase the likelihood that kernels don't exit cleanly before the notebook gives up and kills them.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/161398541",
    "html_url": "https://github.com/ipython/ipython/issues/9061#issuecomment-161398541",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/9061",
    "id": 161398541,
    "node_id": "MDEyOklzc3VlQ29tbWVudDE2MTM5ODU0MQ==",
    "user": {
      "login": "Py4JQuestionAsker",
      "id": 14099358,
      "node_id": "MDQ6VXNlcjE0MDk5MzU4",
      "avatar_url": "https://avatars2.githubusercontent.com/u/14099358?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Py4JQuestionAsker",
      "html_url": "https://github.com/Py4JQuestionAsker",
      "followers_url": "https://api.github.com/users/Py4JQuestionAsker/followers",
      "following_url": "https://api.github.com/users/Py4JQuestionAsker/following{/other_user}",
      "gists_url": "https://api.github.com/users/Py4JQuestionAsker/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Py4JQuestionAsker/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Py4JQuestionAsker/subscriptions",
      "organizations_url": "https://api.github.com/users/Py4JQuestionAsker/orgs",
      "repos_url": "https://api.github.com/users/Py4JQuestionAsker/repos",
      "events_url": "https://api.github.com/users/Py4JQuestionAsker/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Py4JQuestionAsker/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2015-12-02T18:59:15Z",
    "updated_at": "2015-12-02T18:59:15Z",
    "author_association": "NONE",
    "body": "Since I had thought that it was just a problem with atexit and IPython notebook I didn't mention that the notebook is running on Spark, which appears to have its own cleanup routines. In this scenario, the situation I described will always fail even if only 1 kernel is running and busy (though not if it is not busy), which I now see is probably the result of the extra cleanup introduced by Spark.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/218178557",
    "html_url": "https://github.com/ipython/ipython/issues/9061#issuecomment-218178557",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/9061",
    "id": 218178557,
    "node_id": "MDEyOklzc3VlQ29tbWVudDIxODE3ODU1Nw==",
    "user": {
      "login": "Carpique",
      "id": 3523722,
      "node_id": "MDQ6VXNlcjM1MjM3MjI=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/3523722?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Carpique",
      "html_url": "https://github.com/Carpique",
      "followers_url": "https://api.github.com/users/Carpique/followers",
      "following_url": "https://api.github.com/users/Carpique/following{/other_user}",
      "gists_url": "https://api.github.com/users/Carpique/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Carpique/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Carpique/subscriptions",
      "organizations_url": "https://api.github.com/users/Carpique/orgs",
      "repos_url": "https://api.github.com/users/Carpique/repos",
      "events_url": "https://api.github.com/users/Carpique/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Carpique/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2016-05-10T14:40:31Z",
    "updated_at": "2016-05-10T14:40:31Z",
    "author_association": "NONE",
    "body": "I'm running jupyter 3.2.1 (simple, no Spark) and I can definitely verify that registering a shutdown hook with python's atexit() works well when the notebook is not busy and the hook is not invoked when the notebook is busy. \n\nAlthough my use case involves performing some cleanup precisely when notebooks are busy (monitoring execution of a sub-process), I tried also a simple scenario of registering the hook with and without an infinite while loop and I can confirm there's a difference in behavior. \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/468583839",
    "html_url": "https://github.com/ipython/ipython/issues/9061#issuecomment-468583839",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/9061",
    "id": 468583839,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ2ODU4MzgzOQ==",
    "user": {
      "login": "Pierre-Bartet",
      "id": 24455641,
      "node_id": "MDQ6VXNlcjI0NDU1NjQx",
      "avatar_url": "https://avatars0.githubusercontent.com/u/24455641?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Pierre-Bartet",
      "html_url": "https://github.com/Pierre-Bartet",
      "followers_url": "https://api.github.com/users/Pierre-Bartet/followers",
      "following_url": "https://api.github.com/users/Pierre-Bartet/following{/other_user}",
      "gists_url": "https://api.github.com/users/Pierre-Bartet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/Pierre-Bartet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/Pierre-Bartet/subscriptions",
      "organizations_url": "https://api.github.com/users/Pierre-Bartet/orgs",
      "repos_url": "https://api.github.com/users/Pierre-Bartet/repos",
      "events_url": "https://api.github.com/users/Pierre-Bartet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/Pierre-Bartet/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2019-03-01T08:24:25Z",
    "updated_at": "2019-03-01T08:37:28Z",
    "author_association": "NONE",
    "body": "I can confirm, even a simpler example with a single TemporaryDirectory fails cleaning when stopping kernel or restarting it. The problem only arise when kernel is busy when stopped.\r\n\r\nBy the way it is not only an atexit problem, as TemporaryDirectory rely only on weakref. All cleaning (using with, weakref.finalize, __del__ and atexit) consistently fail in the same manner.\r\n\r\nFor example, despite using **with** this example doesn't clean if stopped during the sleep :\r\n\r\n```\r\nimport time\r\nimport tempfile\r\n\r\nwith tempfile.TemporaryDirectory() as tmp:    \r\n    time.sleep(10)\r\n```"
  }
]
