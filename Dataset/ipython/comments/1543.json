[
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/4882086",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-4882086",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 4882086,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODIwODY=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-02T16:20:16Z",
    "updated_at": "2012-04-02T16:20:16Z",
    "author_association": "MEMBER",
    "body": "@ctb already mentioned the problem of reliably capturing the output of long-running shell commands, when the notebook client disconnects and reattaches.\n\nThe issue is that we've basically delegated the capture of outputs as they are generated to the web client, and if the client has disconnected for a while, nobody keeps those outputs.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/4886247",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-4886247",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 4886247,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4ODYyNDc=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-02T19:22:49Z",
    "updated_at": "2012-04-02T19:22:49Z",
    "author_association": "MEMBER",
    "body": "Great, I will follow this issue.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/4890635",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-4890635",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 4890635,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTA2MzU=",
    "user": {
      "login": "cschin",
      "id": 1320747,
      "node_id": "MDQ6VXNlcjEzMjA3NDc=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1320747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cschin",
      "html_url": "https://github.com/cschin",
      "followers_url": "https://api.github.com/users/cschin/followers",
      "following_url": "https://api.github.com/users/cschin/following{/other_user}",
      "gists_url": "https://api.github.com/users/cschin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cschin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cschin/subscriptions",
      "organizations_url": "https://api.github.com/users/cschin/orgs",
      "repos_url": "https://api.github.com/users/cschin/repos",
      "events_url": "https://api.github.com/users/cschin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cschin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-02T22:49:03Z",
    "updated_at": "2012-04-03T03:26:17Z",
    "author_association": "NONE",
    "body": "About long shell commands, is it possible to redirect the output to a file if we detach all connected client? \nMy personal solution for this is to write the output to a file in my code.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/4895249",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-4895249",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 4895249,
    "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTUyNDk=",
    "user": {
      "login": "cschin",
      "id": 1320747,
      "node_id": "MDQ6VXNlcjEzMjA3NDc=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1320747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cschin",
      "html_url": "https://github.com/cschin",
      "followers_url": "https://api.github.com/users/cschin/followers",
      "following_url": "https://api.github.com/users/cschin/following{/other_user}",
      "gists_url": "https://api.github.com/users/cschin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cschin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cschin/subscriptions",
      "organizations_url": "https://api.github.com/users/cschin/orgs",
      "repos_url": "https://api.github.com/users/cschin/repos",
      "events_url": "https://api.github.com/users/cschin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cschin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-03T06:23:26Z",
    "updated_at": "2012-04-03T06:25:34Z",
    "author_association": "NONE",
    "body": "This is probably just my own user case. It is just some UI tweak request not essential for computing in bioinformatics. I find it will be useful if the output cell can have its own horizontal scrolling bar.  The reason for the UI tweak request is that I find it is really convenient to use IPython notebook to view long DNA sequences. (Before IPython, I use \"less -S\" on a terminal) It will be nice to be able to scroll the output cell but not the whole notebook.  I think it is possible to do this with a simple CSS change.   Comment?\n(This thought makes me wanting to embed some sort of genome browser in IPython notebook if it is doable.)\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5011563",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5011563",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5011563,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUwMTE1NjM=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-07T21:13:06Z",
    "updated_at": "2012-04-07T21:13:06Z",
    "author_association": "NONE",
    "body": "Probably the biggest issue I ran into for (e.g.) http://ged.msu.edu/angus/nih-hmp-2012/index.html was that it was messy to run things in the background.  I really wanted to be able to say \"go run this shell script and let me know when it's done.\"  This is related to the question of detaching output, I guess.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5110005",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5110005",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5110005,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTAwMDU=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T07:49:52Z",
    "updated_at": "2012-04-13T07:49:52Z",
    "author_association": "MEMBER",
    "body": "@ctb, this is a tricky one that will require some thought...  The problem is that our notebook server is, by design, very lightweight and dumb (in a sense :).  It doesn't log any of the traffic coming from kernels, it doesn't keep the notebook document state, nothing.  It just routes messages through and that's about it.  So when kernels spew stdout with no browser client actively listening, that output basically goes into /dev/null.\n\nThe question then is how to best go about implementing a solution to produce the user experience of reconnecting to a notebook and having a way to pick up updated output...\n\nI don't think that making the notebook server heavier is a path we want to follow, as it would rapidly become a brittle and complex bottleneck.  My current thinking would be to have a utility that one could activate, that would leave a new process running on the kernel's computer (since the nb server and kernel machine can in principle be different, and we have no mechanism to trigger code execution on the nb server).  This process could log all output coming from the kernel.  Upon reconnection one could then call the command again, which would print to stdout/err all it had logged.\n\nIt's not the most elegant solution, but it could be a start...  Though this would be limited to one cell only.  If you want to leave multiple processes running in the background, it gets pretty tricky to come up with a clean solution that can reattach those outputs to the cells that they were started from.  Mhh...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5122913",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5122913",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5122913,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjI5MTM=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T19:02:54Z",
    "updated_at": "2012-04-13T19:02:54Z",
    "author_association": "MEMBER",
    "body": "Part of the challenge is that kernels have no knowledge of clients whatsoever - and this is deliberate.\n\nstdout messages are captured when there are no clients.  But when there are no clients around, there is no-one to capture that.  We would have to start having the notebook server (not the kernel) log all of those message, which I don't think is reasonable.  I will think more about this though.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5124305",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5124305",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5124305,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjQzMDU=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T20:25:58Z",
    "updated_at": "2012-04-13T20:25:58Z",
    "author_association": "MEMBER",
    "body": "That's why I suggested a separate utility that the user could start before disconnecting from a session he expects to spew a lot of output.  This would be a standalone monitor that listens to the zmq traffic, logs it, and prints it back afterwards when requested.  It's not elegant though, so it would be good if we could come up with a cleaner solution.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5124342",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5124342",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5124342,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjQzNDI=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T20:28:10Z",
    "updated_at": "2012-04-13T20:28:10Z",
    "author_association": "MEMBER",
    "body": "But that utility would be running on the host where the kernel is.  How would the client get that information? (it can only talk to the main notebook server).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5124445",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5124445",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5124445,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjQ0NDU=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T20:34:31Z",
    "updated_at": "2012-04-13T20:34:31Z",
    "author_association": "MEMBER",
    "body": "Ah, on reconnection the user would type another command to retrieve it.  Imagine (assume we call it monitor):\n\n```\n# you're about to leave, and you have a cell producing lots of stdout/err.  Below it, you type\n\n%monitor start\n\n# and save, leave.\n\n# Next day, reopen the notebook, go to that cell and change it to\n\n%monitor flush\n-> prints all logged stdout/err\n```\n\nAs I said, it would be manual, but it can work fine.  Just not terribly elegant.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5124678",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5124678",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5124678,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjQ2Nzg=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T20:47:23Z",
    "updated_at": "2012-04-13T20:47:23Z",
    "author_association": "MEMBER",
    "body": "Ahh, Ok I think this approach does make sense.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5124749",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5124749",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5124749,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjQ3NDk=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T20:52:12Z",
    "updated_at": "2012-04-13T20:52:12Z",
    "author_association": "MEMBER",
    "body": "It's kind of ugly and unsatisfactory, but since we need to preserve _both_ the simplicity of the nb server and the agnosticism of the kernels regarding which clients are connected to it, I don't see a better solution right now...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5124951",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5124951",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5124951,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjQ5NTE=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-13T21:04:14Z",
    "updated_at": "2012-04-13T21:04:14Z",
    "author_association": "NONE",
    "body": "On Fri, Apr 13, 2012 at 01:52:13PM -0700, Fernando Perez wrote:\n\n> It's kind of ugly and unsatisfactory, but since we need to preserve _both_ the simplicity of the nb server and the agnosticism of the kernels regarding which clients are connected to it, I don't see a better solution right now...\n\nA couple of thoughts.\n\nWhat about having remote ipython kernels that shadow your local commands\nand then report back to the central ipynb when a connection is available?\nSo that I could e.g. start up an ipython client on an EC2 instance, send\ncommands to it, disconnect, reconnect later and then retrieve all the saved up\noutput?\n\nAnother option -- we could put together a shell-executing Python script that\nsits there and records some or all of the output from the shell command, and\ncan regurgitate some or all of it on command.  I'm thinking something like a\nlittle RPC server for executing commands and retrieving results, but without\nhaving to expose it to the open (with all of the attendant security issues).\nThen you could run that together from ipynb and connect/reconnect to it.\n\nI think I must be misunderstanding something about the architecture here, too.\nWhy isn't it easy (or at least possible) to reload an ipynb view without\ncausing problems?  The ipynb kernel should still be running if I close up\nmy laptop, move to a new location, and then reopen my laptop with that\npage.  Is it a websockets issue?  Must be ... if that can be resolved,\nthen I feel like that would be a perfectly good solution to the long-running\nprocess problem.\n\n## --t\n\nC. Titus Brown, ctb@msu.edu\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5128013",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5128013",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5128013,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjgwMTM=",
    "user": {
      "login": "cschin",
      "id": 1320747,
      "node_id": "MDQ6VXNlcjEzMjA3NDc=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1320747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cschin",
      "html_url": "https://github.com/cschin",
      "followers_url": "https://api.github.com/users/cschin/followers",
      "following_url": "https://api.github.com/users/cschin/following{/other_user}",
      "gists_url": "https://api.github.com/users/cschin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cschin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cschin/subscriptions",
      "organizations_url": "https://api.github.com/users/cschin/orgs",
      "repos_url": "https://api.github.com/users/cschin/repos",
      "events_url": "https://api.github.com/users/cschin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cschin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-14T01:48:31Z",
    "updated_at": "2012-04-14T01:48:31Z",
    "author_association": "NONE",
    "body": "Question, if there is a python headless client that emulate a web browser that connects to the kernel and the client send \"save\" command to the kernel with a certainly interval, will this work?  The output from the kernel is captured by the headless client and save the notebook behind the scene. The next time one connect to the kernel from a real browser, it should have everything. However, I forget about the the notebook does use a number of modern web browser technologies it can make emulating a full functional browser hard....  \n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5128109",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5128109",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5128109,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjgxMDk=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-14T02:02:49Z",
    "updated_at": "2012-04-14T02:02:49Z",
    "author_association": "MEMBER",
    "body": "@ctb, to clarify: you can reconnect anytime you want to the kernel, and the python status is always OK, but the 'notebook view' that you have in your web browser will only be whatever you have saved.  Let me try to explain the design: the kernel itself doesn't know who is sending it code to execute; you can even simultaneously have a qtconsole, a text console and a notebook all talking to the same kernel and sending it code and commands.  The kernel is just a dumb REPL but attached to network ports instead of a terminal's stdin/out.  All of the notebook view, with output next to its input cell, is 'assembled' purely on the web browser, using javascript code that records which output comes back from executing a cell and puts it in the right places.\n\nFor this reason, if there is no web browser alive recording the output sent to the network by the kernel, that output is effectively lost.  Hence the idea of parking something right next to the kernel to save this information and regurgitate it later.   In fact, since in a kernel we're already proxying stdout/err with objects that pass the data over to zmq, it would be very easy to add the option to save this output to internal storage, and simply return it later on.  Mmh, that might be the simplest solution: we already have all that data in-hand, it would be a simple matter to keep it instead of discarding it instantly when the user asks...\n\nI hope this helps clarify the picture in your head...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5128408",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5128408",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5128408,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxMjg0MDg=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-14T03:01:32Z",
    "updated_at": "2012-04-14T03:01:32Z",
    "author_association": "MEMBER",
    "body": "@cschin: yes, what you describe is in principle possible, the trick is that there's some logic for that which resides client-side.  @ellisonbg wrote that code originally, so he may correct me here if I'm mistaken...\n\nAnd the reason for this is that the user may do lots of things in the browser that affect the notebook but which require zero kernel participation (and this is a good thing!), such as editing markdown cells, reordering cells, deleting them, merging/splitting them, etc.  All these actions only happen in the browser, so it's necessary for the save action to be initiated client-side, sending to the kernel the view of the notebook that's actually in front of the user, for the kernel to then save it.\n\nBut that doesn't mean that some kind of headless monitor kernel-side can't work, as indicated above.  Now, your idea is interesting in the following direction: the `%monitor` I proposed above would just be something that would buffer stdout/err and would release them later on request.  But one could imagine having instead something like what you propose, which would be limited to saving only stdout/err/results, but which could be useful if you want to for example start running an entire notebook(one that could potentially have multiple cells buffered for execution in the queue) and want to disconnect right away.  In that case, you'd basically do the following:\n1. Remove all output you don't want and save the notebook.\n2. Start the monitor with something like `%nbmonitor`\n3. Disconnect without saving again.\n\nAt 2, the monitor would _read_ the notebook file, and would begin storing all output in the right places in the data structure, doing periodic saves of the file until stopped.\n\nWriting something like this isn't trivial, but it has the advantage that someone could start trying to develop it right now as a standalone little tool, without requiring any changes to the main code.\n\nIt's good to hash some of these things out, this is a tricky problem but an important one to have a good solution for in the long run, so thanks for the input!\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5190933",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5190933",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5190933,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTA5MzM=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T03:02:17Z",
    "updated_at": "2012-04-18T03:02:17Z",
    "author_association": "NONE",
    "body": "Another question, just to drive in my ignorance --\n\nis there any way to have multiple cells updating at the same time?\n\n## --titus\n\nC. Titus Brown, ctb@msu.edu\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5190992",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5190992",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5190992,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTA5OTI=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T03:08:00Z",
    "updated_at": "2012-04-18T03:08:00Z",
    "author_association": "MEMBER",
    "body": "Not currently.  Only the cell whose code is currently running can receive output.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191012",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191012",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191012,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTEwMTI=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T03:10:03Z",
    "updated_at": "2012-04-18T03:10:03Z",
    "author_association": "NONE",
    "body": "On Tue, Apr 17, 2012 at 08:08:01PM -0700, Brian E. Granger wrote:\n\n> Not currently.  Only the cell whose code is currently running can receive output.\n\nWell, yeah... but how hard would this be to change?  For teaching, it was\nannoying that I couldn't run a Web server in one cell while doing stuff\nin the other cell :).\n\nAnother question:\n\nIs there a way to 'break out' of execution of a particular cell?\n\ne.g.\n\nif some_condition:\n    raise StopExecutingCell\n\n# continue and do other stuff if some_condition is false\n\nthanks,\n\n## -titus\n\nC. Titus Brown, ctb@msu.edu\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191214",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191214",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191214,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTEyMTQ=",
    "user": {
      "login": "ellisonbg",
      "id": 27600,
      "node_id": "MDQ6VXNlcjI3NjAw",
      "avatar_url": "https://avatars3.githubusercontent.com/u/27600?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ellisonbg",
      "html_url": "https://github.com/ellisonbg",
      "followers_url": "https://api.github.com/users/ellisonbg/followers",
      "following_url": "https://api.github.com/users/ellisonbg/following{/other_user}",
      "gists_url": "https://api.github.com/users/ellisonbg/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ellisonbg/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ellisonbg/subscriptions",
      "organizations_url": "https://api.github.com/users/ellisonbg/orgs",
      "repos_url": "https://api.github.com/users/ellisonbg/repos",
      "events_url": "https://api.github.com/users/ellisonbg/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ellisonbg/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T03:34:32Z",
    "updated_at": "2012-04-18T03:34:32Z",
    "author_association": "MEMBER",
    "body": "On Tue, Apr 17, 2012 at 8:10 PM, C. Titus Brown\nreply@reply.github.com\nwrote:\n\n> On Tue, Apr 17, 2012 at 08:08:01PM -0700, Brian E. Granger wrote:\n> \n> > Not currently.  Only the cell whose code is currently running can receive output.\n> \n> Well, yeah... but how hard would this be to change?  For teaching, it was\n> annoying that I couldn't run a Web server in one cell while doing stuff\n> in the other cell :).\n\nThere are two issues:\n\n1) The IPython kernel is subject to all the constraints of Python,\nnamely that unless you use threads, only one thing can run at a time.\nFurthermore, because of the GIL, threads are serialized, so you really\ncan't run things in parallel using threads in the kernel.  Thus, the\nbest you could do is to run the web server in a thread and hope that\nyou don't need to call non-GIL releasing extension code while it runs.\n2) Python doesn't have an API that allows you to tell what Python code\nlead to a given output (on stdout/stderr/displayhook).  To cope with\nthis lack we do the following.  When code is submitted to the kernel,\nthe browser gives that code a message id.  Right before the kernel\nruns that code, it saves that message id as the \"active\" message id.\nAnytime there is output, that message id is sent along with the\noutput.  Each time code from a new cell is run, the active message id\nis set to that cells message id.  When those output messages arrive\nback in the browser, it looks at the message id to figure out which\ncell the output came from.  Two important things about this.  1) Only\none cell can be active for output purposes at a time.  2) If code from\na previously active cell is still running (in a thread) and write to\nstdout/displayhook that output will be tagged with a newer cells\nmessage id.  Again, these limitations are related to the fact that\nPython itself doesn't give us a way of knowing who is responsible for\nwhat output.\n\nIn summary: I don't think there is a way of doing what you are asking\nfor without changing the language.  Hope that clarifies things.\n\n> Another question:\n> \n> Is there a way to 'break out' of execution of a particular cell?\n> \n> e.g.\n> \n> if some_condition:\n>        raise StopExecutingCell\n> \n> # continue and do other stuff if some_condition is false\n\nAny exception will stop the cell from executing so a simple:\n\nclass StopExecutingCell(Exception):\n    pass\n\nwill work.  BUT, it will clear the queue of any later cells that have\nbeen queued to run.\n\n> thanks,\n> \n> ## -titus\n> \n> C. Titus Brown, ctb@msu.edu\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/issues/1543#issuecomment-5191012\n\n## \n\nBrian E. Granger\nCal Poly State University, San Luis Obispo\nbgranger@calpoly.edu and ellisonbg@gmail.com\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191245",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191245",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191245,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTEyNDU=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T03:37:53Z",
    "updated_at": "2012-04-18T03:37:53Z",
    "author_association": "NONE",
    "body": "On Tue, Apr 17, 2012 at 08:34:33PM -0700, Brian E. Granger wrote:\n\n> On Tue, Apr 17, 2012 at 8:10 PM, C. Titus Brown\n> reply@reply.github.com\n> wrote:\n> \n> > On Tue, Apr 17, 2012 at 08:08:01PM -0700, Brian E. Granger wrote:\n> > \n> > > Not currently. ??Only the cell whose code is currently running can receive output.\n> > \n> > Well, yeah... but how hard would this be to change? ??For teaching, it was\n> > annoying that I couldn't run a Web server in one cell while doing stuff\n> > in the other cell :).\n> \n> There are two issues:\n> \n> 1) The IPython kernel is subject to all the constraints of Python,\n> namely that unless you use threads, only one thing can run at a time.\n> Furthermore, because of the GIL, threads are serialized, so you really\n> can't run things in parallel using threads in the kernel.  Thus, the\n> best you could do is to run the web server in a thread and hope that\n> you don't need to call non-GIL releasing extension code while it runs.\n> 2) Python doesn't have an API that allows you to tell what Python code\n> lead to a given output (on stdout/stderr/displayhook).  To cope with\n> this lack we do the following.  When code is submitted to the kernel,\n> the browser gives that code a message id.  Right before the kernel\n> runs that code, it saves that message id as the \"active\" message id.\n> Anytime there is output, that message id is sent along with the\n> output.  Each time code from a new cell is run, the active message id\n> is set to that cells message id.  When those output messages arrive\n> back in the browser, it looks at the message id to figure out which\n> cell the output came from.  Two important things about this.  1) Only\n> one cell can be active for output purposes at a time.  2) If code from\n> a previously active cell is still running (in a thread) and write to\n> stdout/displayhook that output will be tagged with a newer cells\n> message id.  Again, these limitations are related to the fact that\n> Python itself doesn't give us a way of knowing who is responsible for\n> what output.\n> \n> In summary: I don't think there is a way of doing what you are asking\n> for without changing the language.  Hope that clarifies things.\n\nI see -- the problem is that there's a single kernel, and you can't\ntell which output is coming from where.  Bummer.  Well, I'm not\nabandoning Python over this... :)\n\n> > Another question:\n> > \n> > Is there a way to 'break out' of execution of a particular cell?\n> > \n> > e.g.\n> > \n> > if some_condition:\n> > ?? ?? ?? ??raise StopExecutingCell\n> > \n> > # continue and do other stuff if some_condition is false\n> \n> Any exception will stop the cell from executing so a simple:\n> \n> class StopExecutingCell(Exception):\n>     pass\n> \n> will work.  BUT, it will clear the queue of any later cells that have\n> been queued to run.\n\nright, so... any chance of adding something that will allow the cell\nto exit without clearing the queue?\n\nthanks,\n\n## --titus\n\nC. Titus Brown, ctb@msu.edu\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191388",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191388",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191388,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTEzODg=",
    "user": {
      "login": "cschin",
      "id": 1320747,
      "node_id": "MDQ6VXNlcjEzMjA3NDc=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1320747?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/cschin",
      "html_url": "https://github.com/cschin",
      "followers_url": "https://api.github.com/users/cschin/followers",
      "following_url": "https://api.github.com/users/cschin/following{/other_user}",
      "gists_url": "https://api.github.com/users/cschin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/cschin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/cschin/subscriptions",
      "organizations_url": "https://api.github.com/users/cschin/orgs",
      "repos_url": "https://api.github.com/users/cschin/repos",
      "events_url": "https://api.github.com/users/cschin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/cschin/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T03:56:27Z",
    "updated_at": "2012-04-18T03:56:27Z",
    "author_association": "NONE",
    "body": "a slightly more humble question, instead to update cell in parallel, will it make sense to enable selection over a range of cell and execute in serial? (like some MMa group of cells...) This should be only an UI thing.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191422",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191422",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191422,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTE0MjI=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T04:00:12Z",
    "updated_at": "2012-04-18T04:00:12Z",
    "author_association": "MEMBER",
    "body": "> will it make sense to enable selection over a range of cell and execute in serial?\n\nYes, absolutely.  All this actually requires is the selection part, which we do have planned. There is nothing at all preventing you from submitting any number of cells for execution while one is running ('Run All' already does this - it submits every cell immediately, and they are queued in the Kernel).\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191439",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191439",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191439,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTE0Mzk=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T04:02:26Z",
    "updated_at": "2012-04-18T04:02:26Z",
    "author_association": "MEMBER",
    "body": "> any chance of adding something that will allow the cell to exit without clearing the queue?\n\nYou will have to argue about this one.  It is a trivial implementation detail to switch the abort-on-error behavior, and I have found that I generally prefer _not_ aborting queued cells on a failure in personal use, though it does make a good deal of sense in principal.\n\nA configurable could be made...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5191468",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5191468",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5191468,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTE0Njg=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T04:05:58Z",
    "updated_at": "2012-04-18T04:05:58Z",
    "author_association": "NONE",
    "body": "Why not a specific exception for this?\n\n---\n\nC. Titus Brown, ctb@msu.edu\n\nOn Apr 18, 2012, at 0:02, Min RK reply@reply.github.com wrote:\n\n> > any chance of adding something that will allow the cell to exit without clearing the queue?\n> \n> You will have to argue about this one.  It is a trivial implementation detail to switch the abort-on-error behavior, and I have found that I generally prefer _not_ aborting queued cells on a failure in personal use, though it does make a good deal of sense in principal.\n> \n> A configurable could be made...\n> \n> ---\n> \n> Reply to this email directly or view it on GitHub:\n> https://github.com/ipython/ipython/issues/1543#issuecomment-5191439\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5192473",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5192473",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5192473,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTI0NzM=",
    "user": {
      "login": "fperez",
      "id": 57394,
      "node_id": "MDQ6VXNlcjU3Mzk0",
      "avatar_url": "https://avatars1.githubusercontent.com/u/57394?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fperez",
      "html_url": "https://github.com/fperez",
      "followers_url": "https://api.github.com/users/fperez/followers",
      "following_url": "https://api.github.com/users/fperez/following{/other_user}",
      "gists_url": "https://api.github.com/users/fperez/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fperez/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fperez/subscriptions",
      "organizations_url": "https://api.github.com/users/fperez/orgs",
      "repos_url": "https://api.github.com/users/fperez/repos",
      "events_url": "https://api.github.com/users/fperez/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fperez/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-18T06:06:55Z",
    "updated_at": "2012-04-18T06:06:55Z",
    "author_association": "MEMBER",
    "body": "On Tue, Apr 17, 2012 at 9:05 PM, C. Titus Brown\nreply@reply.github.com\nwrote:\n\n> Why not a specific exception for this?\n\nActually, it already exists :)  Try it:\n\n```\nfrom IPython.core.error import UsageError\nraise UsageError('this will stop this cell but not the ones after it')\n```\n\nWe could have another Exception with similar behavior and a different\nname for it, but this should get you going already...\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/5231228",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-5231228",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 5231228,
    "node_id": "MDEyOklzc3VlQ29tbWVudDUyMzEyMjg=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-04-19T20:28:17Z",
    "updated_at": "2012-04-19T20:28:17Z",
    "author_association": "NONE",
    "body": "On Tue, Apr 17, 2012 at 11:06:56PM -0700, Fernando Perez wrote:\n\n> On Tue, Apr 17, 2012 at 9:05 PM, C. Titus Brown\n> reply@reply.github.com\n> wrote:\n> \n> > Why not a specific exception for this?\n> \n> Actually, it already exists :)  Try it:\n> \n> ```\n> from IPython.core.error import UsageError\n> raise UsageError('this will stop this cell but not the ones after it')\n> ```\n> \n> We could have another Exception with similar behavior and a different\n> name for it, but this should get you going already...\n\nPerfect.  I can write this into a library and be happy :)\n\nthanks,\n\n## --titus\n\nC. Titus Brown, ctb@msu.edu\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/6134623",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-6134623",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 6134623,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzQ2MjM=",
    "user": {
      "login": "ctb",
      "id": 51016,
      "node_id": "MDQ6VXNlcjUxMDE2",
      "avatar_url": "https://avatars2.githubusercontent.com/u/51016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ctb",
      "html_url": "https://github.com/ctb",
      "followers_url": "https://api.github.com/users/ctb/followers",
      "following_url": "https://api.github.com/users/ctb/following{/other_user}",
      "gists_url": "https://api.github.com/users/ctb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ctb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ctb/subscriptions",
      "organizations_url": "https://api.github.com/users/ctb/orgs",
      "repos_url": "https://api.github.com/users/ctb/repos",
      "events_url": "https://api.github.com/users/ctb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ctb/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-06-05T19:45:58Z",
    "updated_at": "2012-06-05T19:45:58Z",
    "author_association": "NONE",
    "body": "OK, at another bioinformatics workshop, and things are going well (see http://ged.msu.edu/angus/tutorials-2012/ for what we're doing -- notebooks at https://github.com/ngs-docs/ngs-notebooks).  The only annoying thing we've run across so far is shell commands that unexpectedly want input -- e.g. 'cp' wants to know if it should overwrite a file.  Easily fixed by adding -f.  Question, though -- is there a reason that stdin is still available for shell commands executed in ipython notebook?  As I understand it there's no way to communicate with the stdin from the notebook.  Any reason not to just /dev/null it?\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/6139033",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-6139033",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 6139033,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzkwMzM=",
    "user": {
      "login": "takluyver",
      "id": 327925,
      "node_id": "MDQ6VXNlcjMyNzkyNQ==",
      "avatar_url": "https://avatars3.githubusercontent.com/u/327925?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/takluyver",
      "html_url": "https://github.com/takluyver",
      "followers_url": "https://api.github.com/users/takluyver/followers",
      "following_url": "https://api.github.com/users/takluyver/following{/other_user}",
      "gists_url": "https://api.github.com/users/takluyver/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/takluyver/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/takluyver/subscriptions",
      "organizations_url": "https://api.github.com/users/takluyver/orgs",
      "repos_url": "https://api.github.com/users/takluyver/repos",
      "events_url": "https://api.github.com/users/takluyver/events{/privacy}",
      "received_events_url": "https://api.github.com/users/takluyver/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-06-05T22:52:42Z",
    "updated_at": "2012-06-05T22:52:42Z",
    "author_association": "MEMBER",
    "body": "It's a constant source of annoyance, but we don't think there's a good solution. Various programs check whether stdout is a terminal to determine if they should display human readable output - `ls`, for example, displays much nicer output when it believes it's in a terminal. So we use pexpect to run the program in a terminal and get the nice output. But then some programs will assume that the terminal is able to get input.\n\nWe've discussed it a few times, but maybe we should reconsider changing that default.\n"
  },
  {
    "url": "https://api.github.com/repos/ipython/ipython/issues/comments/6139266",
    "html_url": "https://github.com/ipython/ipython/issues/1543#issuecomment-6139266",
    "issue_url": "https://api.github.com/repos/ipython/ipython/issues/1543",
    "id": 6139266,
    "node_id": "MDEyOklzc3VlQ29tbWVudDYxMzkyNjY=",
    "user": {
      "login": "minrk",
      "id": 151929,
      "node_id": "MDQ6VXNlcjE1MTkyOQ==",
      "avatar_url": "https://avatars1.githubusercontent.com/u/151929?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/minrk",
      "html_url": "https://github.com/minrk",
      "followers_url": "https://api.github.com/users/minrk/followers",
      "following_url": "https://api.github.com/users/minrk/following{/other_user}",
      "gists_url": "https://api.github.com/users/minrk/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/minrk/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/minrk/subscriptions",
      "organizations_url": "https://api.github.com/users/minrk/orgs",
      "repos_url": "https://api.github.com/users/minrk/repos",
      "events_url": "https://api.github.com/users/minrk/events{/privacy}",
      "received_events_url": "https://api.github.com/users/minrk/received_events",
      "type": "User",
      "site_admin": false
    },
    "created_at": "2012-06-05T23:06:51Z",
    "updated_at": "2012-06-05T23:06:51Z",
    "author_association": "MEMBER",
    "body": "Can we come up with examples other than ls that are improved by this? It might be worth it to use closed/pipe stdin, and just write a nice colored/columnized `%ls` ourselves, if it's sufficiently uncommon.\n"
  }
]
