{"schema": {"fields":[{"type":"integer","name":"index"},{"type":"string","name":"author_association"},{"type":"string","name":"body"},{"type":"datetime","name":"created_at"},{"type":"string","name":"html_url"},{"type":"integer","name":"id"},{"type":"string","name":"issue_url"},{"type":"string","name":"node_id"},{"type":"datetime","name":"updated_at"},{"type":"string","name":"url"},{"type":"string","name":"user"}],"pandas_version":"0.20.0","primaryKey":["index"]}, "data": [{"index":0,"author_association":"COLLABORATOR","body":"IMO, we don't need this change. Sometimes these logs are very helpful in order to find problems in shader code. Besides, how would you distinct this certain warning from others? With a regular expression? I don't think we want to go this way...","created_at":"2018-02-05T09:44:58.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13251#issuecomment-363031802","id":363031802,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13251","node_id":"MDEyOklzc3VlQ29tbWVudDM2MzAzMTgwMg==","updated_at":"2018-02-05T12:16:50.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/363031802","user":{"following_url":"https:\/\/api.github.com\/users\/Mugen87\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/Mugen87\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/12612165?v=4","url":"https:\/\/api.github.com\/users\/Mugen87","gists_url":"https:\/\/api.github.com\/users\/Mugen87\/gists{\/gist_id}","html_url":"https:\/\/github.com\/Mugen87","subscriptions_url":"https:\/\/api.github.com\/users\/Mugen87\/subscriptions","node_id":"MDQ6VXNlcjEyNjEyMTY1","repos_url":"https:\/\/api.github.com\/users\/Mugen87\/repos","received_events_url":"https:\/\/api.github.com\/users\/Mugen87\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/Mugen87\/starred{\/owner}{\/repo}","site_admin":false,"login":"Mugen87","type":"User","id":12612165,"followers_url":"https:\/\/api.github.com\/users\/Mugen87\/followers","organizations_url":"https:\/\/api.github.com\/users\/Mugen87\/orgs"}},{"index":1,"author_association":"NONE","body":"I understand your perspective off course. I am a developer too after all.\r\nBut what use has it to the user?\r\nMaybe it could useful at debug output\r\n\r\nAnd what do we learn from that log below:\r\n\r\n```\r\n[Warning] THREE.WebGLShader: gl.getShaderInfoLog() (3) (application-b5b178842ab242c82df6.js, line 27251)\r\n\"fragment\"\r\n\"WARNING: 0:1: extension 'GL_ARB_gpu_shader5' is not supported\r\n\"\r\n\"1: precision highp float;\r\n2: precision highp int;\r\n3: #define SHADER_NAME MeshBasicMaterial\r\n4: #define GAMMA_FACTOR 2\r\n5: #define NUM_CLIPPING_PLANES 0\r\n6: #define UNION_CLIPPING_PLANES 0\r\n7: uniform mat4 viewMatrix;\r\n8: uniform vec3 cameraPosition;\r\n9: #define TONE_MAPPING\r\n10: #ifndef saturate\r\n11: \t#define saturate(a) clamp( a, 0.0, 1.0 )\r\n12: #endif\r\n13: uniform float toneMappingExposure;\r\n14: uniform float toneMappingWhitePoint;\r\n15: vec3 LinearToneMapping( vec3 color ) {\r\n16: \treturn toneMappingExposure * color;\r\n17: }\r\n18: vec3 ReinhardToneMapping( vec3 color ) {\r\n19: \tcolor *= toneMappingExposure;\r\n20: \treturn saturate( color \/ ( vec3( 1.0 ) + color ) );\r\n21: }\r\n22: #define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) \/ ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 \/ 0.30, vec3( 0.0 ) )\r\n23: vec3 Uncharted2ToneMapping( vec3 color ) {\r\n24: \tcolor *= toneMappingExposure;\r\n25: \treturn saturate( Uncharted2Helper( color ) \/ Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\r\n26: }\r\n27: vec3 OptimizedCineonToneMapping( vec3 color ) {\r\n28: \tcolor *= toneMappingExposure;\r\n29: \tcolor = max( vec3( 0.0 ), color - 0.004 );\r\n30: \treturn pow( ( color * ( 6.2 * color + 0.5 ) ) \/ ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\r\n31: }\r\n32: \r\n33: vec3 toneMapping( vec3 color ) { return LinearToneMapping( color ); }\r\n34: \r\n35: vec4 LinearToLinear( in vec4 value ) {\r\n36: \treturn value;\r\n37: }\r\n38: vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\r\n39: \treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\r\n40: }\r\n41: vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\r\n42: \treturn vec4( pow( value.xyz, vec3( 1.0 \/ gammaFactor ) ), value.w );\r\n43: }\r\n44: vec4 sRGBToLinear( in vec4 value ) {\r\n45: \treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\r\n46: }\r\n47: vec4 LinearTosRGB( in vec4 value ) {\r\n48: \treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\r\n49: }\r\n50: vec4 RGBEToLinear( in vec4 value ) {\r\n51: \treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\r\n52: }\r\n53: vec4 LinearToRGBE( in vec4 value ) {\r\n54: \tfloat maxComponent = max( max( value.r, value.g ), value.b );\r\n55: \tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\r\n56: \treturn vec4( value.rgb \/ exp2( fExp ), ( fExp + 128.0 ) \/ 255.0 );\r\n57: }\r\n58: vec4 RGBMToLinear( in vec4 value, in float maxRange ) {\r\n59: \treturn vec4( value.xyz * value.w * maxRange, 1.0 );\r\n60: }\r\n61: vec4 LinearToRGBM( in vec4 value, in float maxRange ) {\r\n62: \tfloat maxRGB = max( value.x, max( value.g, value.b ) );\r\n63: \tfloat M      = clamp( maxRGB \/ maxRange, 0.0, 1.0 );\r\n64: \tM            = ceil( M * 255.0 ) \/ 255.0;\r\n65: \treturn vec4( value.rgb \/ ( M * maxRange ), M );\r\n66: }\r\n67: vec4 RGBDToLinear( in vec4 value, in float maxRange ) {\r\n68: \treturn vec4( value.rgb * ( ( maxRange \/ 255.0 ) \/ value.a ), 1.0 );\r\n69: }\r\n70: vec4 LinearToRGBD( in vec4 value, in float maxRange ) {\r\n71: \tfloat maxRGB = max( value.x, max( value.g, value.b ) );\r\n72: \tfloat D      = max( maxRange \/ maxRGB, 1.0 );\r\n73: \tD            = min( floor( D ) \/ 255.0, 1.0 );\r\n74: \treturn vec4( value.rgb * ( D * ( 255.0 \/ maxRange ) ), D );\r\n75: }\r\n76: const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\r\n77: vec4 LinearToLogLuv( in vec4 value )  {\r\n78: \tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\r\n79: \tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\r\n80: \tvec4 vResult;\r\n81: \tvResult.xy = Xp_Y_XYZp.xy \/ Xp_Y_XYZp.z;\r\n82: \tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\r\n83: \tvResult.w = fract(Le);\r\n84: \tvResult.z = (Le - (floor(vResult.w*255.0))\/255.0)\/255.0;\r\n85: \treturn vResult;\r\n86: }\r\n87: const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\r\n88: vec4 LogLuvToLinear( in vec4 value ) {\r\n89: \tfloat Le = value.z * 255.0 + value.w;\r\n90: \tvec3 Xp_Y_XYZp;\r\n91: \tXp_Y_XYZp.y = exp2((Le - 127.0) \/ 2.0);\r\n92: \tXp_Y_XYZp.z = Xp_Y_XYZp.y \/ value.y;\r\n93: \tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\r\n94: \tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\r\n95: \treturn vec4( max(vRGB, 0.0), 1.0 );\r\n96: }\r\n97: \r\n98: vec4 mapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }\r\n99: vec4 envMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }\r\n100: vec4 emissiveMapTexelToLinear( vec4 value ) { return LinearToLinear( value ); }\r\n101: vec4 linearToOutputTexel( vec4 value ) { return LinearToLinear( value ); }\r\n102: \r\n103: uniform vec3 diffuse;\r\n104: uniform float opacity;\r\n105: #ifndef FLAT_SHADED\r\n106: \tvarying vec3 vNormal;\r\n107: #endif\r\n108: #define PI 3.14159265359\r\n109: #define PI2 6.28318530718\r\n110: #define PI_HALF 1.5707963267949\r\n111: #define RECIPROCAL_PI 0.31830988618\r\n112: #define RECIPROCAL_PI2 0.15915494\r\n113: #define LOG2 1.442695\r\n114: #define EPSILON 1e-6\r\n115: #define saturate(a) clamp( a, 0.0, 1.0 )\r\n116: #define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n117: float pow2( const in float x ) { return x*x; }\r\n118: float pow3( const in float x ) { return x*x*x; }\r\n119: float pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\n120: float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n121: highp float rand( const in vec2 uv ) {\r\n122: \tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\r\n123: \thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n124: \treturn fract(sin(sn) * c);\r\n125: }\r\n126: struct IncidentLight {\r\n127: \tvec3 color;\r\n128: \tvec3 direction;\r\n129: \tbool visible;\r\n130: };\r\n131: struct ReflectedLight {\r\n132: \tvec3 directDiffuse;\r\n133: \tvec3 directSpecular;\r\n134: \tvec3 indirectDiffuse;\r\n135: \tvec3 indirectSpecular;\r\n136: };\r\n137: struct GeometricContext {\r\n138: \tvec3 position;\r\n139: \tvec3 normal;\r\n140: \tvec3 viewDir;\r\n141: };\r\n142: vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\r\n143: \treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\r\n144: }\r\n145: vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n146: \treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n147: }\r\n148: vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n149: \tfloat distance = dot( planeNormal, point - pointOnPlane );\r\n150: \treturn - distance * planeNormal + point;\r\n151: }\r\n152: float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n153: \treturn sign( dot( point - pointOnPlane, planeNormal ) );\r\n154: }\r\n155: vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n156: \treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) \/ dot( planeNormal, lineDirection ) ) + pointOnLine;\r\n157: }\r\n158: mat3 transposeMat3( const in mat3 m ) {\r\n159: \tmat3 tmp;\r\n160: \ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\r\n161: \ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\r\n162: \ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\r\n163: \treturn tmp;\r\n164: }\r\n165: float linearToRelativeLuminance( const in vec3 color ) {\r\n166: \tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\r\n167: \treturn dot( weights, color.rgb );\r\n168: }\r\n169: \r\n170: #ifdef USE_COLOR\r\n171: \tvarying vec3 vColor;\r\n172: #endif\r\n173: \r\n174: #if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n175: \tvarying vec2 vUv;\r\n176: #endif\r\n177: #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n178: \tvarying vec2 vUv2;\r\n179: #endif\r\n180: #ifdef USE_MAP\r\n181: \tuniform sampler2D map;\r\n182: #endif\r\n183: \r\n184: #ifdef USE_ALPHAMAP\r\n185: \tuniform sampler2D alphaMap;\r\n186: #endif\r\n187: \r\n188: #ifdef USE_AOMAP\r\n189: \tuniform sampler2D aoMap;\r\n190: \tuniform float aoMapIntensity;\r\n191: #endif\r\n192: #ifdef USE_LIGHTMAP\r\n193: \tuniform sampler2D lightMap;\r\n194: \tuniform float lightMapIntensity;\r\n195: #endif\r\n196: #if defined( USE_ENVMAP ) || defined( PHYSICAL )\r\n197: \tuniform float reflectivity;\r\n198: \tuniform float envMapIntensity;\r\n199: #endif\r\n200: #ifdef USE_ENVMAP\r\n201: \t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\r\n202: \t\tvarying vec3 vWorldPosition;\r\n203: \t#endif\r\n204: \t#ifdef ENVMAP_TYPE_CUBE\r\n205: \t\tuniform samplerCube envMap;\r\n206: \t#else\r\n207: \t\tuniform sampler2D envMap;\r\n208: \t#endif\r\n209: \tuniform float flipEnvMap;\r\n210: \t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\r\n211: \t\tuniform float refractionRatio;\r\n212: \t#else\r\n213: \t\tvarying vec3 vReflect;\r\n214: \t#endif\r\n215: #endif\r\n216: \r\n217: #ifdef USE_FOG\r\n218: \tuniform vec3 fogColor;\r\n219: \tvarying float fogDepth;\r\n220: \t#ifdef FOG_EXP2\r\n221: \t\tuniform float fogDensity;\r\n222: \t#else\r\n223: \t\tuniform float fogNear;\r\n224: \t\tuniform float fogFar;\r\n225: \t#endif\r\n226: #endif\r\n227: \r\n228: #ifdef USE_SPECULARMAP\r\n229: \tuniform sampler2D specularMap;\r\n230: #endif\r\n231: #ifdef USE_LOGDEPTHBUF\r\n232: \tuniform float logDepthBufFC;\r\n233: \t#ifdef USE_LOGDEPTHBUF_EXT\r\n234: \t\tvarying float vFragDepth;\r\n235: \t#endif\r\n236: #endif\r\n237: \r\n238: #if NUM_CLIPPING_PLANES > 0\r\n239: \t#if ! defined( PHYSICAL ) && ! defined( PHONG )\r\n240: \t\tvarying vec3 vViewPosition;\r\n241: \t#endif\r\n242: \tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\r\n243: #endif\r\n244: \r\n245: void main() {\r\n246: #if NUM_CLIPPING_PLANES > 0\r\n247: \tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\r\n248: \t\tvec4 plane = clippingPlanes[ i ];\r\n249: \t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\r\n250: \t}\r\n251: \t\t\r\n252: \t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\r\n253: \t\tbool clipped = true;\r\n254: \t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\r\n255: \t\t\tvec4 plane = clippingPlanes[ i ];\r\n256: \t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\r\n257: \t\t}\r\n258: \t\tif ( clipped ) discard;\r\n259: \t\r\n260: \t#endif\r\n261: #endif\r\n262: \r\n263: \tvec4 diffuseColor = vec4( diffuse, opacity );\r\n264: #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\r\n265: \tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\r\n266: #endif\r\n267: #ifdef USE_MAP\r\n268: \tvec4 texelColor = texture2D( map, vUv );\r\n269: \ttexelColor = mapTexelToLinear( texelColor );\r\n270: \tdiffuseColor *= texelColor;\r\n271: #endif\r\n272: \r\n273: #ifdef USE_COLOR\r\n274: \tdiffuseColor.rgb *= vColor;\r\n275: #endif\r\n276: #ifdef USE_ALPHAMAP\r\n277: \tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\r\n278: #endif\r\n279: \r\n280: #ifdef ALPHATEST\r\n281: \tif ( diffuseColor.a < ALPHATEST ) discard;\r\n282: #endif\r\n283: \r\n284: float specularStrength;\r\n285: #ifdef USE_SPECULARMAP\r\n286: \tvec4 texelSpecular = texture2D( specularMap, vUv );\r\n287: \tspecularStrength = texelSpecular.r;\r\n288: #else\r\n289: \tspecularStrength = 1.0;\r\n290: #endif\r\n291: \tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n292: \t#ifdef USE_LIGHTMAP\r\n293: \t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n294: \t#else\r\n295: \t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n296: \t#endif\r\n297: #ifdef USE_AOMAP\r\n298: \tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\r\n299: \treflectedLight.indirectDiffuse *= ambientOcclusion;\r\n300: \t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n301: \t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n302: \t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\r\n303: \t#endif\r\n304: #endif\r\n305: \r\n306: \treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n307: \tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n308: #ifdef USE_ENVMAP\r\n309: \t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n310: \t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\r\n311: \t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n312: \t\t#ifdef ENVMAP_MODE_REFLECTION\r\n313: \t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\r\n314: \t\t#else\r\n315: \t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\r\n316: \t\t#endif\r\n317: \t#else\r\n318: \t\tvec3 reflectVec = vReflect;\r\n319: \t#endif\r\n320: \t#ifdef ENVMAP_TYPE_CUBE\r\n321: \t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\r\n322: \t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n323: \t\tvec2 sampleUV;\r\n324: \t\treflectVec = normalize( reflectVec );\r\n325: \t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n326: \t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n327: \t\tvec4 envColor = texture2D( envMap, sampleUV );\r\n328: \t#elif defined( ENVMAP_TYPE_SPHERE )\r\n329: \t\treflectVec = normalize( reflectVec );\r\n330: \t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\r\n331: \t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\r\n332: \t#else\r\n333: \t\tvec4 envColor = vec4( 0.0 );\r\n334: \t#endif\r\n335: \tenvColor = envMapTexelToLinear( envColor );\r\n336: \t#ifdef ENVMAP_BLENDING_MULTIPLY\r\n337: \t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\r\n338: \t#elif defined( ENVMAP_BLENDING_MIX )\r\n339: \t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\r\n340: \t#elif defined( ENVMAP_BLENDING_ADD )\r\n341: \t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\r\n342: \t#endif\r\n343: #endif\r\n344: \r\n345: \tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n346: #ifdef PREMULTIPLIED_ALPHA\r\n347: \tgl_FragColor.rgb *= gl_FragColor.a;\r\n348: #endif\r\n349: \r\n350: #if defined( TONE_MAPPING )\r\n351:   gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\r\n352: #endif\r\n353: \r\n354:   gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n355: \r\n356: #ifdef USE_FOG\r\n357: \t#ifdef FOG_EXP2\r\n358: \t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\r\n359: \t#else\r\n360: \t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\r\n361: \t#endif\r\n362: \tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\r\n363: #endif\r\n364: \r\n365: }\r\n366: \"\r\n```\r\n","created_at":"2018-02-05T12:22:00.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13251#issuecomment-363069385","id":363069385,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13251","node_id":"MDEyOklzc3VlQ29tbWVudDM2MzA2OTM4NQ==","updated_at":"2018-02-06T01:43:49.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/363069385","user":{"following_url":"https:\/\/api.github.com\/users\/rubydesign\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/rubydesign\/events{\/privacy}","avatar_url":"https:\/\/avatars3.githubusercontent.com\/u\/142157?v=4","url":"https:\/\/api.github.com\/users\/rubydesign","gists_url":"https:\/\/api.github.com\/users\/rubydesign\/gists{\/gist_id}","html_url":"https:\/\/github.com\/rubydesign","subscriptions_url":"https:\/\/api.github.com\/users\/rubydesign\/subscriptions","node_id":"MDQ6VXNlcjE0MjE1Nw==","repos_url":"https:\/\/api.github.com\/users\/rubydesign\/repos","received_events_url":"https:\/\/api.github.com\/users\/rubydesign\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/rubydesign\/starred{\/owner}{\/repo}","site_admin":false,"login":"rubydesign","type":"User","id":142157,"followers_url":"https:\/\/api.github.com\/users\/rubydesign\/followers","organizations_url":"https:\/\/api.github.com\/users\/rubydesign\/orgs"}},{"index":2,"author_association":"COLLABORATOR","body":"related: #5835","created_at":"2018-02-05T12:34:14.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13251#issuecomment-363071940","id":363071940,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13251","node_id":"MDEyOklzc3VlQ29tbWVudDM2MzA3MTk0MA==","updated_at":"2018-02-05T12:34:14.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/363071940","user":{"following_url":"https:\/\/api.github.com\/users\/Mugen87\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/Mugen87\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/12612165?v=4","url":"https:\/\/api.github.com\/users\/Mugen87","gists_url":"https:\/\/api.github.com\/users\/Mugen87\/gists{\/gist_id}","html_url":"https:\/\/github.com\/Mugen87","subscriptions_url":"https:\/\/api.github.com\/users\/Mugen87\/subscriptions","node_id":"MDQ6VXNlcjEyNjEyMTY1","repos_url":"https:\/\/api.github.com\/users\/Mugen87\/repos","received_events_url":"https:\/\/api.github.com\/users\/Mugen87\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/Mugen87\/starred{\/owner}{\/repo}","site_admin":false,"login":"Mugen87","type":"User","id":12612165,"followers_url":"https:\/\/api.github.com\/users\/Mugen87\/followers","organizations_url":"https:\/\/api.github.com\/users\/Mugen87\/orgs"}},{"index":3,"author_association":"OWNER","body":"The core problem here is `WARNING: 0:1: extension 'GL_ARB_gpu_shader5' is not supported` which shouldn't be reported.\r\n\r\nIt'll be better to report this to Safari instead.","created_at":"2018-02-06T01:43:17.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13251#issuecomment-363282358","id":363282358,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13251","node_id":"MDEyOklzc3VlQ29tbWVudDM2MzI4MjM1OA==","updated_at":"2018-02-06T01:43:17.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/363282358","user":{"following_url":"https:\/\/api.github.com\/users\/mrdoob\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/mrdoob\/events{\/privacy}","avatar_url":"https:\/\/avatars0.githubusercontent.com\/u\/97088?v=4","url":"https:\/\/api.github.com\/users\/mrdoob","gists_url":"https:\/\/api.github.com\/users\/mrdoob\/gists{\/gist_id}","html_url":"https:\/\/github.com\/mrdoob","subscriptions_url":"https:\/\/api.github.com\/users\/mrdoob\/subscriptions","node_id":"MDQ6VXNlcjk3MDg4","repos_url":"https:\/\/api.github.com\/users\/mrdoob\/repos","received_events_url":"https:\/\/api.github.com\/users\/mrdoob\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/mrdoob\/starred{\/owner}{\/repo}","site_admin":false,"login":"mrdoob","type":"User","id":97088,"followers_url":"https:\/\/api.github.com\/users\/mrdoob\/followers","organizations_url":"https:\/\/api.github.com\/users\/mrdoob\/orgs"}}]}