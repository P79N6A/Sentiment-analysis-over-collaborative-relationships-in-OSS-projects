{"schema": {"fields":[{"type":"integer","name":"index"},{"type":"string","name":"author_association"},{"type":"string","name":"body"},{"type":"datetime","name":"created_at"},{"type":"string","name":"html_url"},{"type":"integer","name":"id"},{"type":"string","name":"issue_url"},{"type":"string","name":"node_id"},{"type":"datetime","name":"updated_at"},{"type":"string","name":"url"},{"type":"string","name":"user"}],"pandas_version":"0.20.0","primaryKey":["index"]}, "data": [{"index":0,"author_association":"CONTRIBUTOR","body":"I didn't see many people interested in this subject.\n(probably because I didn't see any serious project made in THREE ...)\nAnyway, for those interested:\nHere is the updated UTF8 loader (with progress callback):\nhttp:\/\/necromanthus.com\/Test\/html5\/JS\/UTF8Loader.js \n\nAnd here you can see it in action:\nhttp:\/\/necromanthus.com\/Test\/html5\/test9.html \n\ncheers\n","created_at":"2015-04-20T13:34:59.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/6350#issuecomment-94451974","id":94451974,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/6350","node_id":"MDEyOklzc3VlQ29tbWVudDk0NDUxOTc0","updated_at":"2015-04-20T13:34:59.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/94451974","user":{"following_url":"https:\/\/api.github.com\/users\/RemusMar\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/RemusMar\/events{\/privacy}","avatar_url":"https:\/\/avatars1.githubusercontent.com\/u\/11772787?v=4","url":"https:\/\/api.github.com\/users\/RemusMar","gists_url":"https:\/\/api.github.com\/users\/RemusMar\/gists{\/gist_id}","html_url":"https:\/\/github.com\/RemusMar","subscriptions_url":"https:\/\/api.github.com\/users\/RemusMar\/subscriptions","node_id":"MDQ6VXNlcjExNzcyNzg3","repos_url":"https:\/\/api.github.com\/users\/RemusMar\/repos","received_events_url":"https:\/\/api.github.com\/users\/RemusMar\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/RemusMar\/starred{\/owner}{\/repo}","site_admin":false,"login":"RemusMar","type":"User","id":11772787,"followers_url":"https:\/\/api.github.com\/users\/RemusMar\/followers","organizations_url":"https:\/\/api.github.com\/users\/RemusMar\/orgs"}},{"index":1,"author_association":"OWNER","body":"That's a lot of things that changed.\n\n``` diff\ndiff --git a\/examples\/js\/loaders\/UTF8Loader.js b\/examples\/js\/loaders\/UTF8Loader.js\nindex bca7d9a..b6eb004 100644\n--- a\/examples\/js\/loaders\/UTF8Loader.js\n+++ b\/examples\/js\/loaders\/UTF8Loader.js\n@@ -1,781 +1,430 @@\n-\/**\n- * Loader for UTF8 version2 (after r51) encoded models generated by:\n- * http:\/\/code.google.com\/p\/webgl-loader\/\n- *\n- * Code to load\/decompress mesh is taken from r100 of this webgl-loader\n- *\/\n-\n-THREE.UTF8Loader = function () {};\n-\n-\/**\n- * Load UTF8 encoded model\n- * @param jsonUrl - URL from which to load json containing information about model\n- * @param callback - Callback(THREE.Object3D) on successful loading of model\n- * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)\n- *                  Additional options include\n- *                   geometryBase: Base url from which to load referenced geometries\n- *                   materialBase: Base url from which to load referenced textures\n- *\/\n-\n-THREE.UTF8Loader.prototype.load = function ( jsonUrl, callback, options ) {\n-\n-   this.downloadModelJson( jsonUrl, callback, options );\n-\n+THREE.UTF8Loader = function ( showStatus ) {\n+   THREE.Loader.call( this, showStatus );\n };\n\n-\/\/ BufferGeometryCreator\n+THREE.UTF8Loader.prototype.load = function ( jsonUrl, callback, options, callbackProgress ) {\n+   this.downloadModelJson( jsonUrl, callback, options, callbackProgress );\n+};\n\n THREE.UTF8Loader.BufferGeometryCreator = function () {\n };\n\n THREE.UTF8Loader.BufferGeometryCreator.prototype.create = function ( attribArray, indices ) {\n-\n    var ntris = indices.length \/ 3;\n-\n    var geometry = new THREE.BufferGeometry();\n-\n    var positions = new Float32Array( ntris * 3 * 3 );\n    var normals = new Float32Array( ntris * 3 * 3 );\n    var uvs = new Float32Array( ntris * 3 * 2 );\n-\n    var i, j, offset;\n    var x, y, z;\n    var u, v;\n-\n    var end = attribArray.length;\n    var stride = 8;\n-\n-   \/\/ extract positions\n-\n    j = 0;\n    offset = 0;\n-\n    for ( i = offset; i < end; i += stride ) {\n-\n        x = attribArray[ i ];\n        y = attribArray[ i + 1 ];\n        z = attribArray[ i + 2 ];\n-\n        positions[ j ++ ] = x;\n        positions[ j ++ ] = y;\n        positions[ j ++ ] = z;\n-\n    }\n-\n-   \/\/ extract uvs\n-\n    j = 0;\n    offset = 3;\n-\n    for ( i = offset; i < end; i += stride ) {\n-\n        u = attribArray[ i ];\n        v = attribArray[ i + 1 ];\n-\n        uvs[ j ++ ] = u;\n        uvs[ j ++ ] = v;\n-\n    }\n-\n-   \/\/ extract normals\n-\n    j = 0;\n    offset = 5;\n-\n    for ( i = offset; i < end; i += stride ) {\n-\n        x = attribArray[ i ];\n        y = attribArray[ i + 1 ];\n        z = attribArray[ i + 2 ];\n-\n        normals[ j ++ ] = x;\n        normals[ j ++ ] = y;\n        normals[ j ++ ] = z;\n-\n    }\n-\n    geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\n    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n    geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n    geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n-\n    geometry.offsets.push( { start: 0, count: indices.length, index: 0 } );\n-\n    geometry.computeBoundingSphere();\n-\n    return geometry;\n-\n };\n\n-\n-\/\/ UTF-8 decoder from webgl-loader (r100)\n-\/\/ http:\/\/code.google.com\/p\/webgl-loader\/\n-\n-\/\/ Model manifest description. Contains objects like:\n-\/\/ name: {\n-\/\/   materials: { 'material_name': { ... } ... },\n-\/\/   decodeParams: {\n-\/\/     decodeOffsets: [ ... ],\n-\/\/     decodeScales: [ ... ],\n-\/\/   },\n-\/\/   urls: {\n-\/\/     'url': [\n-\/\/       { material: 'material_name',\n-\/\/         attribRange: [#, #],\n-\/\/         indexRange: [#, #],\n-\/\/         names: [ 'object names' ... ],\n-\/\/         lengths: [#, #, # ... ]\n-\/\/       }\n-\/\/     ],\n-\/\/     ...\n-\/\/   }\n-\/\/ }\n-\n var DEFAULT_DECODE_PARAMS = {\n-\n     decodeOffsets: [ -4095, -4095, -4095, 0, 0, -511, -511, -511 ],\n     decodeScales: [ 1 \/ 8191, 1 \/ 8191, 1 \/ 8191, 1 \/ 1023, 1 \/ 1023, 1 \/ 1023, 1 \/ 1023, 1 \/ 1023 ]\n-\n-    \/\/ TODO: normal decoding? (see walt.js)\n-    \/\/ needs to know: input, output (from vertex format!)\n-    \/\/\n-    \/\/ Should split attrib\/index.\n-    \/\/ 1) Decode position and non-normal attributes.\n-    \/\/ 2) Decode indices, computing normals\n-    \/\/ 3) Maybe normalize normals? Only necessary for refinement, or fixed?\n-    \/\/ 4) Maybe refine normals? Should this be part of regular refinement?\n-    \/\/ 5) Morphing\n-\n };\n\n-\/\/ Triangle strips!\n-\n-\/\/ TODO: will it be an optimization to specialize this method at\n-\/\/ runtime for different combinations of stride, decodeOffset and\n-\/\/ decodeScale?\n-\n-THREE.UTF8Loader.prototype.decompressAttribsInner_ = function ( str, inputStart, inputEnd,\n-                                                                  output, outputStart, stride,\n-                                                                  decodeOffset, decodeScale ) {\n\n+THREE.UTF8Loader.prototype.decompressAttribsInner_ = function ( str, inputStart, inputEnd, output, outputStart, stride, decodeOffset, decodeScale ) {\n    var prev = 0;\n-\n    for ( var j = inputStart; j < inputEnd; j ++ ) {\n-\n        var code = str.charCodeAt( j );\n        prev += ( code >> 1 ) ^ ( -( code & 1 ) );\n-\n        output[ outputStart ] = decodeScale * ( prev + decodeOffset );\n        outputStart += stride;\n-\n    }\n-\n };\n\n-THREE.UTF8Loader.prototype.decompressIndices_ = function( str, inputStart, numIndices,\n-                                                            output, outputStart ) {\n-\n+THREE.UTF8Loader.prototype.decompressIndices_ = function( str, inputStart, numIndices, output, outputStart ) {\n    var highest = 0;\n-\n    for ( var i = 0; i < numIndices; i ++ ) {\n-\n        var code = str.charCodeAt( inputStart ++ );\n-\n        output[ outputStart ++ ] = highest - code;\n-\n        if ( code === 0 ) {\n-\n            highest ++;\n-\n        }\n-\n    }\n-\n };\n\n-THREE.UTF8Loader.prototype.decompressAABBs_ = function ( str, inputStart, numBBoxen,\n-                                                           decodeOffsets, decodeScales ) {\n+THREE.UTF8Loader.prototype.decompressAABBs_ = function ( str, inputStart, numBBoxen, decodeOffsets, decodeScales ) {\n    var numFloats = 6 * numBBoxen;\n-\n    var inputEnd = inputStart + numFloats;\n    var outputStart = 0;\n-\n    var bboxen = new Float32Array( numFloats );\n-\n    for ( var i = inputStart; i < inputEnd; i += 6 ) {\n-\n        var minX = str.charCodeAt(i + 0) + decodeOffsets[0];\n        var minY = str.charCodeAt(i + 1) + decodeOffsets[1];\n        var minZ = str.charCodeAt(i + 2) + decodeOffsets[2];\n-\n        var radiusX = (str.charCodeAt(i + 3) + 1) >> 1;\n        var radiusY = (str.charCodeAt(i + 4) + 1) >> 1;\n        var radiusZ = (str.charCodeAt(i + 5) + 1) >> 1;\n-\n        bboxen[ outputStart ++ ] = decodeScales[0] * (minX + radiusX);\n        bboxen[ outputStart ++ ] = decodeScales[1] * (minY + radiusY);\n        bboxen[ outputStart ++ ] = decodeScales[2] * (minZ + radiusZ);\n-\n        bboxen[ outputStart ++ ] = decodeScales[0] * radiusX;\n        bboxen[ outputStart ++ ] = decodeScales[1] * radiusY;\n        bboxen[ outputStart ++ ] = decodeScales[2] * radiusZ;\n-\n    }\n-\n    return bboxen;\n-\n };\n\n THREE.UTF8Loader.prototype.decompressMesh =  function ( str, meshParams, decodeParams, name, idx, callback ) {\n-\n-    \/\/ Extract conversion parameters from attribArrays.\n-\n    var stride = decodeParams.decodeScales.length;\n-\n    var decodeOffsets = decodeParams.decodeOffsets;\n    var decodeScales = decodeParams.decodeScales;\n-\n    var attribStart = meshParams.attribRange[0];\n    var numVerts = meshParams.attribRange[1];\n-\n-    \/\/ Decode attributes.\n-\n    var inputOffset = attribStart;\n    var attribsOut = new Float32Array( stride * numVerts );\n-\n    for (var j = 0; j < stride; j ++ ) {\n-\n        var end = inputOffset + numVerts;\n-\n        var decodeScale = decodeScales[j];\n-\n        if ( decodeScale ) {\n-\n-            \/\/ Assume if decodeScale is never set, simply ignore the\n-            \/\/ attribute.\n-\n            this.decompressAttribsInner_( str, inputOffset, end,\n                 attribsOut, j, stride,\n                 decodeOffsets[j], decodeScale );\n        }\n-\n        inputOffset = end;\n-\n    }\n-\n    var indexStart = meshParams.indexRange[ 0 ];\n    var numIndices = 3 * meshParams.indexRange[ 1 ];\n-\n    var indicesOut = new Uint16Array( numIndices );\n-\n    this.decompressIndices_( str, inputOffset, numIndices, indicesOut, 0 );\n-\n-    \/\/ Decode bboxen.\n-\n    var bboxen = undefined;\n    var bboxOffset = meshParams.bboxes;\n-\n    if ( bboxOffset ) {\n-\n        bboxen = this.decompressAABBs_( str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales );\n    }\n-\n    callback( name, idx, attribsOut, indicesOut, bboxen, meshParams );\n-\n };\n\n THREE.UTF8Loader.prototype.copyAttrib = function ( stride, attribsOutFixed, lastAttrib, index ) {\n-\n    for ( var j = 0; j < stride; j ++ ) {\n-\n        lastAttrib[ j ] = attribsOutFixed[ stride * index + j ];\n-\n    }\n-\n };\n\n THREE.UTF8Loader.prototype.decodeAttrib2 = function ( str, stride, decodeOffsets, decodeScales, deltaStart,\n-                                                        numVerts, attribsOut, attribsOutFixed, lastAttrib,\n-                                                        index ) {\n-\n+                                                        numVerts, attribsOut, attribsOutFixed, lastAttrib, index ) {\n    for ( var j = 0; j < 5; j ++ ) {\n-\n        var code = str.charCodeAt( deltaStart + numVerts * j + index );\n        var delta = ( code >> 1) ^ (-(code & 1));\n-\n        lastAttrib[ j ] += delta;\n        attribsOutFixed[ stride * index + j ] = lastAttrib[ j ];\n        attribsOut[ stride * index + j ] = decodeScales[ j ] * ( lastAttrib[ j ] + decodeOffsets[ j ] );\n    }\n-\n };\n\n THREE.UTF8Loader.prototype.accumulateNormal = function ( i0, i1, i2, attribsOutFixed, crosses ) {\n-\n    var p0x = attribsOutFixed[ 8 * i0 ];\n    var p0y = attribsOutFixed[ 8 * i0 + 1 ];\n    var p0z = attribsOutFixed[ 8 * i0 + 2 ];\n-\n    var p1x = attribsOutFixed[ 8 * i1 ];\n    var p1y = attribsOutFixed[ 8 * i1 + 1 ];\n    var p1z = attribsOutFixed[ 8 * i1 + 2 ];\n-\n    var p2x = attribsOutFixed[ 8 * i2 ];\n    var p2y = attribsOutFixed[ 8 * i2 + 1 ];\n    var p2z = attribsOutFixed[ 8 * i2 + 2 ];\n-\n    p1x -= p0x;\n    p1y -= p0y;\n    p1z -= p0z;\n-\n    p2x -= p0x;\n    p2y -= p0y;\n    p2z -= p0z;\n-\n    p0x = p1y * p2z - p1z * p2y;\n    p0y = p1z * p2x - p1x * p2z;\n    p0z = p1x * p2y - p1y * p2x;\n-\n    crosses[ 3 * i0 ]     += p0x;\n    crosses[ 3 * i0 + 1 ] += p0y;\n    crosses[ 3 * i0 + 2 ] += p0z;\n-\n    crosses[ 3 * i1 ]     += p0x;\n    crosses[ 3 * i1 + 1 ] += p0y;\n    crosses[ 3 * i1 + 2 ] += p0z;\n-\n    crosses[ 3 * i2 ]     += p0x;\n    crosses[ 3 * i2 + 1 ] += p0y;\n    crosses[ 3 * i2 + 2 ] += p0z;\n-\n };\n\n THREE.UTF8Loader.prototype.decompressMesh2 = function( str, meshParams, decodeParams, name, idx, callback ) {\n-\n    var MAX_BACKREF = 96;\n-\n-    \/\/ Extract conversion parameters from attribArrays.\n-\n    var stride = decodeParams.decodeScales.length;\n-\n    var decodeOffsets = decodeParams.decodeOffsets;\n    var decodeScales = decodeParams.decodeScales;\n-\n    var deltaStart = meshParams.attribRange[ 0 ];\n    var numVerts = meshParams.attribRange[ 1 ];\n-\n    var codeStart = meshParams.codeRange[ 0 ];\n    var codeLength = meshParams.codeRange[ 1 ];\n-\n    var numIndices = 3 * meshParams.codeRange[ 2 ];\n-\n    var indicesOut = new Uint16Array( numIndices );\n-\n    var crosses = new Int32Array( 3 * numVerts );\n-\n    var lastAttrib = new Uint16Array( stride );\n-\n    var attribsOutFixed = new Uint16Array( stride * numVerts );\n    var attribsOut = new Float32Array( stride * numVerts );\n-\n    var highest = 0;\n    var outputStart = 0;\n-\n    for ( var i = 0; i < numIndices; i += 3 ) {\n-\n        var code = str.charCodeAt( codeStart ++ );\n-\n        var max_backref = Math.min( i, MAX_BACKREF );\n-\n        if ( code < max_backref ) {\n-\n-            \/\/ Parallelogram\n-\n            var winding = code % 3;\n            var backref = i - ( code - winding );\n            var i0, i1, i2;\n-\n            switch ( winding ) {\n-\n                case 0:\n-\n                    i0 = indicesOut[ backref + 2 ];\n                    i1 = indicesOut[ backref + 1 ];\n                    i2 = indicesOut[ backref + 0 ];\n                    break;\n-\n                case 1:\n-\n                    i0 = indicesOut[ backref + 0 ];\n                    i1 = indicesOut[ backref + 2 ];\n                    i2 = indicesOut[ backref + 1 ];\n                    break;\n-\n                case 2:\n-\n                    i0 = indicesOut[ backref + 1 ];\n                    i1 = indicesOut[ backref + 0 ];\n                    i2 = indicesOut[ backref + 2 ];\n                    break;\n-\n            }\n-\n            indicesOut[ outputStart ++ ] = i0;\n            indicesOut[ outputStart ++ ] = i1;\n-\n            code = str.charCodeAt( codeStart ++ );\n-\n            var index = highest - code;\n            indicesOut[ outputStart ++ ] = index;\n-\n            if ( code === 0 ) {\n-\n                for (var j = 0; j < 5; j ++ ) {\n-\n                    var deltaCode = str.charCodeAt( deltaStart + numVerts * j + highest );\n-\n                    var prediction = ((deltaCode >> 1) ^ (-(deltaCode & 1))) +\n-                        attribsOutFixed[stride * i0 + j] +\n-                        attribsOutFixed[stride * i1 + j] -\n-                        attribsOutFixed[stride * i2 + j];\n-\n+                        attribsOutFixed[stride * i0 + j] + attribsOutFixed[stride * i1 + j] - attribsOutFixed[stride * i2 + j];\n                    lastAttrib[j] = prediction;\n-\n                    attribsOutFixed[ stride * highest + j ] = prediction;\n                    attribsOut[ stride * highest + j ] = decodeScales[ j ] * ( prediction + decodeOffsets[ j ] );\n-\n                }\n-\n                highest ++;\n-\n            } else {\n-\n                this.copyAttrib( stride, attribsOutFixed, lastAttrib, index );\n-\n            }\n-\n            this.accumulateNormal( i0, i1, index, attribsOutFixed, crosses );\n-\n        } else {\n-\n-            \/\/ Simple\n-\n            var index0 = highest - ( code - max_backref );\n-\n            indicesOut[ outputStart ++ ] = index0;\n-\n            if ( code === max_backref ) {\n-\n-               this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\n-                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\n-                    highest ++ );\n-\n+               this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest ++ );\n            } else {\n-\n                this.copyAttrib(stride, attribsOutFixed, lastAttrib, index0);\n-\n            }\n-\n            code = str.charCodeAt( codeStart ++ );\n-\n            var index1 = highest - code;\n            indicesOut[ outputStart ++ ] = index1;\n-\n            if ( code === 0 ) {\n-\n-               this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\n-                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\n-                    highest ++ );\n-\n+               this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest ++ );\n            } else {\n-\n                this.copyAttrib( stride, attribsOutFixed, lastAttrib, index1 );\n-\n            }\n-\n            code = str.charCodeAt( codeStart ++ );\n-\n            var index2 = highest - code;\n            indicesOut[ outputStart ++ ] = index2;\n-\n            if ( code === 0 ) {\n-\n                for ( var j = 0; j < 5; j ++ ) {\n-\n                    lastAttrib[ j ] = ( attribsOutFixed[ stride * index0 + j ] + attribsOutFixed[ stride * index1 + j ] ) \/ 2;\n-\n                }\n-\n                this.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\n-                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\n-                    highest ++ );\n-\n+                    numVerts, attribsOut, attribsOutFixed, lastAttrib, highest ++ );\n            } else {\n-\n                this.copyAttrib( stride, attribsOutFixed, lastAttrib, index2 );\n-\n            }\n-\n            this.accumulateNormal( index0, index1, index2, attribsOutFixed, crosses );\n-\n        }\n-\n    }\n-\n    for ( var i = 0; i < numVerts; i ++ ) {\n-\n        var nx = crosses[ 3 * i ];\n        var ny = crosses[ 3 * i + 1 ];\n        var nz = crosses[ 3 * i + 2 ];\n-\n        var norm = 511.0 \/ Math.sqrt( nx * nx + ny * ny + nz * nz );\n-\n        var cx = str.charCodeAt( deltaStart + 5 * numVerts + i );\n        var cy = str.charCodeAt( deltaStart + 6 * numVerts + i );\n        var cz = str.charCodeAt( deltaStart + 7 * numVerts + i );\n-\n        attribsOut[ stride * i + 5 ] = norm * nx + ((cx >> 1) ^ (-(cx & 1)));\n        attribsOut[ stride * i + 6 ] = norm * ny + ((cy >> 1) ^ (-(cy & 1)));\n        attribsOut[ stride * i + 7 ] = norm * nz + ((cz >> 1) ^ (-(cz & 1)));\n    }\n-\n    callback( name, idx, attribsOut, indicesOut, undefined, meshParams );\n-\n };\n\n-THREE.UTF8Loader.prototype.downloadMesh = function ( path, name, meshEntry, decodeParams, callback ) {\n-\n+THREE.UTF8Loader.prototype.downloadMesh = function ( path, name, meshEntry, decodeParams, callback, callbackProgress ) {\n    var loader = this;\n    var idx = 0;\n-\n+   var xhr = new XMLHttpRequest();\n+   var length = 0;\n    function onprogress( req, e ) {\n-\n        while ( idx < meshEntry.length ) {\n-\n            var meshParams = meshEntry[ idx ];\n            var indexRange = meshParams.indexRange;\n-\n            if ( indexRange ) {\n-\n                var meshEnd = indexRange[ 0 ] + 3 * indexRange[ 1 ];\n-\n                if ( req.responseText.length < meshEnd ) break;\n-\n                loader.decompressMesh( req.responseText, meshParams, decodeParams, name, idx, callback );\n-\n            } else {\n-\n                var codeRange = meshParams.codeRange;\n                var meshEnd = codeRange[ 0 ] + codeRange[ 1 ];\n-\n                if ( req.responseText.length < meshEnd ) break;\n-\n                loader.decompressMesh2( req.responseText, meshParams, decodeParams, name, idx, callback );\n            }\n-\n            ++ idx;\n-\n        }\n-\n-   }\n-\n-   getHttpRequest( path, function( req, e ) {\n-\n-       if ( req.status === 200 || req.status === 0 ) {\n-\n-           onprogress( req, e );\n-\n+   };\n+   xhr.onreadystatechange = function( e ) {\n+       if ( xhr.readyState == 4 ) {\n+           if ( xhr.status == 200 || xhr.status == 0 ) {\n+               onprogress( xhr, e );\n+           }\n+       } else if ( xhr.readyState == 3 ) {\n+           if ( callbackProgress ) {\n+               if ( length == 0 ) {\n+                   length = xhr.getResponseHeader( \"Content-Length\" );\n+               }\n+               callbackProgress( {total: length, loaded: xhr.responseText.length} );\n+           }\n        }\n-\n-        \/\/ TODO: handle errors.\n-\n-   }, onprogress );\n-\n+   }\n+   xhr.open( \"GET\", path, true );\n+   xhr.send( null );\n };\n\n-THREE.UTF8Loader.prototype.downloadMeshes = function ( path, meshUrlMap, decodeParams, callback ) {\n-\n+THREE.UTF8Loader.prototype.downloadMeshes = function ( path, meshUrlMap, decodeParams, callback, callbackProgress ) {\n    for ( var url in meshUrlMap ) {\n-\n        var meshEntry = meshUrlMap[url];\n-       this.downloadMesh( path + url, url, meshEntry, decodeParams, callback );\n-\n+       this.downloadMesh( path + url, url, meshEntry, decodeParams, callback, callbackProgress );\n    }\n-\n };\n\n THREE.UTF8Loader.prototype.createMeshCallback = function( materialBaseUrl, loadModelInfo, allDoneCallback ) {\n-\n    var nCompletedUrls = 0;\n    var nExpectedUrls = 0;\n-\n    var expectedMeshesPerUrl = {};\n    var decodedMeshesPerUrl = {};\n-\n    var modelParts = {};\n-\n    var meshUrlMap = loadModelInfo.urls;\n-\n    for ( var url in meshUrlMap ) {\n-\n        expectedMeshesPerUrl[ url ] = meshUrlMap[ url ].length;\n        decodedMeshesPerUrl[ url ] = 0;\n-\n        nExpectedUrls ++;\n-\n        modelParts[ url ] = new THREE.Object3D();\n-\n    }\n-\n    var model = new THREE.Object3D();\n-\n-    \/\/ Prepare materials first...\n-\n    var materialCreator = new THREE.MTLLoader.MaterialCreator( materialBaseUrl, loadModelInfo.options );\n    materialCreator.setMaterials( loadModelInfo.materials );\n-\n    materialCreator.preload();\n-\n-   \/\/ Create callback for creating mesh parts\n-\n    var bufferGeometryCreator = new THREE.UTF8Loader.BufferGeometryCreator();\n-\n    var meshCallback = function( name, idx, attribArray, indexArray, bboxen, meshParams ) {\n-\n-        \/\/ Got ourselves a new mesh\n-\n-        \/\/ name identifies this part of the model (url)\n-        \/\/ idx is the mesh index of this mesh of the part\n-        \/\/ attribArray defines the vertices\n-        \/\/ indexArray defines the faces\n-        \/\/ bboxen defines the bounding box\n-        \/\/ meshParams contains the material info\n-\n        var geometry = bufferGeometryCreator.create( attribArray, indexArray );\n        var material = materialCreator.create( meshParams.material );\n-\n        var mesh = new THREE.Mesh( geometry, material );\n        modelParts[ name ].add( mesh );\n-\n         \/\/model.add(new THREE.Mesh(geometry, material));\n-\n        decodedMeshesPerUrl[ name ] ++;\n-\n        if ( decodedMeshesPerUrl[ name ] === expectedMeshesPerUrl[ name ] ) {\n-\n            nCompletedUrls ++;\n-\n            model.add( modelParts[ name ] );\n-\n            if ( nCompletedUrls === nExpectedUrls ) {\n-\n-                \/\/ ALL DONE!!!\n-\n                allDoneCallback( model );\n-\n            }\n-\n        }\n-\n    };\n-\n    return meshCallback;\n-\n };\n\n-THREE.UTF8Loader.prototype.downloadModel = function ( geometryBase, materialBase, model, callback ) {\n-\n+THREE.UTF8Loader.prototype.downloadModel = function ( geometryBase, materialBase, model, callback, callbackProgress ) {\n    var meshCallback = this.createMeshCallback( materialBase, model, callback );\n-   this.downloadMeshes( geometryBase, model.urls, model.decodeParams, meshCallback );\n-\n+   this.downloadMeshes( geometryBase, model.urls, model.decodeParams, meshCallback, callbackProgress );\n };\n\n-THREE.UTF8Loader.prototype.downloadModelJson = function ( jsonUrl, callback, options ) {\n-\n-   getJsonRequest( jsonUrl, function( loaded ) {\n-\n+THREE.UTF8Loader.prototype.downloadModelJson = function ( jsonUrl, callback, options, callbackProgress ) {\n+   this.getJsonRequest( jsonUrl, function( loaded ) {\n        if ( ! loaded.decodeParams ) {\n-\n            if ( options && options.decodeParams ) {\n-\n                loaded.decodeParams = options.decodeParams;\n-\n            } else {\n-\n                loaded.decodeParams = DEFAULT_DECODE_PARAMS;\n-\n            }\n-\n        }\n-\n        loaded.options = options;\n-\n        var geometryBase = jsonUrl.substr( 0, jsonUrl.lastIndexOf( \"\/\" ) + 1 );\n        var materialBase = geometryBase;\n-\n        if ( options && options.geometryBase ) {\n-\n            geometryBase = options.geometryBase;\n-\n            if ( geometryBase.charAt( geometryBase.length - 1 ) !== \"\/\" ) {\n-\n                geometryBase = geometryBase + \"\/\";\n-\n            }\n-\n        }\n-\n        if ( options && options.materialBase ) {\n-\n            materialBase = options.materialBase;\n-\n            if ( materialBase.charAt( materialBase.length - 1 ) !== \"\/\" ) {\n-\n                materialBase = materialBase  + \"\/\";\n-\n            }\n-\n        }\n-\n-       this.downloadModel( geometryBase, materialBase, loaded, callback );\n-\n+       this.downloadModel( geometryBase, materialBase, loaded, callback, callbackProgress );\n    }.bind( this ) );\n-\n };\n\n-\/\/ XMLHttpRequest stuff\n-\n-function getHttpRequest( url, onload, opt_onprogress ) {\n-\n+THREE.UTF8Loader.prototype.getHttpRequest = function( url, onload, opt_onprogress ) {\n    var LISTENERS = {\n-\n-        load: function( e ) { onload( req, e ); },\n-        progress: function( e ) { opt_onprogress( req, e ); }\n-\n-    };\n-\n+           load: function( e ) { onload( req, e ); },\n+           progress: function( e ) { opt_onprogress( e ); }\n+   };\n    var req = new XMLHttpRequest();\n-   addListeners( req, LISTENERS );\n-\n+   this.addListeners( req, LISTENERS );\n    req.open( 'GET', url, true );\n    req.send( null );\n }\n\n-function getJsonRequest( url, onjson ) {\n-\n-   getHttpRequest( url,\n+THREE.UTF8Loader.prototype.getJsonRequest = function( url, onjson ) {\n+   this.getHttpRequest( url,\n         function( e ) { onjson( JSON.parse( e.responseText ) ); },\n         function() {} );\n-\n }\n\n-function addListeners( dom, listeners ) {\n-\n+THREE.UTF8Loader.prototype.addListeners = function( dom, listeners ) {\n     \/\/ TODO: handle event capture, object binding.\n-\n    for ( var key in listeners ) {\n-\n        dom.addEventListener( key, listeners[ key ] );\n-\n    }\n }\n```\n","created_at":"2015-04-21T13:43:16.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/6350#issuecomment-94796890","id":94796890,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/6350","node_id":"MDEyOklzc3VlQ29tbWVudDk0Nzk2ODkw","updated_at":"2015-04-21T13:43:16.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/94796890","user":{"following_url":"https:\/\/api.github.com\/users\/mrdoob\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/mrdoob\/events{\/privacy}","avatar_url":"https:\/\/avatars0.githubusercontent.com\/u\/97088?v=4","url":"https:\/\/api.github.com\/users\/mrdoob","gists_url":"https:\/\/api.github.com\/users\/mrdoob\/gists{\/gist_id}","html_url":"https:\/\/github.com\/mrdoob","subscriptions_url":"https:\/\/api.github.com\/users\/mrdoob\/subscriptions","node_id":"MDQ6VXNlcjk3MDg4","repos_url":"https:\/\/api.github.com\/users\/mrdoob\/repos","received_events_url":"https:\/\/api.github.com\/users\/mrdoob\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/mrdoob\/starred{\/owner}{\/repo}","site_admin":false,"login":"mrdoob","type":"User","id":97088,"followers_url":"https:\/\/api.github.com\/users\/mrdoob\/followers","organizations_url":"https:\/\/api.github.com\/users\/mrdoob\/orgs"}},{"index":2,"author_association":"CONTRIBUTOR","body":"It's 100% backward compatible with the previous one.\nI didn't modify the JSON loader part because no one needs onProgress for a few hundred bytes.\nThe major update is related to the downloadMesh part (the UTF8 file loader), because that's the one with MB involved.\nFeel free to replace the old file if you like.\n","created_at":"2015-04-21T13:56:35.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/6350#issuecomment-94801867","id":94801867,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/6350","node_id":"MDEyOklzc3VlQ29tbWVudDk0ODAxODY3","updated_at":"2015-04-21T13:56:35.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/94801867","user":{"following_url":"https:\/\/api.github.com\/users\/RemusMar\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/RemusMar\/events{\/privacy}","avatar_url":"https:\/\/avatars1.githubusercontent.com\/u\/11772787?v=4","url":"https:\/\/api.github.com\/users\/RemusMar","gists_url":"https:\/\/api.github.com\/users\/RemusMar\/gists{\/gist_id}","html_url":"https:\/\/github.com\/RemusMar","subscriptions_url":"https:\/\/api.github.com\/users\/RemusMar\/subscriptions","node_id":"MDQ6VXNlcjExNzcyNzg3","repos_url":"https:\/\/api.github.com\/users\/RemusMar\/repos","received_events_url":"https:\/\/api.github.com\/users\/RemusMar\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/RemusMar\/starred{\/owner}{\/repo}","site_admin":false,"login":"RemusMar","type":"User","id":11772787,"followers_url":"https:\/\/api.github.com\/users\/RemusMar\/followers","organizations_url":"https:\/\/api.github.com\/users\/RemusMar\/orgs"}},{"index":3,"author_association":"OWNER","body":"As you can see on my previous post, many things changed. It's not clear what did actually change and I can't blindly replace the file. Also, seems like you removed the credits from all the original authors of the file.\n","created_at":"2015-04-21T14:10:27.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/6350#issuecomment-94809124","id":94809124,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/6350","node_id":"MDEyOklzc3VlQ29tbWVudDk0ODA5MTI0","updated_at":"2015-04-21T14:11:09.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/94809124","user":{"following_url":"https:\/\/api.github.com\/users\/mrdoob\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/mrdoob\/events{\/privacy}","avatar_url":"https:\/\/avatars0.githubusercontent.com\/u\/97088?v=4","url":"https:\/\/api.github.com\/users\/mrdoob","gists_url":"https:\/\/api.github.com\/users\/mrdoob\/gists{\/gist_id}","html_url":"https:\/\/github.com\/mrdoob","subscriptions_url":"https:\/\/api.github.com\/users\/mrdoob\/subscriptions","node_id":"MDQ6VXNlcjk3MDg4","repos_url":"https:\/\/api.github.com\/users\/mrdoob\/repos","received_events_url":"https:\/\/api.github.com\/users\/mrdoob\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/mrdoob\/starred{\/owner}{\/repo}","site_admin":false,"login":"mrdoob","type":"User","id":97088,"followers_url":"https:\/\/api.github.com\/users\/mrdoob\/followers","organizations_url":"https:\/\/api.github.com\/users\/mrdoob\/orgs"}},{"index":4,"author_association":"CONTRIBUTOR","body":"I always remove all the comments inside of the downloaded files.\nSmaller files = faster download.\nNot to mention that it saves server bandwidth ...\n","created_at":"2015-04-21T14:15:33.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/6350#issuecomment-94810650","id":94810650,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/6350","node_id":"MDEyOklzc3VlQ29tbWVudDk0ODEwNjUw","updated_at":"2015-04-21T14:15:45.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/94810650","user":{"following_url":"https:\/\/api.github.com\/users\/RemusMar\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/RemusMar\/events{\/privacy}","avatar_url":"https:\/\/avatars1.githubusercontent.com\/u\/11772787?v=4","url":"https:\/\/api.github.com\/users\/RemusMar","gists_url":"https:\/\/api.github.com\/users\/RemusMar\/gists{\/gist_id}","html_url":"https:\/\/github.com\/RemusMar","subscriptions_url":"https:\/\/api.github.com\/users\/RemusMar\/subscriptions","node_id":"MDQ6VXNlcjExNzcyNzg3","repos_url":"https:\/\/api.github.com\/users\/RemusMar\/repos","received_events_url":"https:\/\/api.github.com\/users\/RemusMar\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/RemusMar\/starred{\/owner}{\/repo}","site_admin":false,"login":"RemusMar","type":"User","id":11772787,"followers_url":"https:\/\/api.github.com\/users\/RemusMar\/followers","organizations_url":"https:\/\/api.github.com\/users\/RemusMar\/orgs"}},{"index":5,"author_association":"COLLABORATOR","body":"`UTF8Loader` has been removed via #14363","created_at":"2018-07-18T20:13:27.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/6350#issuecomment-406059412","id":406059412,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/6350","node_id":"MDEyOklzc3VlQ29tbWVudDQwNjA1OTQxMg==","updated_at":"2018-07-18T20:13:27.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/406059412","user":{"following_url":"https:\/\/api.github.com\/users\/Mugen87\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/Mugen87\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/12612165?v=4","url":"https:\/\/api.github.com\/users\/Mugen87","gists_url":"https:\/\/api.github.com\/users\/Mugen87\/gists{\/gist_id}","html_url":"https:\/\/github.com\/Mugen87","subscriptions_url":"https:\/\/api.github.com\/users\/Mugen87\/subscriptions","node_id":"MDQ6VXNlcjEyNjEyMTY1","repos_url":"https:\/\/api.github.com\/users\/Mugen87\/repos","received_events_url":"https:\/\/api.github.com\/users\/Mugen87\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/Mugen87\/starred{\/owner}{\/repo}","site_admin":false,"login":"Mugen87","type":"User","id":12612165,"followers_url":"https:\/\/api.github.com\/users\/Mugen87\/followers","organizations_url":"https:\/\/api.github.com\/users\/Mugen87\/orgs"}}]}