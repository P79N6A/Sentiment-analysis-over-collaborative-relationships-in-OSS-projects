{"schema": {"fields":[{"type":"integer","name":"index"},{"type":"string","name":"author_association"},{"type":"string","name":"body"},{"type":"datetime","name":"created_at"},{"type":"string","name":"html_url"},{"type":"integer","name":"id"},{"type":"string","name":"issue_url"},{"type":"string","name":"node_id"},{"type":"datetime","name":"updated_at"},{"type":"string","name":"url"},{"type":"string","name":"user"}],"pandas_version":"0.20.0","primaryKey":["index"]}, "data": [{"index":0,"author_association":"COLLABORATOR","body":"Correct. Raycasting against sprites has always been an approximation.\r\n\r\nThe approximation is worse if the sprite is non-uniformly scaled and rotated.\r\n\r\nSprite `center` was recently added, and raycasting does not take the center into consideration, either.\r\n\r\nAlso, areas of transparency in a sprite are not honored.\r\n\r\n>I'm going to also throw something up on StackExchange to see if someone has a quick fix for me,\r\n\r\nGood luck with that...","created_at":"2018-04-03T05:21:17.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13751#issuecomment-378131584","id":378131584,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13751","node_id":"MDEyOklzc3VlQ29tbWVudDM3ODEzMTU4NA==","updated_at":"2018-04-03T05:21:17.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/378131584","user":{"following_url":"https:\/\/api.github.com\/users\/WestLangley\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/WestLangley\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/1000017?v=4","url":"https:\/\/api.github.com\/users\/WestLangley","gists_url":"https:\/\/api.github.com\/users\/WestLangley\/gists{\/gist_id}","html_url":"https:\/\/github.com\/WestLangley","subscriptions_url":"https:\/\/api.github.com\/users\/WestLangley\/subscriptions","node_id":"MDQ6VXNlcjEwMDAwMTc=","repos_url":"https:\/\/api.github.com\/users\/WestLangley\/repos","received_events_url":"https:\/\/api.github.com\/users\/WestLangley\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/WestLangley\/starred{\/owner}{\/repo}","site_admin":false,"login":"WestLangley","type":"User","id":1000017,"followers_url":"https:\/\/api.github.com\/users\/WestLangley\/followers","organizations_url":"https:\/\/api.github.com\/users\/WestLangley\/orgs"}},{"index":1,"author_association":"COLLABORATOR","body":"Also, a non-rotated sprite always renders right-side-up even if the camera is tilted. That is, if the camera is upside-down, the rendered sprite will still appear right-side-up.\r\n\r\nThis behavior would need to be accommodated if raycasting against sprites is to be handled accurately.\r\n\r\nIf you are satisfied with an approximation, as we have been so far, then all that is required is to get the center of the sprite correct, and the scale close-to-correct. This is reasonable, because users will typically click near the center of the sprite.","created_at":"2018-04-03T05:43:14.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13751#issuecomment-378134849","id":378134849,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13751","node_id":"MDEyOklzc3VlQ29tbWVudDM3ODEzNDg0OQ==","updated_at":"2018-04-03T05:43:14.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/378134849","user":{"following_url":"https:\/\/api.github.com\/users\/WestLangley\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/WestLangley\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/1000017?v=4","url":"https:\/\/api.github.com\/users\/WestLangley","gists_url":"https:\/\/api.github.com\/users\/WestLangley\/gists{\/gist_id}","html_url":"https:\/\/github.com\/WestLangley","subscriptions_url":"https:\/\/api.github.com\/users\/WestLangley\/subscriptions","node_id":"MDQ6VXNlcjEwMDAwMTc=","repos_url":"https:\/\/api.github.com\/users\/WestLangley\/repos","received_events_url":"https:\/\/api.github.com\/users\/WestLangley\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/WestLangley\/starred{\/owner}{\/repo}","site_admin":false,"login":"WestLangley","type":"User","id":1000017,"followers_url":"https:\/\/api.github.com\/users\/WestLangley\/followers","organizations_url":"https:\/\/api.github.com\/users\/WestLangley\/orgs"}},{"index":2,"author_association":"NONE","body":"Yeah, I think that an approximation is fine in general.  But I think that to solve the other issues, like raycasting not handling changes to the center, the solution will most likely just have to be exact.\r\n\r\nAt first I was hoping that I could just make some sort of bounding box that contains every possible orientation of the sprite.  Unfortunately that doesn't work, because the bounding box would have to be about 2x the size of the actual sprite.  So, that ends up being even worse than the disc approximation.\r\n\r\nIn my head, I feel like somehow the camera needs to passed into the raycaster.  That way the rotation of the camera could be used to determine the tilt of the sprite's plane.  Does that make sense?  I'm rusty on my linear algebra, and I can't really think through in my head how it would work, but I'm confident that knowing the rotation of the camera would give enough information to translate the original center to where it currently is.\r\n\r\nIf anyone has any input I'm happy to translate the math into the code.  I just can't put it all together...","created_at":"2018-04-03T15:05:20.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13751#issuecomment-378283015","id":378283015,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13751","node_id":"MDEyOklzc3VlQ29tbWVudDM3ODI4MzAxNQ==","updated_at":"2018-04-03T15:05:20.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/378283015","user":{"following_url":"https:\/\/api.github.com\/users\/mrz5018\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/mrz5018\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/3534492?v=4","url":"https:\/\/api.github.com\/users\/mrz5018","gists_url":"https:\/\/api.github.com\/users\/mrz5018\/gists{\/gist_id}","html_url":"https:\/\/github.com\/mrz5018","subscriptions_url":"https:\/\/api.github.com\/users\/mrz5018\/subscriptions","node_id":"MDQ6VXNlcjM1MzQ0OTI=","repos_url":"https:\/\/api.github.com\/users\/mrz5018\/repos","received_events_url":"https:\/\/api.github.com\/users\/mrz5018\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/mrz5018\/starred{\/owner}{\/repo}","site_admin":false,"login":"mrz5018","type":"User","id":3534492,"followers_url":"https:\/\/api.github.com\/users\/mrz5018\/followers","organizations_url":"https:\/\/api.github.com\/users\/mrz5018\/orgs"}},{"index":3,"author_association":"CONTRIBUTOR","body":"when ever I need something sprite-like and clickable, I just end up using a plane with .quaternion.copy(camera.quaternion) in .updateMatrixWorld or somewhere. this way you use same raycast code that you use for meshes.\r\n\r\nanother bonus is that you are free to change shaders to whatever you want (without [hax](http:\/\/jsrun.it\/makc\/cozIcan)).","created_at":"2018-05-02T12:31:39.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13751#issuecomment-385961737","id":385961737,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13751","node_id":"MDEyOklzc3VlQ29tbWVudDM4NTk2MTczNw==","updated_at":"2018-05-02T12:39:13.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/385961737","user":{"following_url":"https:\/\/api.github.com\/users\/makc\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/makc\/events{\/privacy}","avatar_url":"https:\/\/avatars0.githubusercontent.com\/u\/242577?v=4","url":"https:\/\/api.github.com\/users\/makc","gists_url":"https:\/\/api.github.com\/users\/makc\/gists{\/gist_id}","html_url":"https:\/\/github.com\/makc","subscriptions_url":"https:\/\/api.github.com\/users\/makc\/subscriptions","node_id":"MDQ6VXNlcjI0MjU3Nw==","repos_url":"https:\/\/api.github.com\/users\/makc\/repos","received_events_url":"https:\/\/api.github.com\/users\/makc\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/makc\/starred{\/owner}{\/repo}","site_admin":false,"login":"makc","type":"User","id":242577,"followers_url":"https:\/\/api.github.com\/users\/makc\/followers","organizations_url":"https:\/\/api.github.com\/users\/makc\/orgs"}},{"index":4,"author_association":"CONTRIBUTOR","body":"Agreed. It would probably require more optimization if it was on mouse move, but on mouse click you should be able to rotate the planes and cast against them. Drawing can be a completely different thing,  preferably instancing the same quad. \r\n\r\nOne optimization could be, test against the bounding spheres, and then rotate only the ones that pass. ","created_at":"2018-05-02T18:14:01.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13751#issuecomment-386071170","id":386071170,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13751","node_id":"MDEyOklzc3VlQ29tbWVudDM4NjA3MTE3MA==","updated_at":"2018-05-02T18:15:29.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/386071170","user":{"following_url":"https:\/\/api.github.com\/users\/pailhead\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/pailhead\/events{\/privacy}","avatar_url":"https:\/\/avatars0.githubusercontent.com\/u\/4681282?v=4","url":"https:\/\/api.github.com\/users\/pailhead","gists_url":"https:\/\/api.github.com\/users\/pailhead\/gists{\/gist_id}","html_url":"https:\/\/github.com\/pailhead","subscriptions_url":"https:\/\/api.github.com\/users\/pailhead\/subscriptions","node_id":"MDQ6VXNlcjQ2ODEyODI=","repos_url":"https:\/\/api.github.com\/users\/pailhead\/repos","received_events_url":"https:\/\/api.github.com\/users\/pailhead\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/pailhead\/starred{\/owner}{\/repo}","site_admin":false,"login":"pailhead","type":"User","id":4681282,"followers_url":"https:\/\/api.github.com\/users\/pailhead\/followers","organizations_url":"https:\/\/api.github.com\/users\/pailhead\/orgs"}},{"index":5,"author_association":"NONE","body":"@makc You're 100% right, this is a much easier way to handle the situation.  I just do a `plane.quaternion.copy(camera.quaternion)` and that seems to do the trick.\r\n\r\nI'll need to figure out a way to mimic the `sprite.center` functionality on a plane geometry, but this completely alleviates the raycasting issue.","created_at":"2018-05-03T19:28:04.000Z","html_url":"https:\/\/github.com\/mrdoob\/three.js\/issues\/13751#issuecomment-386409481","id":386409481,"issue_url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/13751","node_id":"MDEyOklzc3VlQ29tbWVudDM4NjQwOTQ4MQ==","updated_at":"2018-05-03T19:28:04.000Z","url":"https:\/\/api.github.com\/repos\/mrdoob\/three.js\/issues\/comments\/386409481","user":{"following_url":"https:\/\/api.github.com\/users\/mrz5018\/following{\/other_user}","events_url":"https:\/\/api.github.com\/users\/mrz5018\/events{\/privacy}","avatar_url":"https:\/\/avatars2.githubusercontent.com\/u\/3534492?v=4","url":"https:\/\/api.github.com\/users\/mrz5018","gists_url":"https:\/\/api.github.com\/users\/mrz5018\/gists{\/gist_id}","html_url":"https:\/\/github.com\/mrz5018","subscriptions_url":"https:\/\/api.github.com\/users\/mrz5018\/subscriptions","node_id":"MDQ6VXNlcjM1MzQ0OTI=","repos_url":"https:\/\/api.github.com\/users\/mrz5018\/repos","received_events_url":"https:\/\/api.github.com\/users\/mrz5018\/received_events","gravatar_id":"","starred_url":"https:\/\/api.github.com\/users\/mrz5018\/starred{\/owner}{\/repo}","site_admin":false,"login":"mrz5018","type":"User","id":3534492,"followers_url":"https:\/\/api.github.com\/users\/mrz5018\/followers","organizations_url":"https:\/\/api.github.com\/users\/mrz5018\/orgs"}}]}